-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ByteString-Text hexidecimal conversions
--   
--   Encode a ByteString as a hexidecimal Text value, or decode hexidecimal
--   Text as a ByteString.
@package hex-text
@version 0.1.0.0

module Text.Hex

-- | Encodes a byte string as hexidecimal number represented in text. Each
--   byte of the input is converted into two characters in the resulting
--   text.
--   
--   <pre>
--   &gt;&gt;&gt; (encodeHex . ByteString.singleton) 192
--   "c0"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (encodeHex . ByteString.singleton) 168
--   "a8"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (encodeHex . ByteString.pack) [192, 168, 1, 2]
--   "c0a80102"
--   </pre>
--   
--   <a>Text</a> produced by <tt>encodeHex</tt> can be converted back to a
--   <a>ByteString</a> using <a>decodeHex</a>.
--   
--   The lazy variant of <tt>encodeHex</tt> is <a>lazilyEncodeHex</a>.
encodeHex :: ByteString -> Text

-- | Decodes hexidecimal text as a byte string. If the text contains an
--   even number of characters and consists only of the digits <tt>0</tt>
--   through <tt>9</tt> and letters <tt>a</tt> through <tt>f</tt>, then the
--   result is a <a>Just</a> value.
--   
--   <pre>
--   &gt;&gt;&gt; (fmap ByteString.unpack . decodeHex . Text.pack) "c0a80102"
--   Just [192,168,1,2]
--   </pre>
--   
--   If the text contains an odd number of characters, decoding fails and
--   produces <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (fmap ByteString.unpack . decodeHex . Text.pack) "c0a8010"
--   Nothing
--   </pre>
--   
--   If the text contains non-hexidecimal characters, decoding fails and
--   produces <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (fmap ByteString.unpack . decodeHex . Text.pack) "x0a80102"
--   Nothing
--   </pre>
--   
--   The letters may be in either upper or lower case. This next example
--   therefore gives the same result as the first one above:
--   
--   <pre>
--   &gt;&gt;&gt; (fmap ByteString.unpack . decodeHex . Text.pack) "C0A80102"
--   Just [192,168,1,2]
--   </pre>
decodeHex :: Text -> Maybe ByteString

-- | <tt>lazilyEncodeHex</tt> is the lazy variant of <a>encodeHex</a>.
--   
--   With laziness, it is possible to encode byte strings of infinite
--   length:
--   
--   <pre>
--   &gt;&gt;&gt; (LazyText.take 8 . lazilyEncodeHex . LazyByteString.pack . cycle) [1, 2, 3]
--   "01020301"
--   </pre>
lazilyEncodeHex :: LazyByteString -> LazyText

-- | Strict text
type Text = Text

-- | Lazy text
type LazyText = Text

-- | Strict byte string
type ByteString = ByteString

-- | Lazy byte string
type LazyByteString = ByteString
lazyText :: Text -> LazyText
strictText :: LazyText -> Text
lazyByteString :: ByteString -> LazyByteString
strictByteString :: LazyByteString -> ByteString
