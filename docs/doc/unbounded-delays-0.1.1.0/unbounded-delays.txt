-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Unbounded thread delays and timeouts
--   
--   The <tt>threadDelay</tt> and <tt>timeout</tt> functions from the
--   <tt>base</tt> library use the bounded <tt>Int</tt> type for specifying
--   the delay or timeout period. This packages provides alternatives which
--   use the unbounded <tt>Integer</tt> type.
@package unbounded-delays
@version 0.1.1.0


-- | Arbitrarily long thread delays.
module Control.Concurrent.Thread.Delay

-- | Like <tt>Control.Concurrent.<a>threadDelay</a></tt>, but not bounded
--   by an <a>Int</a>.
--   
--   Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   earlier than specified.
delay :: Integer -> IO ()


-- | Wait arbitrarily long for an IO computation to finish.
module Control.Concurrent.Timeout

-- | Like <a>timeoutWithPred</a>, but does not expose the <a>Timeout</a>
--   exception to the called action.
timeout :: Integer -> IO α -> IO (Maybe α)
data Timeout

-- | Like <tt>System.Timeout.<a>timeout</a></tt>, but not bounded by an
--   <a>Int</a>. (..) Wrap an <a>IO</a> computation to time out and return
--   <a>Nothing</a> in case no result is available within <tt>n</tt>
--   microseconds (<tt>1/10^6</tt> seconds). In case a result is available
--   before the timeout expires, <a>Just</a> <tt>a</tt> is returned. A
--   negative timeout interval means "wait indefinitely".
--   
--   If the computation has not terminated after <tt>n</tt> microseconds,
--   it is interrupted by an asynchronous exception. The function passed to
--   <tt>f</tt> can be used to detect whether it was interrupted by this
--   timeout or some other exception.
--   
--   The design of this combinator was guided by the objective that
--   <tt>timeout n (const f)</tt> should behave exactly the same as
--   <tt>f</tt> as long as <tt>f</tt> doesn't time out. This means that
--   <tt>f</tt> has the same <a>myThreadId</a> it would have without the
--   timeout wrapper. Any exceptions <tt>f</tt> might throw cancel the
--   timeout and propagate further up. It also possible for <tt>f</tt> to
--   receive exceptions thrown to it by another thread.
--   
--   A tricky implementation detail is the question of how to abort an
--   <a>IO</a> computation. This combinator relies on asynchronous
--   exceptions internally. The technique works very well for computations
--   executing inside of the Haskell runtime system, but it doesn't work at
--   all for non-Haskell code. Foreign function calls, for example, cannot
--   be timed out with this combinator simply because an arbitrary C
--   function cannot receive asynchronous exceptions. When <tt>timeout</tt>
--   is used to wrap an FFI call that blocks, no timeout event can be
--   delivered until the FFI call returns, which pretty much negates the
--   purpose of the combinator. In practice, however, this limitation is
--   less severe than it may sound. Standard I/O functions like
--   <a>hGetBuf</a>, <a>hPutBuf</a>, Network.Socket.accept, or
--   <a>hWaitForInput</a> appear to be blocking, but they really don't
--   because the runtime system uses scheduling mechanisms like
--   <tt>select(2)</tt> to perform asynchronous I/O, so it is possible to
--   interrupt standard socket I/O or file I/O using this combinator.
timeoutWithPred :: Integer -> ((Timeout -> Bool) -> IO α) -> IO (Maybe α)
instance GHC.Classes.Eq Control.Concurrent.Timeout.Timeout
instance GHC.Show.Show Control.Concurrent.Timeout.Timeout
instance GHC.Exception.Type.Exception Control.Concurrent.Timeout.Timeout
