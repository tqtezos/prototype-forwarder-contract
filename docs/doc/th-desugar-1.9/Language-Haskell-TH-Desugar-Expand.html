<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Language.Haskell.TH.Desugar.Expand</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Language.Haskell.TH.Desugar.Expand.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">th-desugar-1.9: Functions to desugar Template Haskell</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(C) 2014 Richard Eisenberg</td></tr><tr><th>License</th><td>BSD-style (see LICENSE)</td></tr><tr><th>Maintainer</th><td>Ryan Scott</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>non-portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Language.Haskell.TH.Desugar.Expand</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Expand synonyms soundly</a></li><li><a href="#g:2">Expand synonyms potentially unsoundly</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Expands type synonyms and type families in desugared types.
 See also the package th-expand-syns for doing this to
 non-desugared types.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:expand">expand</a> :: (<a href="Language-Haskell-TH-Desugar.html#t:DsMonad" title="Language.Haskell.TH.Desugar">DsMonad</a> q, <a href="../base-4.12.0.0/Data-Data.html#t:Data" title="Data.Data">Data</a> a) =&gt; a -&gt; q a</li><li class="src short"><a href="#v:expandType">expandType</a> :: <a href="Language-Haskell-TH-Desugar.html#t:DsMonad" title="Language.Haskell.TH.Desugar">DsMonad</a> q =&gt; <a href="Language-Haskell-TH-Desugar.html#t:DType" title="Language.Haskell.TH.Desugar">DType</a> -&gt; q <a href="Language-Haskell-TH-Desugar.html#t:DType" title="Language.Haskell.TH.Desugar">DType</a></li><li class="src short"><a href="#v:expandUnsoundly">expandUnsoundly</a> :: (<a href="Language-Haskell-TH-Desugar.html#t:DsMonad" title="Language.Haskell.TH.Desugar">DsMonad</a> q, <a href="../base-4.12.0.0/Data-Data.html#t:Data" title="Data.Data">Data</a> a) =&gt; a -&gt; q a</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Expand synonyms soundly</h1></a><div class="top"><p class="src"><a id="v:expand" class="def">expand</a> :: (<a href="Language-Haskell-TH-Desugar.html#t:DsMonad" title="Language.Haskell.TH.Desugar">DsMonad</a> q, <a href="../base-4.12.0.0/Data-Data.html#t:Data" title="Data.Data">Data</a> a) =&gt; a -&gt; q a <a href="src/Language.Haskell.TH.Desugar.Expand.html#expand" class="link">Source</a> <a href="#v:expand" class="selflink">#</a></p><div class="doc"><p>Expand all type synonyms and type families in the desugared abstract
 syntax tree provided, where type family simplification is on a &quot;best effort&quot;
 basis. Normally, the first parameter should have a type like
 <code><a href="Language-Haskell-TH-Desugar.html#t:DExp" title="Language.Haskell.TH.Desugar">DExp</a></code> or <code><a href="Language-Haskell-TH-Desugar.html#t:DLetDec" title="Language.Haskell.TH.Desugar">DLetDec</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:expandType" class="def">expandType</a> :: <a href="Language-Haskell-TH-Desugar.html#t:DsMonad" title="Language.Haskell.TH.Desugar">DsMonad</a> q =&gt; <a href="Language-Haskell-TH-Desugar.html#t:DType" title="Language.Haskell.TH.Desugar">DType</a> -&gt; q <a href="Language-Haskell-TH-Desugar.html#t:DType" title="Language.Haskell.TH.Desugar">DType</a> <a href="src/Language.Haskell.TH.Desugar.Expand.html#expandType" class="link">Source</a> <a href="#v:expandType" class="selflink">#</a></p><div class="doc"><p>Expands all type synonyms in a desugared type. Also expands open type family
 applications. (In GHCs before 7.10, this part does not work if there are any
 variables.) Attempts to
 expand closed type family applications, but aborts the moment it spots anything
 strange, like a nested type family application or type variable.</p></div></div><a href="#g:2" id="g:2"><h1>Expand synonyms potentially unsoundly</h1></a><div class="top"><p class="src"><a id="v:expandUnsoundly" class="def">expandUnsoundly</a> :: (<a href="Language-Haskell-TH-Desugar.html#t:DsMonad" title="Language.Haskell.TH.Desugar">DsMonad</a> q, <a href="../base-4.12.0.0/Data-Data.html#t:Data" title="Data.Data">Data</a> a) =&gt; a -&gt; q a <a href="src/Language.Haskell.TH.Desugar.Expand.html#expandUnsoundly" class="link">Source</a> <a href="#v:expandUnsoundly" class="selflink">#</a></p><div class="doc"><p>Expand all type synonyms and type families in the desugared abstract
 syntax tree provided, where type family simplification is on a &quot;better
 than best effort&quot; basis. This means that it will try so hard that it will
 sometimes do the wrong thing. Specifically, any kind parameters to type
 families are ignored. So, if we have</p><pre>type family F (x :: k) where
  F (a :: *) = Int</pre><p><code><a href="Language-Haskell-TH-Desugar-Expand.html#v:expandUnsoundly" title="Language.Haskell.TH.Desugar.Expand">expandUnsoundly</a></code> will expand <code>F 'True</code> to <code>Int</code>, ignoring that the
 expansion should only work for type of kind <code>*</code>.</p><p>This function is useful because plain old <code><a href="Language-Haskell-TH-Desugar-Expand.html#v:expand" title="Language.Haskell.TH.Desugar.Expand">expand</a></code> will simply fail
 to expand type families that make use of kinds. Sometimes, the kinds
 are benign and we want to expand anyway. Use this function in that case.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>