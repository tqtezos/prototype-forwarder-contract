-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Wadler/Leijen Pretty Printer for Text values
--   
--   A clone of wl-pprint for use with the text library.
@package wl-pprint-text
@version 1.2.0.0


-- | This library is a port of the <i>wl-pprint</i> package to use
--   <a>Doc</a> values rather than <a>String</a>s.
--   
--   Pretty print module based on Philip Wadler's "prettier printer"
--   
--   <pre>
--   "A prettier printer"
--   Draft paper, April 1997, revised March 1998.
--   <a>http://cm.bell-labs.com/cm/cs/who/wadler/papers/prettier/prettier.ps</a>
--   </pre>
--   
--   PPrint is an implementation of the pretty printing combinators
--   described by Philip Wadler (1997). In their bare essence, the
--   combinators of Wadler are not expressive enough to describe some
--   commonly occurring layouts. The PPrint library adds new primitives to
--   describe these layouts and works well in practice.
--   
--   The library is based on a single way to concatenate documents, which
--   is associative and has both a left and right unit. This simple design
--   leads to an efficient and short implementation. The simplicity is
--   reflected in the predictable behaviour of the combinators which make
--   them easy to use in practice.
--   
--   A thorough description of the primitive combinators and their
--   implementation can be found in Philip Wadler's paper (1997). Additions
--   and the main differences with his original paper are:
--   
--   <ul>
--   <li>The nil document is called empty.</li>
--   <li>The above combinator is called <a>&lt;$&gt;</a>. The operator
--   <a>&lt;/&gt;</a> is used for soft line breaks.</li>
--   <li>There are three new primitives: <a>align</a>, <a>fill</a> and
--   <a>fillBreak</a>. These are very useful in practice.</li>
--   <li>Lots of other useful combinators, like <a>fillSep</a> and
--   <a>list</a>.</li>
--   <li>There are two renderers, <a>renderPretty</a> for pretty printing
--   and <a>renderCompact</a> for compact output. The pretty printing
--   algorithm also uses a ribbon-width now for even prettier output.</li>
--   <li>There are two displayers, <a>displayT</a> for <a>Doc</a> values
--   and <a>displayIO</a> for file based output.</li>
--   <li>There is a <a>Pretty</a> class.</li>
--   <li>The implementation uses optimised representations and strictness
--   annotations.</li>
--   </ul>
--   
--   Ways that this library differs from <i>wl-pprint</i> (apart from using
--   <a>Doc</a> rather than <a>String</a>):
--   
--   <ul>
--   <li>Smarter treatment of <a>empty</a> sub-documents (partially copied
--   over from the <i>pretty</i> library).</li>
--   </ul>
module Text.PrettyPrint.Leijen.Text

-- | The abstract data type <tt>Doc</tt> represents pretty documents.
--   
--   <tt>Doc</tt> is an instance of the <a>Show</a> class. <tt>(show
--   doc)</tt> pretty prints document <tt>doc</tt> with a page width of 100
--   characters and a ribbon width of 40 characters.
--   
--   <pre>
--   show (text "hello" &lt;$&gt; text "world")
--   </pre>
--   
--   Which would return the string "hello\nworld", i.e.
--   
--   <pre>
--   hello
--   world
--   
--   </pre>
data Doc

-- | The empty document is, indeed, empty. Although <tt>empty</tt> has no
--   content, it does have a 'height' of 1 and behaves exactly like
--   <tt>(text "")</tt> (and is therefore not a unit of
--   <tt>&lt;$&gt;</tt>).
empty :: Doc

-- | Determine if the document is empty or not.
isEmpty :: Doc -> Bool

-- | The document <tt>(char c)</tt> contains the literal character
--   <tt>c</tt>. The character shouldn't be a newline (<tt>'\n'</tt>), the
--   function <a>line</a> should be used for line breaks.
char :: Char -> Doc

-- | The document <tt>(text s)</tt> contains the literal string <tt>s</tt>.
--   The string shouldn't contain any newline (<tt>'\n'</tt>) characters.
--   If the string contains newline characters, the function <a>string</a>
--   should be used.
text :: Text -> Doc
textStrict :: Text -> Doc

-- | The document <tt>(x <a>beside</a> y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt>. It is an associative operation having
--   <a>empty</a> as a left and right unit. (infixr 6)
--   
--   It is equivalent to <a>&lt;&gt;</a>.
beside :: Doc -> Doc -> Doc
infixr 6 `beside`

-- | The document <tt>(nest i x)</tt> renders document <tt>x</tt> with the
--   current indentation level increased by <tt>i</tt> (See also
--   <a>hang</a>, <a>align</a> and <a>indent</a>).
--   
--   <pre>
--   nest 2 (text "hello" &lt;$&gt; text "world") &lt;$&gt; text "!"
--   </pre>
--   
--   outputs as:
--   
--   <pre>
--   hello
--     world
--   !
--   
--   </pre>
nest :: Int -> Doc -> Doc

-- | The <tt>line</tt> document advances to the next line and indents to
--   the current nesting level. Document <tt>line</tt> behaves like
--   <tt>(text " ")</tt> if the line break is undone by <a>group</a> or if
--   rendered with <a>renderOneLine</a>.
line :: Doc

-- | The <tt>linebreak</tt> document advances to the next line and indents
--   to the current nesting level. Document <tt>linebreak</tt> behaves like
--   <a>empty</a> if the line break is undone by <a>group</a>.
linebreak :: Doc

-- | The <tt>group</tt> combinator is used to specify alternative layouts.
--   The document <tt>(group x)</tt> undoes all line breaks in document
--   <tt>x</tt>. The resulting line is added to the current line if that
--   fits the page. Otherwise, the document <tt>x</tt> is rendered without
--   any changes.
group :: Doc -> Doc

-- | The document <tt>softline</tt> behaves like <a>space</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softline = group line
--   </pre>
softline :: Doc

-- | The document <tt>softbreak</tt> behaves like <a>empty</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softbreak = group linebreak
--   </pre>
softbreak :: Doc

-- | The document <tt>spacebreak</tt> behaves like <a>space</a> when
--   rendered normally but like <a>empty</a> when using
--   <a>renderCompact</a> or <a>renderOneLine</a>.
spacebreak :: Doc

-- | The document <tt>(align x)</tt> renders document <tt>x</tt> with the
--   nesting level set to the current column. It is used for example to
--   implement <a>hang</a>.
--   
--   As an example, we will put a document right above another one,
--   regardless of the current nesting level:
--   
--   <pre>
--   x $$ y = align (x &lt;$&gt; y)
--   </pre>
--   
--   <pre>
--   test = text "hi" &lt;+&gt; (text "nice" $$ text "world")
--   </pre>
--   
--   which will be laid out as:
--   
--   <pre>
--   hi nice
--      world
--   
--   </pre>
align :: Doc -> Doc

-- | The hang combinator implements hanging indentation. The document
--   <tt>(hang i x)</tt> renders document <tt>x</tt> with a nesting level
--   set to the current column plus <tt>i</tt>. The following example uses
--   hanging indentation for some text:
--   
--   <pre>
--   test = hang 4 (fillSep (map text
--           (words "the hang combinator indents these words !")))
--   </pre>
--   
--   Which lays out on a page with a width of 20 characters as:
--   
--   <pre>
--   the hang combinator
--       indents these
--       words !
--   
--   </pre>
--   
--   The <tt>hang</tt> combinator is implemented as:
--   
--   <pre>
--   hang i x = align (nest i x)
--   </pre>
hang :: Int -> Doc -> Doc

-- | The document <tt>(indent i x)</tt> indents document <tt>x</tt> with
--   <tt>i</tt> spaces.
--   
--   <pre>
--   test = indent 4 (fillSep (map text
--           (words "the indent combinator indents these words !")))
--   </pre>
--   
--   Which lays out with a page width of 20 as:
--   
--   <pre>
--   the indent
--   combinator
--   indents these
--   words !
--   
--   </pre>
indent :: Int -> Doc -> Doc

-- | The document <tt>(encloseSep l r sep xs)</tt> concatenates the
--   documents <tt>xs</tt> separated by <tt>sep</tt> and encloses the
--   resulting document by <tt>l</tt> and <tt>r</tt>. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All separators are put in front of the elements.
--   For example, the combinator <a>list</a> can be defined with
--   <tt>encloseSep</tt>:
--   
--   <pre>
--   list xs = encloseSep lbracket rbracket comma xs
--   test = text "list" &lt;+&gt; (list (map int [10,200,3000]))
--   </pre>
--   
--   Which is laid out with a page width of 20 as:
--   
--   <pre>
--   list [10,200,3000]
--   
--   </pre>
--   
--   But when the page width is 15, it is laid out as:
--   
--   <pre>
--   list [10
--        ,200
--        ,3000]
--   
--   </pre>
encloseSep :: Doc -> Doc -> Doc -> [Doc] -> Doc

-- | The document <tt>(list xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in square brackets. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
list :: [Doc] -> Doc

-- | The document <tt>(tupled xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in parenthesis. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
tupled :: [Doc] -> Doc

-- | The document <tt>(semiBraces xs)</tt> separates the documents
--   <tt>xs</tt> with semi colons and encloses them in braces. The
--   documents are rendered horizontally if that fits the page. Otherwise
--   they are aligned vertically. All semi colons are put in front of the
--   elements.
semiBraces :: [Doc] -> Doc

-- | The document <tt>(x &lt;+&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>space</a> in between. (infixr 6)
(<+>) :: Doc -> Doc -> Doc
infixr 6 <+>

-- | The document <tt>(x &lt;++&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <a>spacebreak</a> in between. (infixr
--   6)
(<++>) :: Doc -> Doc -> Doc
infixr 6 <++>

-- | The document <tt>(x &lt;$&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>line</a> in between. (infixr 5)
(<$>) :: Doc -> Doc -> Doc
infixr 5 <$>

-- | The document <tt>(x &lt;/&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>softline</a> in between. This effectively
--   puts <tt>x</tt> and <tt>y</tt> either next to each other (with a
--   <tt>space</tt> in between) or underneath each other. (infixr 5)
(</>) :: Doc -> Doc -> Doc
infixr 5 </>

-- | The document <tt>(x &lt;$$&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <a>linebreak</a> in between. (infixr
--   5)
(<$$>) :: Doc -> Doc -> Doc
infixr 5 <$$>

-- | The document <tt>(x &lt;//&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <a>softbreak</a> in between. This
--   effectively puts <tt>x</tt> and <tt>y</tt> either right next to each
--   other or underneath each other. (infixr 5)
(<//>) :: Doc -> Doc -> Doc
infixr 5 <//>

-- | The document <tt>(hsep xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt>.
hsep :: [Doc] -> Doc

-- | The document <tt>(vsep xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>(&lt;$&gt;)</tt>. If a <a>group</a> undoes the
--   line breaks inserted by <tt>vsep</tt>, all documents are separated
--   with a space.
--   
--   <pre>
--   someText = map text (words ("text to lay out"))
--   
--   test = text "some" &lt;+&gt; vsep someText
--   </pre>
--   
--   This is laid out as:
--   
--   <pre>
--   some text
--   to
--   lay
--   out
--   
--   </pre>
--   
--   The <a>align</a> combinator can be used to align the documents under
--   their first element
--   
--   <pre>
--   test = text "some" &lt;+&gt; align (vsep someText)
--   </pre>
--   
--   Which is printed as:
--   
--   <pre>
--   some text
--        to
--        lay
--        out
--   
--   </pre>
vsep :: [Doc] -> Doc

-- | The document <tt>(fillSep xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt> as long as its fits the page,
--   then inserts a <tt>line</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillSep xs = foldr (&lt;/&gt;) empty xs
--   </pre>
fillSep :: [Doc] -> Doc

-- | The document <tt>(sep xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;+&gt;)</tt>, if it fits the page, or
--   vertically with <tt>(&lt;$&gt;)</tt>.
--   
--   <pre>
--   sep xs = group (vsep xs)
--   </pre>
sep :: [Doc] -> Doc

-- | The document <tt>(hcat xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt>.
hcat :: [Doc] -> Doc

-- | The document <tt>(vcat xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>(&lt;$$&gt;)</tt>. If a <a>group</a> undoes the
--   line breaks inserted by <tt>vcat</tt>, all documents are directly
--   concatenated.
vcat :: [Doc] -> Doc

-- | The document <tt>(fillCat xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt> as long as its fits the page,
--   then inserts a <tt>linebreak</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillCat xs = foldr (&lt;//&gt;) empty xs
--   </pre>
fillCat :: [Doc] -> Doc

-- | The document <tt>(cat xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;&gt;)</tt>, if it fits the page, or
--   vertically with <tt>(&lt;$$&gt;)</tt>.
--   
--   <pre>
--   cat xs = group (vcat xs)
--   </pre>
cat :: [Doc] -> Doc

-- | <tt>(punctuate p xs)</tt> concatenates all documents in <tt>xs</tt>
--   with document <tt>p</tt> except for the last document.
--   
--   <pre>
--   someText = map text ["words","in","a","tuple"]
--   test = parens (align (cat (punctuate comma someText)))
--   </pre>
--   
--   This is laid out on a page width of 20 as:
--   
--   <pre>
--   (words,in,a,tuple)
--   
--   </pre>
--   
--   But when the page width is 15, it is laid out as:
--   
--   <pre>
--   (words,
--    in,
--    a,
--    tuple)
--   
--   </pre>
--   
--   (If you want put the commas in front of their elements instead of at
--   the end, you should use <a>tupled</a> or, in general,
--   <a>encloseSep</a>.)
punctuate :: Doc -> [Doc] -> [Doc]

-- | The document <tt>(fill i x)</tt> renders document <tt>x</tt>. It then
--   appends <tt>space</tt>s until the width is equal to <tt>i</tt>. If the
--   width of <tt>x</tt> is already larger, nothing is appended. This
--   combinator is quite useful in practice to output a list of bindings.
--   The following example demonstrates this.
--   
--   <pre>
--   types = [("empty","Doc")
--            ,("nest","Int -&gt; Doc -&gt; Doc")
--            ,("linebreak","Doc")]
--   
--   ptype (name,tp)
--   = fill 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   
--   test = text "let" &lt;+&gt; align (vcat (map ptype types))
--   </pre>
--   
--   Which is laid out as:
--   
--   <pre>
--   let empty  :: Doc
--       nest   :: Int -&gt; Doc -&gt; Doc
--       linebreak :: Doc
--   
--   </pre>
fill :: Int -> Doc -> Doc

-- | The document <tt>(fillBreak i x)</tt> first renders document
--   <tt>x</tt>. It then appends <tt>space</tt>s until the width is equal
--   to <tt>i</tt>. If the width of <tt>x</tt> is already larger than
--   <tt>i</tt>, the nesting level is increased by <tt>i</tt> and a
--   <tt>line</tt> is appended. When we redefine <tt>ptype</tt> in the
--   previous example to use <tt>fillBreak</tt>, we get a useful variation
--   of the previous output:
--   
--   <pre>
--   ptype (name,tp)
--   = fillBreak 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   </pre>
--   
--   The output will now be:
--   
--   <pre>
--   let empty  :: Doc
--       nest   :: Int -&gt; Doc -&gt; Doc
--       linebreak
--              :: Doc
--   
--   </pre>
fillBreak :: Int -> Doc -> Doc

-- | The document <tt>(enclose l r x)</tt> encloses document <tt>x</tt>
--   between documents <tt>l</tt> and <tt>r</tt> using <tt>(&lt;&gt;)</tt>.
--   
--   <pre>
--   enclose l r x = l &lt;&gt; x &lt;&gt; r
--   </pre>
enclose :: Doc -> Doc -> Doc -> Doc

-- | Document <tt>(squotes x)</tt> encloses document <tt>x</tt> with single
--   quotes "'".
squotes :: Doc -> Doc

-- | Document <tt>(dquotes x)</tt> encloses document <tt>x</tt> with double
--   quotes '"'.
dquotes :: Doc -> Doc

-- | Document <tt>(parens x)</tt> encloses document <tt>x</tt> in
--   parenthesis, "(" and ")".
parens :: Doc -> Doc

-- | Document <tt>(angles x)</tt> encloses document <tt>x</tt> in angles,
--   "&lt;" and "&gt;".
angles :: Doc -> Doc

-- | Document <tt>(braces x)</tt> encloses document <tt>x</tt> in braces,
--   "{" and "}".
braces :: Doc -> Doc

-- | Document <tt>(brackets x)</tt> encloses document <tt>x</tt> in square
--   brackets, "[" and "]".
brackets :: Doc -> Doc

-- | The document <tt>lparen</tt> contains a left parenthesis, "(".
lparen :: Doc

-- | The document <tt>rparen</tt> contains a right parenthesis, ")".
rparen :: Doc

-- | The document <tt>langle</tt> contains a left angle, "&lt;".
langle :: Doc

-- | The document <tt>rangle</tt> contains a right angle, "&gt;".
rangle :: Doc

-- | The document <tt>lbrace</tt> contains a left brace, "{".
lbrace :: Doc

-- | The document <tt>rbrace</tt> contains a right brace, "}".
rbrace :: Doc

-- | The document <tt>lbracket</tt> contains a left square bracket, "[".
lbracket :: Doc

-- | The document <tt>rbracket</tt> contains a right square bracket, "]".
rbracket :: Doc

-- | The document <tt>squote</tt> contains a single quote, "'".
squote :: Doc

-- | The document <tt>dquote</tt> contains a double quote, '"'.
dquote :: Doc

-- | The document <tt>semi</tt> contains a semi colon, ";".
semi :: Doc

-- | The document <tt>colon</tt> contains a colon, ":".
colon :: Doc

-- | The document <tt>comma</tt> contains a comma, ",".
comma :: Doc

-- | The document <tt>space</tt> contains a single space, " ".
--   
--   <pre>
--   x &lt;+&gt; y = x &lt;&gt; space &lt;&gt; y
--   </pre>
space :: Doc

-- | The document <tt>dot</tt> contains a single dot, ".".
dot :: Doc

-- | The document <tt>backslash</tt> contains a back slash, "\".
backslash :: Doc

-- | The document <tt>equals</tt> contains an equal sign, "=".
equals :: Doc

-- | The document <tt>(string s)</tt> concatenates all characters in
--   <tt>s</tt> using <tt>line</tt> for newline characters and
--   <tt>char</tt> for all other characters. It is used instead of
--   <a>text</a> whenever the text contains newline characters.
string :: Text -> Doc
stringStrict :: Text -> Doc

-- | The document <tt>(int i)</tt> shows the literal integer <tt>i</tt>
--   using <a>text</a>.
int :: Int -> Doc

-- | The document <tt>(integer i)</tt> shows the literal integer <tt>i</tt>
--   using <a>text</a>.
integer :: Integer -> Doc

-- | The document <tt>(float f)</tt> shows the literal float <tt>f</tt>
--   using <a>text</a>.
float :: Float -> Doc

-- | The document <tt>(double d)</tt> shows the literal double <tt>d</tt>
--   using <a>text</a>.
double :: Double -> Doc

-- | The document <tt>(rational r)</tt> shows the literal rational
--   <tt>r</tt> using <a>text</a>.
rational :: Rational -> Doc

-- | The document <tt>(bool b)</tt> shows the literal boolean <tt>b</tt>
--   using <a>text</a>.
bool :: Bool -> Doc

-- | Specifies how to create the document based upon which column it is in.
column :: (Int -> Doc) -> Doc

-- | Specifies how to nest the document based upon which column it is being
--   nested in.
nesting :: (Int -> Doc) -> Doc
width :: Doc -> (Int -> Doc) -> Doc

-- | The member <tt>prettyList</tt> is only used to define the <tt>instance
--   Pretty a =&gt; Pretty [a]</tt>. In normal circumstances only the
--   <tt>pretty</tt> function is used.
class Pretty a
pretty :: Pretty a => a -> Doc
prettyList :: Pretty a => [a] -> Doc

-- | The data type <tt>SimpleDoc</tt> represents rendered documents and is
--   used by the display functions.
--   
--   The <tt>Int</tt> in <tt>SText</tt> contains the length of the string.
--   The <tt>Int</tt> in <tt>SLine</tt> contains the indentation for that
--   line. The library provides two default display functions
--   <tt>displayS</tt> and <a>displayIO</a>. You can provide your own
--   display function by writing a function from a <tt>SimpleDoc</tt> to
--   your own output format.
data SimpleDoc
SEmpty :: SimpleDoc
SChar :: Char -> SimpleDoc -> SimpleDoc
SText :: !Int64 -> Builder -> SimpleDoc -> SimpleDoc
SLine :: !Int64 -> SimpleDoc -> SimpleDoc

-- | This is the default pretty printer which is used by <a>show</a>,
--   <a>putDoc</a> and <a>hPutDoc</a>. <tt>(renderPretty ribbonfrac width
--   x)</tt> renders document <tt>x</tt> with a page width of
--   <tt>width</tt> and a ribbon width of <tt>(ribbonfrac * width)</tt>
--   characters. The ribbon width is the maximal amount of non-indentation
--   characters on a line. The parameter <tt>ribbonfrac</tt> should be
--   between <tt>0.0</tt> and <tt>1.0</tt>. If it is lower or higher, the
--   ribbon width will be 0 or <tt>width</tt> respectively.
renderPretty :: Float -> Int -> Doc -> SimpleDoc

-- | <tt>(renderCompact x)</tt> renders document <tt>x</tt> without adding
--   any indentation. Since no 'pretty' printing is involved, this renderer
--   is very fast. The resulting output contains fewer characters than a
--   pretty printed version and can be used for output that is read by
--   other programs.
renderCompact :: Doc -> SimpleDoc

-- | <tt>(renderOneLine x)</tt> renders document <tt>x</tt> without adding
--   any indentation or newlines.
renderOneLine :: Doc -> SimpleDoc

-- | <tt>(displayB simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a <a>Builder</a> type (for
--   further manipulation before converting to a lazy <a>Doc</a>).
displayB :: SimpleDoc -> Builder

-- | <tt>(displayT simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a lazy <a>Doc</a> value.
--   
--   <pre>
--   showWidth :: Int -&gt; Doc -&gt; Text
--   showWidth w x = displayT (renderPretty 0.4 w x)
--   </pre>
displayT :: SimpleDoc -> Text
displayTStrict :: SimpleDoc -> Text

-- | <tt>(displayIO handle simpleDoc)</tt> writes <tt>simpleDoc</tt> to the
--   file handle <tt>handle</tt>. This function is used for example by
--   <a>hPutDoc</a>:
--   
--   <pre>
--   hPutDoc handle doc = displayIO handle (renderPretty 0.4 100 doc)
--   </pre>
displayIO :: Handle -> SimpleDoc -> IO ()

-- | The action <tt>(putDoc doc)</tt> pretty prints document <tt>doc</tt>
--   to the standard output, with a page width of 100 characters and a
--   ribbon width of 40 characters.
--   
--   <pre>
--   main :: IO ()
--   main = do{ putDoc (text "hello" &lt;+&gt; text "world") }
--   </pre>
--   
--   Which would output
--   
--   <pre>
--   hello world
--   </pre>
putDoc :: Doc -> IO ()

-- | <tt>(hPutDoc handle doc)</tt> pretty prints document <tt>doc</tt> to
--   the file handle <tt>handle</tt> with a page width of 100 characters
--   and a ribbon width of 40 characters.
--   
--   <pre>
--   main = do handle &lt;- 'openFile' "MyFile" 'WriteMode'
--             'hPutDoc' handle ('vcat' ('map' 'text'
--                             ['T.pack' "vertical", 'T.pack' "text"]))
--             'hClose' handle
--   </pre>
hPutDoc :: Handle -> Doc -> IO ()
instance GHC.Show.Show Text.PrettyPrint.Leijen.Text.SimpleDoc
instance Text.PrettyPrint.Leijen.Text.Pretty a => Text.PrettyPrint.Leijen.Text.Pretty [a]
instance Text.PrettyPrint.Leijen.Text.Pretty Text.PrettyPrint.Leijen.Text.Doc
instance Text.PrettyPrint.Leijen.Text.Pretty Data.Text.Internal.Lazy.Text
instance Text.PrettyPrint.Leijen.Text.Pretty Data.Text.Internal.Text
instance Text.PrettyPrint.Leijen.Text.Pretty ()
instance Text.PrettyPrint.Leijen.Text.Pretty GHC.Types.Bool
instance Text.PrettyPrint.Leijen.Text.Pretty GHC.Types.Char
instance Text.PrettyPrint.Leijen.Text.Pretty GHC.Types.Int
instance Text.PrettyPrint.Leijen.Text.Pretty GHC.Integer.Type.Integer
instance Text.PrettyPrint.Leijen.Text.Pretty GHC.Types.Float
instance Text.PrettyPrint.Leijen.Text.Pretty GHC.Types.Double
instance (Text.PrettyPrint.Leijen.Text.Pretty a, Text.PrettyPrint.Leijen.Text.Pretty b) => Text.PrettyPrint.Leijen.Text.Pretty (a, b)
instance (Text.PrettyPrint.Leijen.Text.Pretty a, Text.PrettyPrint.Leijen.Text.Pretty b, Text.PrettyPrint.Leijen.Text.Pretty c) => Text.PrettyPrint.Leijen.Text.Pretty (a, b, c)
instance Text.PrettyPrint.Leijen.Text.Pretty a => Text.PrettyPrint.Leijen.Text.Pretty (GHC.Maybe.Maybe a)
instance Data.String.IsString Text.PrettyPrint.Leijen.Text.Doc
instance GHC.Base.Semigroup Text.PrettyPrint.Leijen.Text.Doc
instance GHC.Base.Monoid Text.PrettyPrint.Leijen.Text.Doc
instance GHC.Show.Show Text.PrettyPrint.Leijen.Text.Doc


-- | This module provides a version of <a>Text.PrettyPrint.Leijen.Text</a>
--   where the combinators have been lifted into a <a>Monad</a>. The main
--   usage for this is for state-based pretty-printing.
module Text.PrettyPrint.Leijen.Text.Monadic

-- | The abstract data type <tt>Doc</tt> represents pretty documents.
--   
--   <tt>Doc</tt> is an instance of the <a>Show</a> class. <tt>(show
--   doc)</tt> pretty prints document <tt>doc</tt> with a page width of 100
--   characters and a ribbon width of 40 characters.
--   
--   <pre>
--   show (text "hello" &lt;$&gt; text "world")
--   </pre>
--   
--   Which would return the string "hello\nworld", i.e.
--   
--   <pre>
--   hello
--   world
--   
--   </pre>
data Doc

-- | The empty document is, indeed, empty. Although <tt>empty</tt> has no
--   content, it does have a 'height' of 1 and behaves exactly like
--   <tt>(text "")</tt> (and is therefore not a unit of
--   <tt>&lt;$&gt;</tt>).
empty :: Applicative m => m Doc

-- | The document <tt>(char c)</tt> contains the literal character
--   <tt>c</tt>. The character shouldn't be a newline (<tt>'\n'</tt>), the
--   function <a>line</a> should be used for line breaks.
char :: Applicative m => Char -> m Doc

-- | The document <tt>(text s)</tt> contains the literal string <tt>s</tt>.
--   The string shouldn't contain any newline (<tt>'\n'</tt>) characters.
--   If the string contains newline characters, the function <a>string</a>
--   should be used.
text :: Applicative m => Text -> m Doc
textStrict :: Monad m => Text -> m Doc

-- | The document <tt>(x <a>beside</a> y)</tt> concatenates document
--   <tt>x</tt> and document <tt>y</tt>. It is an associative operation
--   having <a>empty</a> as a left and right unit. (infixr 6)
beside :: Applicative m => m Doc -> m Doc -> m Doc
infixr 6 `beside`

-- | The document <tt>(nest i x)</tt> renders document <tt>x</tt> with the
--   current indentation level increased by <tt>i</tt> (See also
--   <a>hang</a>, <a>align</a> and <a>indent</a>).
--   
--   <pre>
--   nest 2 (text "hello" &lt;$&gt; text "world") &lt;$&gt; text "!"
--   </pre>
--   
--   outputs as:
--   
--   <pre>
--   hello
--     world
--   !
--   
--   </pre>
nest :: Functor m => Int -> m Doc -> m Doc

-- | The <tt>line</tt> document advances to the next line and indents to
--   the current nesting level. Document <tt>line</tt> behaves like
--   <tt>(text " ")</tt> if the line break is undone by <a>group</a> or if
--   rendered with <a>renderOneLine</a>.
line :: Applicative m => m Doc

-- | The <tt>linebreak</tt> document advances to the next line and indents
--   to the current nesting level. Document <tt>linebreak</tt> behaves like
--   <a>empty</a> if the line break is undone by <a>group</a>.
linebreak :: Applicative m => m Doc

-- | The <tt>group</tt> combinator is used to specify alternative layouts.
--   The document <tt>(group x)</tt> undoes all line breaks in document
--   <tt>x</tt>. The resulting line is added to the current line if that
--   fits the page. Otherwise, the document <tt>x</tt> is rendered without
--   any changes.
group :: Functor m => m Doc -> m Doc

-- | The document <tt>softline</tt> behaves like <a>space</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
softline :: Applicative m => m Doc

-- | The document <tt>softbreak</tt> behaves like <a>empty</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
softbreak :: Applicative m => m Doc

-- | The document <tt>spacebreak</tt> behaves like <a>space</a> when
--   rendered normally but like <a>empty</a> when using
--   <a>renderCompact</a> or <a>renderOneLine</a>.
spacebreak :: Applicative m => m Doc

-- | The document <tt>(align x)</tt> renders document <tt>x</tt> with the
--   nesting level set to the current column. It is used for example to
--   implement <a>hang</a>.
--   
--   As an example, we will put a document right above another one,
--   regardless of the current nesting level:
--   
--   <pre>
--   x $$ y = align (x &lt;$&gt; y)
--   </pre>
--   
--   <pre>
--   test = text "hi" &lt;+&gt; (text "nice" $$ text "world")
--   </pre>
--   
--   which will be laid out as:
--   
--   <pre>
--   hi nice
--      world
--   
--   </pre>
align :: Functor m => m Doc -> m Doc

-- | The hang combinator implements hanging indentation. The document
--   <tt>(hang i x)</tt> renders document <tt>x</tt> with a nesting level
--   set to the current column plus <tt>i</tt>. The following example uses
--   hanging indentation for some text:
--   
--   <pre>
--   test = hang 4 (fillSep (map text
--           (words "the hang combinator indents these words !")))
--   </pre>
--   
--   Which lays out on a page with a width of 20 characters as:
--   
--   <pre>
--   the hang combinator
--       indents these
--       words !
--   
--   </pre>
--   
--   The <tt>hang</tt> combinator is implemented as:
--   
--   <pre>
--   hang i x = align (nest i x)
--   </pre>
hang :: Functor m => Int -> m Doc -> m Doc

-- | The document <tt>(indent i x)</tt> indents document <tt>x</tt> with
--   <tt>i</tt> spaces.
--   
--   <pre>
--   test = indent 4 (fillSep (map text
--           (words "the indent combinator indents these words !")))
--   </pre>
--   
--   Which lays out with a page width of 20 as:
--   
--   <pre>
--   the indent
--   combinator
--   indents these
--   words !
--   
--   </pre>
indent :: Functor m => Int -> m Doc -> m Doc

-- | The document <tt>(encloseSep l r sep xs)</tt> concatenates the
--   documents <tt>xs</tt> separated by <tt>sep</tt> and encloses the
--   resulting document by <tt>l</tt> and <tt>r</tt>. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All separators are put in front of the elements.
--   For example, the combinator <a>list</a> can be defined with
--   <tt>encloseSep</tt>:
--   
--   <pre>
--   list xs = encloseSep lbracket rbracket comma xs
--   test = text "list" &lt;+&gt; (list (map int [10,200,3000]))
--   </pre>
--   
--   Which is laid out with a page width of 20 as:
--   
--   <pre>
--   list [10,200,3000]
--   
--   </pre>
--   
--   But when the page width is 15, it is laid out as:
--   
--   <pre>
--   list [10
--        ,200
--        ,3000]
--   
--   </pre>
encloseSep :: Applicative m => m Doc -> m Doc -> m Doc -> m [Doc] -> m Doc

-- | The document <tt>(list xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in square brackets. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
list :: Functor m => m [Doc] -> m Doc

-- | The document <tt>(tupled xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in parenthesis. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
tupled :: Functor m => m [Doc] -> m Doc

-- | The document <tt>(semiBraces xs)</tt> separates the documents
--   <tt>xs</tt> with semi colons and encloses them in braces. The
--   documents are rendered horizontally if that fits the page. Otherwise
--   they are aligned vertically. All semi colons are put in front of the
--   elements.
semiBraces :: Functor m => m [Doc] -> m Doc

-- | The document <tt>(x &lt;+&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>space</a> in between. (infixr 6)
(<+>) :: Applicative m => m Doc -> m Doc -> m Doc
infixr 6 <+>

-- | The document <tt>(x &lt;++&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <a>spacebreak</a> in between. (infixr
--   6)
(<++>) :: Applicative m => m Doc -> m Doc -> m Doc
infixr 6 <++>

-- | The document <tt>(x &lt;$&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>line</a> in between. (infixr 5)
(<$>) :: Applicative m => m Doc -> m Doc -> m Doc
infixr 5 <$>

-- | The document <tt>(x &lt;/&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>softline</a> in between. This effectively
--   puts <tt>x</tt> and <tt>y</tt> either next to each other (with a
--   <tt>space</tt> in between) or underneath each other. (infixr 5)
(</>) :: Applicative m => m Doc -> m Doc -> m Doc
infixr 5 </>

-- | The document <tt>(x &lt;$$&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <a>linebreak</a> in between. (infixr
--   5)
(<$$>) :: Applicative m => m Doc -> m Doc -> m Doc
infixr 5 <$$>

-- | The document <tt>(x &lt;//&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <a>softbreak</a> in between. This
--   effectively puts <tt>x</tt> and <tt>y</tt> either right next to each
--   other or underneath each other. (infixr 5)
(<//>) :: Applicative m => m Doc -> m Doc -> m Doc
infixr 5 <//>

-- | The document <tt>(hsep xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt>.
hsep :: Functor m => m [Doc] -> m Doc

-- | The document <tt>(vsep xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>(&lt;$&gt;)</tt>. If a <a>group</a> undoes the
--   line breaks inserted by <tt>vsep</tt>, all documents are separated
--   with a space.
--   
--   <pre>
--   someText = map text (words ("text to lay out"))
--   
--   test = text "some" &lt;+&gt; vsep someText
--   </pre>
--   
--   This is laid out as:
--   
--   <pre>
--   some text
--   to
--   lay
--   out
--   
--   </pre>
--   
--   The <a>align</a> combinator can be used to align the documents under
--   their first element
--   
--   <pre>
--   test = text "some" &lt;+&gt; align (vsep someText)
--   </pre>
--   
--   Which is printed as:
--   
--   <pre>
--   some text
--        to
--        lay
--        out
--   
--   </pre>
vsep :: Functor m => m [Doc] -> m Doc

-- | The document <tt>(fillSep xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt> as long as its fits the page,
--   then inserts a <tt>line</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillSep xs = foldr (&lt;/&gt;) empty xs
--   </pre>
fillSep :: Functor m => m [Doc] -> m Doc

-- | The document <tt>(sep xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;+&gt;)</tt>, if it fits the page, or
--   vertically with <tt>(&lt;$&gt;)</tt>.
--   
--   <pre>
--   sep xs = group (vsep xs)
--   </pre>
sep :: Functor m => m [Doc] -> m Doc

-- | The document <tt>(hcat xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt>.
hcat :: Functor m => m [Doc] -> m Doc

-- | The document <tt>(vcat xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>(&lt;$$&gt;)</tt>. If a <a>group</a> undoes the
--   line breaks inserted by <tt>vcat</tt>, all documents are directly
--   concatenated.
vcat :: Functor m => m [Doc] -> m Doc

-- | The document <tt>(fillCat xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt> as long as its fits the page,
--   then inserts a <tt>linebreak</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillCat xs = foldr (&lt;//&gt;) empty xs
--   </pre>
fillCat :: Functor m => m [Doc] -> m Doc

-- | The document <tt>(cat xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;&gt;)</tt>, if it fits the page, or
--   vertically with <tt>(&lt;$$&gt;)</tt>.
--   
--   <pre>
--   cat xs = group (vcat xs)
--   </pre>
cat :: Functor m => m [Doc] -> m Doc

-- | <tt>(punctuate p xs)</tt> concatenates all documents in <tt>xs</tt>
--   with document <tt>p</tt> except for the last document.
--   
--   <pre>
--   someText = map text ["words","in","a","tuple"]
--   test = parens (align (cat (punctuate comma someText)))
--   </pre>
--   
--   This is laid out on a page width of 20 as:
--   
--   <pre>
--   (words,in,a,tuple)
--   
--   </pre>
--   
--   But when the page width is 15, it is laid out as:
--   
--   <pre>
--   (words,
--    in,
--    a,
--    tuple)
--   
--   </pre>
--   
--   (If you want put the commas in front of their elements instead of at
--   the end, you should use <a>tupled</a> or, in general,
--   <a>encloseSep</a>.)
punctuate :: Applicative m => m Doc -> m [Doc] -> m [Doc]

-- | The document <tt>(fill i x)</tt> renders document <tt>x</tt>. It then
--   appends <tt>space</tt>s until the width is equal to <tt>i</tt>. If the
--   width of <tt>x</tt> is already larger, nothing is appended. This
--   combinator is quite useful in practice to output a list of bindings.
--   The following example demonstrates this.
--   
--   <pre>
--   types = [("empty","Doc")
--            ,("nest","Int -&gt; Doc -&gt; Doc")
--            ,("linebreak","Doc")]
--   
--   ptype (name,tp)
--   = fill 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   
--   test = text "let" &lt;+&gt; align (vcat (map ptype types))
--   </pre>
--   
--   Which is laid out as:
--   
--   <pre>
--   let empty  :: Doc
--       nest   :: Int -&gt; Doc -&gt; Doc
--       linebreak :: Doc
--   
--   </pre>
fill :: Functor m => Int -> m Doc -> m Doc

-- | The document <tt>(fillBreak i x)</tt> first renders document
--   <tt>x</tt>. It then appends <tt>space</tt>s until the width is equal
--   to <tt>i</tt>. If the width of <tt>x</tt> is already larger than
--   <tt>i</tt>, the nesting level is increased by <tt>i</tt> and a
--   <tt>line</tt> is appended. When we redefine <tt>ptype</tt> in the
--   previous example to use <tt>fillBreak</tt>, we get a useful variation
--   of the previous output:
--   
--   <pre>
--   ptype (name,tp)
--   = fillBreak 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   </pre>
--   
--   The output will now be:
--   
--   <pre>
--   let empty  :: Doc
--       nest   :: Int -&gt; Doc -&gt; Doc
--       linebreak
--              :: Doc
--   
--   </pre>
fillBreak :: Functor m => Int -> m Doc -> m Doc

-- | The document <tt>(enclose l r x)</tt> encloses document <tt>x</tt>
--   between documents <tt>l</tt> and <tt>r</tt> using
--   <tt><a>beside</a></tt>.
--   
--   <pre>
--   enclose l r x = l `beside` x `beside` r
--   </pre>
enclose :: Applicative m => m Doc -> m Doc -> m Doc -> m Doc

-- | Document <tt>(squotes x)</tt> encloses document <tt>x</tt> with single
--   quotes "'".
squotes :: Functor m => m Doc -> m Doc

-- | Document <tt>(dquotes x)</tt> encloses document <tt>x</tt> with double
--   quotes '"'.
dquotes :: Functor m => m Doc -> m Doc

-- | Document <tt>(parens x)</tt> encloses document <tt>x</tt> in
--   parenthesis, "(" and ")".
parens :: Functor m => m Doc -> m Doc

-- | Document <tt>(angles x)</tt> encloses document <tt>x</tt> in angles,
--   "&lt;" and "&gt;".
angles :: Functor m => m Doc -> m Doc

-- | Document <tt>(braces x)</tt> encloses document <tt>x</tt> in braces,
--   "{" and "}".
braces :: Functor m => m Doc -> m Doc

-- | Document <tt>(brackets x)</tt> encloses document <tt>x</tt> in square
--   brackets, "[" and "]".
brackets :: Functor m => m Doc -> m Doc

-- | The document <tt>lparen</tt> contains a left parenthesis, "(".
lparen :: Applicative m => m Doc

-- | The document <tt>rparen</tt> contains a right parenthesis, ")".
rparen :: Applicative m => m Doc

-- | The document <tt>langle</tt> contains a left angle, "&lt;".
langle :: Applicative m => m Doc

-- | The document <tt>rangle</tt> contains a right angle, "&gt;".
rangle :: Applicative m => m Doc

-- | The document <tt>lbrace</tt> contains a left brace, "{".
lbrace :: Applicative m => m Doc

-- | The document <tt>rbrace</tt> contains a right brace, "}".
rbrace :: Applicative m => m Doc

-- | The document <tt>lbracket</tt> contains a left square bracket, "[".
lbracket :: Applicative m => m Doc

-- | The document <tt>rbracket</tt> contains a right square bracket, "]".
rbracket :: Applicative m => m Doc

-- | The document <tt>squote</tt> contains a single quote, "'".
squote :: Applicative m => m Doc

-- | The document <tt>dquote</tt> contains a double quote, '"'.
dquote :: Applicative m => m Doc

-- | The document <tt>semi</tt> contains a semi colon, ";".
semi :: Applicative m => m Doc

-- | The document <tt>colon</tt> contains a colon, ":".
colon :: Applicative m => m Doc

-- | The document <tt>comma</tt> contains a comma, ",".
comma :: Applicative m => m Doc

-- | The document <tt>space</tt> contains a single space, " ".
--   
--   <pre>
--   x &lt;+&gt; y = x `beside` space `beside` y
--   </pre>
space :: Applicative m => m Doc

-- | The document <tt>dot</tt> contains a single dot, ".".
dot :: Applicative m => m Doc

-- | The document <tt>backslash</tt> contains a back slash, "\".
backslash :: Applicative m => m Doc

-- | The document <tt>equals</tt> contains an equal sign, "=".
equals :: Applicative m => m Doc

-- | The document <tt>(string s)</tt> concatenates all characters in
--   <tt>s</tt> using <tt>line</tt> for newline characters and
--   <tt>char</tt> for all other characters. It is used instead of
--   <a>text</a> whenever the text contains newline characters.
string :: Applicative m => Text -> m Doc
stringStrict :: Monad m => Text -> m Doc

-- | The document <tt>(int i)</tt> shows the literal integer <tt>i</tt>
--   using <a>text</a>.
int :: Applicative m => Int -> m Doc

-- | The document <tt>(integer i)</tt> shows the literal integer <tt>i</tt>
--   using <a>text</a>.
integer :: Applicative m => Integer -> m Doc

-- | The document <tt>(float f)</tt> shows the literal float <tt>f</tt>
--   using <a>text</a>.
float :: Applicative m => Float -> m Doc

-- | The document <tt>(double d)</tt> shows the literal double <tt>d</tt>
--   using <a>text</a>.
double :: Applicative m => Double -> m Doc

-- | The document <tt>(rational r)</tt> shows the literal rational
--   <tt>r</tt> using <a>text</a>.
rational :: Applicative m => Rational -> m Doc

-- | The document <tt>(bool b)</tt> shows the literal boolean <tt>b</tt>
--   using <a>text</a>.
bool :: Applicative m => Bool -> m Doc

-- | Specifies how to create the document based upon which column it is in.
column :: Functor m => m (Int -> Doc) -> m Doc

-- | Specifies how to nest the document based upon which column it is being
--   nested in.
nesting :: Functor m => m (Int -> Doc) -> m Doc
width :: Applicative m => m Doc -> m (Int -> Doc) -> m Doc

-- | The member <tt>prettyList</tt> is only used to define the <tt>instance
--   Pretty a =&gt; Pretty [a]</tt>. In normal circumstances only the
--   <tt>pretty</tt> function is used.
class Pretty a
pretty :: Pretty a => a -> Doc
prettyList :: Pretty a => [a] -> Doc

-- | A monadic version of <a>pretty</a>; this is to allow you to use the
--   <a>Pretty</a> class without having to create extra instances.
--   Alternatively, you may wish to make a variant of <a>Pretty</a> using
--   the actual <a>Monad</a> to be used.
prettyM :: (Pretty a, Applicative m) => a -> m Doc

-- | The data type <tt>SimpleDoc</tt> represents rendered documents and is
--   used by the display functions.
--   
--   The <tt>Int</tt> in <tt>SText</tt> contains the length of the string.
--   The <tt>Int</tt> in <tt>SLine</tt> contains the indentation for that
--   line. The library provides two default display functions
--   <tt>displayS</tt> and <a>displayIO</a>. You can provide your own
--   display function by writing a function from a <tt>SimpleDoc</tt> to
--   your own output format.
data SimpleDoc
SEmpty :: SimpleDoc
SChar :: Char -> SimpleDoc -> SimpleDoc
SText :: !Int64 -> Builder -> SimpleDoc -> SimpleDoc
SLine :: !Int64 -> SimpleDoc -> SimpleDoc

-- | This is the default pretty printer which is used by <a>show</a>,
--   <a>putDoc</a> and <a>hPutDoc</a>. <tt>(renderPretty ribbonfrac width
--   x)</tt> renders document <tt>x</tt> with a page width of
--   <tt>width</tt> and a ribbon width of <tt>(ribbonfrac * width)</tt>
--   characters. The ribbon width is the maximal amount of non-indentation
--   characters on a line. The parameter <tt>ribbonfrac</tt> should be
--   between <tt>0.0</tt> and <tt>1.0</tt>. If it is lower or higher, the
--   ribbon width will be 0 or <tt>width</tt> respectively.
renderPretty :: Float -> Int -> Doc -> SimpleDoc

-- | <tt>(renderCompact x)</tt> renders document <tt>x</tt> without adding
--   any indentation. Since no 'pretty' printing is involved, this renderer
--   is very fast. The resulting output contains fewer characters than a
--   pretty printed version and can be used for output that is read by
--   other programs.
renderCompact :: Doc -> SimpleDoc

-- | <tt>(renderOneLine x)</tt> renders document <tt>x</tt> without adding
--   any indentation or newlines.
renderOneLine :: Doc -> SimpleDoc

-- | <tt>(displayB simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a <a>Builder</a> type (for
--   further manipulation before converting to a lazy <a>Doc</a>).
displayB :: SimpleDoc -> Builder

-- | <tt>(displayT simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a lazy <a>Doc</a> value.
--   
--   <pre>
--   showWidth :: Int -&gt; Doc -&gt; Text
--   showWidth w x = displayT (renderPretty 0.4 w x)
--   </pre>
displayT :: SimpleDoc -> Text
displayTStrict :: SimpleDoc -> Text

-- | <tt>(displayIO handle simpleDoc)</tt> writes <tt>simpleDoc</tt> to the
--   file handle <tt>handle</tt>. This function is used for example by
--   <a>hPutDoc</a>:
--   
--   <pre>
--   hPutDoc handle doc = displayIO handle (renderPretty 0.4 100 doc)
--   </pre>
displayIO :: Handle -> SimpleDoc -> IO ()

-- | The action <tt>(putDoc doc)</tt> pretty prints document <tt>doc</tt>
--   to the standard output, with a page width of 100 characters and a
--   ribbon width of 40 characters.
--   
--   <pre>
--   main :: IO ()
--   main = do{ putDoc (text "hello" &lt;+&gt; text "world") }
--   </pre>
--   
--   Which would output
--   
--   <pre>
--   hello world
--   </pre>
putDoc :: Doc -> IO ()

-- | <tt>(hPutDoc handle doc)</tt> pretty prints document <tt>doc</tt> to
--   the file handle <tt>handle</tt> with a page width of 100 characters
--   and a ribbon width of 40 characters.
--   
--   <pre>
--   main = do handle &lt;- 'openFile' "MyFile" 'WriteMode'
--             'hPutDoc' handle ('vcat' ('map' 'text'
--                             ['T.pack' "vertical", 'T.pack' "text"]))
--             'hClose' handle
--   </pre>
hPutDoc :: Handle -> Doc -> IO ()
