-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | QuickCheck support for the Tasty test framework.
--   
--   QuickCheck support for the Tasty test framework.
@package tasty-quickcheck
@version 0.10.1


-- | This module allows to use QuickCheck properties in tasty.
module Test.Tasty.QuickCheck

-- | Create a <tt>Test</tt> for a QuickCheck <a>Testable</a> property
testProperty :: Testable a => TestName -> a -> TestTree

-- | Create a test from a list of QuickCheck properties. To be used with
--   <a>allProperties</a>. E.g.
--   
--   <pre>
--   tests :: TestTree
--   tests = testProperties "Foo" $allProperties
--   </pre>
testProperties :: TestName -> [(String, Property)] -> TestTree

-- | Number of test cases for QuickCheck to generate
newtype QuickCheckTests
QuickCheckTests :: Int -> QuickCheckTests
newtype QuickCheckReplay
QuickCheckReplay :: Maybe Int -> QuickCheckReplay

-- | If a test case fails unexpectedly, show the replay token
newtype QuickCheckShowReplay
QuickCheckShowReplay :: Bool -> QuickCheckShowReplay

-- | Size of the biggest test cases
newtype QuickCheckMaxSize
QuickCheckMaxSize :: Int -> QuickCheckMaxSize

-- | Maximum number of of discarded tests per successful test before giving
--   up.
newtype QuickCheckMaxRatio
QuickCheckMaxRatio :: Int -> QuickCheckMaxRatio

-- | Show the test cases that QuickCheck generates
newtype QuickCheckVerbose
QuickCheckVerbose :: Bool -> QuickCheckVerbose

-- | A variant of <a>labelledExamples</a> that takes test arguments and
--   returns a result.
labelledExamplesWithResult :: Testable prop => Args -> prop -> IO Result

-- | A variant of <a>labelledExamples</a> that returns a result.
labelledExamplesResult :: Testable prop => prop -> IO Result

-- | A variant of <a>labelledExamples</a> that takes test arguments.
labelledExamplesWith :: Testable prop => Args -> prop -> IO ()

-- | Given a property, which must use <a>label</a>, <a>collect</a>,
--   <a>classify</a> or <a>cover</a> to associate labels with test cases,
--   find an example test case for each possible label. The example test
--   cases are minimised using shrinking.
--   
--   For example, suppose we test <tt><a>delete</a> x xs</tt> and record
--   the number of times that <tt>x</tt> occurs in <tt>xs</tt>:
--   
--   <pre>
--   prop_delete :: Int -&gt; [Int] -&gt; Property
--   prop_delete x xs =
--     classify (count x xs == 0) "count x xs == 0" $
--     classify (count x xs == 1) "count x xs == 1" $
--     classify (count x xs &gt;= 2) "count x xs &gt;= 2" $
--     counterexample (show (delete x xs)) $
--     count x (delete x xs) == max 0 (count x xs-1)
--     where count x xs = length (filter (== x) xs)
--   </pre>
--   
--   <a>labelledExamples</a> generates three example test cases, one for
--   each label:
--   
--   <pre>
--   &gt;&gt;&gt; labelledExamples prop_delete
--   *** Found example of count x xs == 0
--   0
--   []
--   []
--   
--   *** Found example of count x xs == 1
--   0
--   [0]
--   []
--   
--   *** Found example of count x xs &gt;= 2
--   5
--   [5,5]
--   [5]
--   
--   +++ OK, passed 100 tests:
--   78% count x xs == 0
--   21% count x xs == 1
--    1% count x xs &gt;= 2
--   </pre>
labelledExamples :: Testable prop => prop -> IO ()

-- | Monomorphise an arbitrary property by defaulting all type variables to
--   <a>Integer</a>.
--   
--   For example, if <tt>f</tt> has type <tt><a>Ord</a> a =&gt; [a] -&gt;
--   [a]</tt> then <tt>$(<a>monomorphic</a> 'f)</tt> has type
--   <tt>[<a>Integer</a>] -&gt; [<a>Integer</a>]</tt>.
--   
--   If you want to use <a>monomorphic</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
monomorphic :: Name -> ExpQ

-- | Test a polymorphic property, defaulting all type variables to
--   <a>Integer</a>. This is just a convenience function that combines
--   <a>verboseCheck</a> and <a>monomorphic</a>.
--   
--   If you want to use <a>polyVerboseCheck</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
polyVerboseCheck :: Name -> ExpQ

-- | Test a polymorphic property, defaulting all type variables to
--   <a>Integer</a>.
--   
--   Invoke as <tt>$(<a>polyQuickCheck</a> 'prop)</tt>, where <tt>prop</tt>
--   is a property. Note that just evaluating <tt><a>quickCheck</a>
--   prop</tt> in GHCi will seem to work, but will silently default all
--   type variables to <tt>()</tt>!
--   
--   <tt>$(<a>polyQuickCheck</a> 'prop)</tt> means the same as
--   <tt><a>quickCheck</a> $(<a>monomorphic</a> 'prop)</tt>. If you want to
--   supply custom arguments to <a>polyQuickCheck</a>, you will have to
--   combine <a>quickCheckWith</a> and <a>monomorphic</a> yourself.
--   
--   If you want to use <a>polyQuickCheck</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
polyQuickCheck :: Name -> ExpQ

-- | Check if the test run result was a success
isSuccess :: Result -> Bool

-- | A successful test run
pattern Success :: () => () => Int -> Int -> !Map [String] Int -> !Map String Int -> !Map String (Map String Int) -> String -> Result

-- | Given up
pattern GaveUp :: () => () => Int -> Int -> !Map [String] Int -> !Map String Int -> !Map String (Map String Int) -> String -> Result

-- | A failed test run
pattern Failure :: () => () => Int -> Int -> Int -> Int -> Int -> QCGen -> Int -> String -> Maybe AnException -> String -> [String] -> [String] -> Set String -> Result

-- | A property that should have failed did not
pattern NoExpectedFailure :: () => () => Int -> Int -> !Map [String] Int -> !Map String Int -> !Map String (Map String Int) -> String -> Result

-- | Number of tests performed
numTests :: Result -> Int

-- | Number of tests skipped
numDiscarded :: Result -> Int

-- | The number of test cases having each combination of labels (see
--   <a>label</a>)
labels :: Result -> Map [String] Int

-- | The number of test cases having each class (see <a>classify</a>)
classes :: Result -> Map String Int

-- | Data collected by <a>tabulate</a>
tables :: Result -> Map String (Map String Int)

-- | Printed output
output :: Result -> String

-- | Number of successful shrinking steps performed
numShrinks :: Result -> Int

-- | Number of unsuccessful shrinking steps performed
numShrinkTries :: Result -> Int

-- | Number of unsuccessful shrinking steps performed since last successful
--   shrink
numShrinkFinal :: Result -> Int

-- | What seed was used
usedSeed :: Result -> QCGen

-- | What was the test size
usedSize :: Result -> Int

-- | Why did the property fail
reason :: Result -> String

-- | The exception the property threw, if any
theException :: Result -> Maybe AnException

-- | The test case which provoked the failure
failingTestCase :: Result -> [String]

-- | The test case's labels (see <a>label</a>)
failingLabels :: Result -> [String]

-- | The test case's classes (see <a>classify</a>)
failingClasses :: Result -> Set String

-- | Checks that a value is total, i.e., doesn't crash when evaluated.
total :: NFData a => a -> Property

-- | Like <a>/=</a>, but prints a counterexample when it fails.
(=/=) :: (Eq a, Show a) => a -> a -> Property
infix 4 =/=

-- | Like <a>==</a>, but prints a counterexample when it fails.
(===) :: (Eq a, Show a) => a -> a -> Property
infix 4 ===

-- | Take the disjunction of several properties.
disjoin :: Testable prop => [prop] -> Property

-- | Disjunction: <tt>p1</tt> <a>.||.</a> <tt>p2</tt> passes unless
--   <tt>p1</tt> and <tt>p2</tt> simultaneously fail.
(.||.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
infixr 1 .||.

-- | Take the conjunction of several properties.
conjoin :: Testable prop => [prop] -> Property

-- | Conjunction: <tt>p1</tt> <a>.&amp;&amp;.</a> <tt>p2</tt> passes if
--   both <tt>p1</tt> and <tt>p2</tt> pass.
(.&&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
infixr 1 .&&.

-- | Nondeterministic choice: <tt>p1</tt> <a>.&amp;.</a> <tt>p2</tt> picks
--   randomly one of <tt>p1</tt> and <tt>p2</tt> to test. If you test the
--   property 100 times it makes 100 random choices.
(.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
infixr 1 .&.

-- | Like <a>forAllShrink</a>, but without printing the generated value.
forAllShrinkBlind :: Testable prop => Gen a -> (a -> [a]) -> (a -> prop) -> Property

-- | Like <a>forAllShrink</a>, but with an explicitly given show function.
forAllShrinkShow :: Testable prop => Gen a -> (a -> [a]) -> (a -> String) -> (a -> prop) -> Property

-- | Like <a>forAll</a>, but tries to shrink the argument for failing test
--   cases.
forAllShrink :: (Show a, Testable prop) => Gen a -> (a -> [a]) -> (a -> prop) -> Property

-- | Like <a>forAll</a>, but without printing the generated value.
forAllBlind :: Testable prop => Gen a -> (a -> prop) -> Property

-- | Like <a>forAll</a>, but with an explicitly given show function.
forAllShow :: Testable prop => Gen a -> (a -> String) -> (a -> prop) -> Property

-- | Explicit universal quantification: uses an explicitly given test case
--   generator.
forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property

-- | Considers a property failed if it does not complete within the given
--   number of microseconds.
--   
--   Note: if the property times out, variables quantified inside the
--   <a>within</a> will not be printed. Therefore, you should use
--   <a>within</a> only in the body of your property.
--   
--   Good: <tt>prop_foo a b c = within 1000000 ...</tt>
--   
--   Bad: <tt>prop_foo = within 1000000 $ \a b c -&gt; ...</tt>
--   
--   Bad: <tt>prop_foo a b c = ...; main = quickCheck (within 1000000
--   prop_foo)</tt>
within :: Testable prop => Int -> prop -> Property

-- | Implication for properties: The resulting property holds if the first
--   argument is <a>False</a> (in which case the test case is discarded),
--   or if the given property holds. Note that using implication carelessly
--   can severely skew test case distribution: consider using <a>cover</a>
--   to make sure that your test data is still good quality.
(==>) :: Testable prop => Bool -> prop -> Property
infixr 0 ==>

-- | Checks that the values in a given <tt>table</tt> appear a certain
--   proportion of the time. A call to <a>coverTable</a> <tt>table</tt>
--   <tt>[(x1, p1), ..., (xn, pn)]</tt> asserts that of the values in
--   <tt>table</tt>, <tt>x1</tt> should appear at least <tt>p1</tt> percent
--   of the time, <tt>x2</tt> at least <tt>p2</tt> percent of the time, and
--   so on.
--   
--   <b>Note:</b> If the coverage check fails, QuickCheck prints out a
--   warning, but the property does <i>not</i> fail. To make the property
--   fail, use <a>checkCoverage</a>.
--   
--   Continuing the example from the <tt>tabular</tt> combinator...
--   
--   <pre>
--   data Command = LogIn | LogOut | SendMessage String deriving (Data, Show)
--   prop_chatroom :: [Command] -&gt; Property
--   prop_chatroom cmds =
--     wellFormed cmds LoggedOut ==&gt;
--     'tabulate' "Commands" (map (show . 'Data.Data.toConstr') cmds) $
--       ...
--   </pre>
--   
--   ...we can add a coverage requirement as follows, which checks that
--   <tt>LogIn</tt>, <tt>LogOut</tt> and <tt>SendMessage</tt> each occur at
--   least 25% of the time:
--   
--   <pre>
--   prop_chatroom :: [Command] -&gt; Property
--   prop_chatroom cmds =
--     wellFormed cmds LoggedOut ==&gt;
--     coverTable "Commands" [("LogIn", 25), ("LogOut", 25), ("SendMessage", 25)] $
--     'tabulate' "Commands" (map (show . 'Data.Data.toConstr') cmds) $
--       ... property goes here ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_chatroom
--   +++ OK, passed 100 tests; 2909 discarded:
--   56% 0
--   17% 1
--   10% 2
--    6% 3
--    5% 4
--    3% 5
--    3% 7
--   
--   Commands (111 in total):
--   51.4% LogIn
--   30.6% SendMessage
--   18.0% LogOut
--   
--   Table 'Commands' had only 18.0% LogOut, but expected 25.0%
--   </pre>
coverTable :: Testable prop => String -> [(String, Double)] -> prop -> Property

-- | Collects information about test case distribution into a table. The
--   arguments to <a>tabulate</a> are the table's name and a list of values
--   associated with the current test case. After testing, QuickCheck
--   prints the frequency of all collected values. The frequencies are
--   expressed as a percentage of the total number of values collected.
--   
--   You should prefer <a>tabulate</a> to <a>label</a> when each test case
--   is associated with a varying number of values. Here is a (not terribly
--   useful) example, where the test data is a list of integers and we
--   record all values that occur in the list:
--   
--   <pre>
--   prop_sorted_sort :: [Int] -&gt; Property
--   prop_sorted_sort xs =
--     sorted xs ==&gt;
--     tabulate "List elements" (map show xs) $
--     sort xs === xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_sorted_sort
--   +++ OK, passed 100 tests; 1684 discarded.
--   
--   List elements (109 in total):
--    3.7% 0
--    3.7% 17
--    3.7% 2
--    3.7% 6
--    2.8% -6
--    2.8% -7
--   </pre>
--   
--   Here is a more useful example. We are testing a chatroom, where the
--   user can log in, log out, or send a message:
--   
--   <pre>
--   data Command = LogIn | LogOut | SendMessage String deriving (Data, Show)
--   instance Arbitrary Command where ...
--   </pre>
--   
--   There are some restrictions on command sequences; for example, the
--   user must log in before doing anything else. The function <tt>valid ::
--   [Command] -&gt; Bool</tt> checks that a command sequence is allowed.
--   Our property then has the form:
--   
--   <pre>
--   prop_chatroom :: [Command] -&gt; Property
--   prop_chatroom cmds =
--     valid cmds ==&gt;
--       ...
--   </pre>
--   
--   The use of <a>==&gt;</a> may skew test case distribution. We use
--   <a>collect</a> to see the length of the command sequences, and
--   <a>tabulate</a> to get the frequencies of the individual commands:
--   
--   <pre>
--   prop_chatroom :: [Command] -&gt; Property
--   prop_chatroom cmds =
--     wellFormed cmds LoggedOut ==&gt;
--     'collect' (length cmds) $
--     'tabulate' "Commands" (map (show . 'Data.Data.toConstr') cmds) $
--       ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheckWith stdArgs{maxDiscardRatio = 1000} prop_chatroom
--   +++ OK, passed 100 tests; 2775 discarded:
--   60% 0
--   20% 1
--   15% 2
--    3% 3
--    1% 4
--    1% 5
--   
--   Commands (68 in total):
--   62% LogIn
--   22% SendMessage
--   16% LogOut
--   </pre>
tabulate :: Testable prop => String -> [String] -> prop -> Property

-- | Checks that at least the given proportion of <i>successful</i> test
--   cases belong to the given class. Discarded tests (i.e. ones with a
--   false precondition) do not affect coverage.
--   
--   <b>Note:</b> If the coverage check fails, QuickCheck prints out a
--   warning, but the property does <i>not</i> fail. To make the property
--   fail, use <a>checkCoverage</a>.
--   
--   For example:
--   
--   <pre>
--   prop_sorted_sort :: [Int] -&gt; Property
--   prop_sorted_sort xs =
--     sorted xs ==&gt;
--     cover 50 (length xs &gt; 1) "non-trivial" $
--     sort xs === xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_sorted_sort
--   +++ OK, passed 100 tests; 135 discarded (26% non-trivial).
--   
--   Only 26% non-trivial, but expected 50%
--   </pre>
cover :: Testable prop => Double -> Bool -> String -> prop -> Property

-- | Reports how many test cases satisfy a given condition.
--   
--   For example:
--   
--   <pre>
--   prop_sorted_sort :: [Int] -&gt; Property
--   prop_sorted_sort xs =
--     sorted xs ==&gt;
--     classify (length xs &gt; 1) "non-trivial" $
--     sort xs === xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_sorted_sort
--   +++ OK, passed 100 tests (22% non-trivial).
--   </pre>
classify :: Testable prop => Bool -> String -> prop -> Property

-- | Attaches a label to a test case. This is used for reporting test case
--   distribution.
--   
--   <pre>
--   collect x = label (show x)
--   </pre>
--   
--   For example:
--   
--   <pre>
--   prop_reverse_reverse :: [Int] -&gt; Property
--   prop_reverse_reverse xs =
--     collect (length xs) $
--       reverse (reverse xs) === xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_reverse_reverse
--   +++ OK, passed 100 tests:
--   7% 7
--   6% 3
--   5% 4
--   4% 6
--   ...
--   </pre>
--   
--   Each use of <a>collect</a> in your property results in a separate
--   table of test case distribution in the output. If this is not what you
--   want, use <a>tabulate</a>.
collect :: (Show a, Testable prop) => a -> prop -> Property

-- | Attaches a label to a test case. This is used for reporting test case
--   distribution.
--   
--   For example:
--   
--   <pre>
--   prop_reverse_reverse :: [Int] -&gt; Property
--   prop_reverse_reverse xs =
--     label ("length of input is " ++ show (length xs)) $
--       reverse (reverse xs) === xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_reverse_reverse
--   +++ OK, passed 100 tests:
--   7% length of input is 7
--   6% length of input is 3
--   5% length of input is 4
--   4% length of input is 6
--   ...
--   </pre>
--   
--   Each use of <a>label</a> in your property results in a separate table
--   of test case distribution in the output. If this is not what you want,
--   use <a>tabulate</a>.
label :: Testable prop => String -> prop -> Property

-- | The standard parameters used by <a>checkCoverage</a>: <tt>certainty =
--   10^9</tt>, <tt>tolerance = 0.9</tt>. See <a>Confidence</a> for the
--   meaning of the parameters.
stdConfidence :: Confidence

-- | Check coverage requirements using a custom confidence level. See
--   <a>stdConfidence</a>.
--   
--   An example of making the statistical test less stringent in order to
--   improve performance:
--   
--   <pre>
--   quickCheck (checkCoverageWith stdConfidence{certainty = 10^6} prop_foo)
--   </pre>
checkCoverageWith :: Testable prop => Confidence -> prop -> Property

-- | Check that all coverage requirements defined by <a>cover</a> and
--   <a>coverTable</a> are met, using a statistically sound test, and fail
--   if they are not met.
--   
--   Ordinarily, a failed coverage check does not cause the property to
--   fail. This is because the coverage requirement is not tested in a
--   statistically sound way. If you use <a>cover</a> to express that a
--   certain value must appear 20% of the time, QuickCheck will warn you if
--   the value only appears in 19 out of 100 test cases - but since the
--   coverage varies randomly, you may have just been unlucky, and there
--   may not be any real problem with your test generation.
--   
--   When you use <a>checkCoverage</a>, QuickCheck uses a statistical test
--   to account for the role of luck in coverage failures. It will run as
--   many tests as needed until it is sure about whether the coverage
--   requirements are met. If a coverage requirement is not met, the
--   property fails.
--   
--   Example:
--   
--   <pre>
--   quickCheck (checkCoverage prop_foo)
--   </pre>
checkCoverage :: Testable prop => prop -> Property

-- | Configures how many times a property will be tested.
--   
--   For example,
--   
--   <pre>
--   quickCheck (withMaxSuccess 1000 p)
--   </pre>
--   
--   will test <tt>p</tt> up to 1000 times.
withMaxSuccess :: Testable prop => Int -> prop -> Property

-- | Modifies a property so that it will be tested repeatedly. Opposite of
--   <a>once</a>.
again :: Testable prop => prop -> Property

-- | Modifies a property so that it only will be tested once. Opposite of
--   <a>again</a>.
once :: Testable prop => prop -> Property

-- | Indicates that a property is supposed to fail. QuickCheck will report
--   an error if it does not fail.
expectFailure :: Testable prop => prop -> Property

-- | Prints out the generated testcase every time the property fails,
--   including during shrinking. Only variables quantified over
--   <i>inside</i> the <a>verboseShrinking</a> are printed.
verboseShrinking :: Testable prop => prop -> Property

-- | Performs an <a>IO</a> action every time a property fails. Thus, if
--   shrinking is done, this can be used to keep track of the failures
--   along the way.
whenFail' :: Testable prop => IO () -> prop -> Property

-- | Performs an <a>IO</a> action after the last failure of a property.
whenFail :: Testable prop => IO () -> prop -> Property

-- | Adds the given string to the counterexample if the property fails.
printTestCase :: Testable prop => String -> prop -> Property

-- | Adds the given string to the counterexample if the property fails.
counterexample :: Testable prop => String -> prop -> Property

-- | Disables shrinking for a property altogether. Only quantification
--   <i>inside</i> the call to <a>noShrinking</a> is affected.
noShrinking :: Testable prop => prop -> Property

-- | Shrinks the argument to a property if it fails. Shrinking is done
--   automatically for most types. This function is only needed when you
--   want to override the default behavior.
shrinking :: Testable prop => (a -> [a]) -> a -> (a -> prop) -> Property

-- | Adjust the test case size for a property, by transforming it with the
--   given function.
mapSize :: Testable prop => (Int -> Int) -> prop -> Property

-- | Do I/O inside a property.
--   
--   Warning: during shrinking, the I/O may not always be re-executed.
--   Instead, the I/O may be executed once and then its result retained. If
--   this is not acceptable, use <a>ioProperty</a> instead.
idempotentIOProperty :: Testable prop => IO prop -> Property

-- | Do I/O inside a property.
--   
--   Warning: any random values generated inside of the argument to
--   <tt>ioProperty</tt> will not currently be shrunk. For best results,
--   generate all random values before calling <tt>ioProperty</tt>, or use
--   <a>idempotentIOProperty</a> if that is safe.
--   
--   Note: if your property does no quantification, it will only be tested
--   once. To test it repeatedly, use <a>again</a>.
ioProperty :: Testable prop => IO prop -> Property

-- | The type of properties.
data Property

-- | The class of properties, i.e., types which QuickCheck knows how to
--   test. Typically a property will be a function returning <a>Bool</a> or
--   <a>Property</a>.
--   
--   If a property does no quantification, i.e. has no parameters and
--   doesn't use <a>forAll</a>, it will only be tested once. This may not
--   be what you want if your property is an <tt>IO Bool</tt>. You can
--   change this behaviour using the <a>again</a> combinator.
class Testable prop

-- | Convert the thing to a property.
property :: Testable prop => prop -> Property

-- | Optional; used internally in order to improve shrinking. Tests a
--   property but also quantifies over an extra value (with a custom shrink
--   and show function). The <a>Testable</a> instance for functions defines
--   <tt>propertyForAllShrinkShow</tt> in a way that improves shrinking.
propertyForAllShrinkShow :: Testable prop => Gen a -> (a -> [a]) -> (a -> [String]) -> (a -> prop) -> Property

-- | If a property returns <a>Discard</a>, the current test case is
--   discarded, the same as if a precondition was false.
--   
--   An example is the definition of <a>==&gt;</a>:
--   
--   <pre>
--   (==&gt;) :: Testable prop =&gt; Bool -&gt; prop -&gt; Property
--   False ==&gt; _ = property Discard
--   True  ==&gt; p = property p
--   </pre>
data Discard
Discard :: Discard

-- | The statistical parameters used by <tt>checkCoverage</tt>.
data Confidence
Confidence :: Integer -> Double -> Confidence

-- | How certain <tt>checkCoverage</tt> must be before the property fails.
--   If the coverage requirement is met, and the certainty parameter is
--   <tt>n</tt>, then you should get a false positive at most one in
--   <tt>n</tt> runs of QuickCheck. The default value is <tt>10^9</tt>.
--   
--   Lower values will speed up <tt>checkCoverage</tt> at the cost of false
--   positives.
--   
--   If you are using <tt>checkCoverage</tt> as part of a test suite, you
--   should be careful not to set <tt>certainty</tt> too low. If you want,
--   say, a 1% chance of a false positive during a project's lifetime, then
--   <tt>certainty</tt> should be set to at least <tt>100 * m * n</tt>,
--   where <tt>m</tt> is the number of uses of <tt>cover</tt> in the test
--   suite, and <tt>n</tt> is the number of times you expect the test suite
--   to be run during the project's lifetime. The default value is chosen
--   to be big enough for most projects.
[certainty] :: Confidence -> Integer

-- | For statistical reasons, <tt>checkCoverage</tt> will not reject
--   coverage levels that are only slightly below the required levels. If
--   the required level is <tt>p</tt> then an actual level of <tt>tolerance
--   * p</tt> will be accepted. The default value is <tt>0.9</tt>.
--   
--   Lower values will speed up <tt>checkCoverage</tt> at the cost of not
--   detecting minor coverage violations.
[tolerance] :: Confidence -> Double

-- | Extracts the value of a ternary function. <a>Fn3</a> is the pattern
--   equivalent of this function.
applyFun3 :: () => Fun (a, b, c) d -> a -> b -> c -> d

-- | Extracts the value of a binary function.
--   
--   <a>Fn2</a> is the pattern equivalent of this function.
--   
--   <pre>
--   prop_zipWith :: Fun (Int, Bool) Char -&gt; [Int] -&gt; [Bool] -&gt; Bool
--   prop_zipWith f xs ys = zipWith (applyFun2 f) xs ys == [ applyFun2 f x y | (x, y) &lt;- zip xs ys]
--   </pre>
applyFun2 :: () => Fun (a, b) c -> a -> b -> c

-- | Extracts the value of a function.
--   
--   <a>Fn</a> is the pattern equivalent of this function.
--   
--   <pre>
--   prop :: Fun String Integer -&gt; Bool
--   prop f = applyFun f "banana" == applyFun f "monkey"
--         || applyFun f "banana" == applyFun f "elephant"
--   </pre>
applyFun :: () => Fun a b -> a -> b

-- | The basic building block for <a>Function</a> instances. Provides a
--   <a>Function</a> instance by mapping to and from a type that already
--   has a <a>Function</a> instance.
functionMap :: Function b => (a -> b) -> (b -> a) -> (a -> c) -> a :-> c

-- | Provides a <a>Function</a> instance for types isomorphic to
--   <a>Void</a>.
--   
--   An actual <tt><a>Function</a> <a>Void</a></tt> instance is defined in
--   <tt>quickcheck-instances</tt>.
functionVoid :: () => (forall b. () => void -> b) -> void :-> c

-- | Provides a <a>Function</a> instance for types with <a>Show</a> and
--   <a>Read</a>.
functionShow :: (Show a, Read a) => (a -> c) -> a :-> c

-- | Provides a <a>Function</a> instance for types with <a>Integral</a>.
functionIntegral :: Integral a => (a -> b) -> a :-> b

-- | Provides a <a>Function</a> instance for types with <a>RealFrac</a>.
functionRealFrac :: RealFrac a => (a -> b) -> a :-> b

-- | Provides a <a>Function</a> instance for types with <a>Bounded</a> and
--   <a>Enum</a>. Use only for small types (i.e. not integers): creates the
--   list <tt>['minBound'..'maxBound']</tt>!
functionBoundedEnum :: (Eq a, Bounded a, Enum a) => (a -> b) -> a :-> b

-- | A modifier for testing functions.
--   
--   <pre>
--   prop :: Fun String Integer -&gt; Bool
--   prop (Fn f) = f "banana" == f "monkey"
--              || f "banana" == f "elephant"
--   </pre>
pattern Fn :: forall a b. () => () => (a -> b) -> Fun a b

-- | A modifier for testing binary functions.
--   
--   <pre>
--   prop_zipWith :: Fun (Int, Bool) Char -&gt; [Int] -&gt; [Bool] -&gt; Bool
--   prop_zipWith (Fn2 f) xs ys = zipWith f xs ys == [ f x y | (x, y) &lt;- zip xs ys]
--   </pre>
pattern Fn2 :: forall a b c. () => () => (a -> b -> c) -> Fun (a, b) c

-- | A modifier for testing ternary functions.
pattern Fn3 :: forall a b c d. () => () => (a -> b -> c -> d) -> Fun (a, b, c) d

-- | The class <tt>Function a</tt> is used for random generation of
--   showable functions of type <tt>a -&gt; b</tt>.
--   
--   There is a default implementation for <a>function</a>, which you can
--   use if your type has structural equality. Otherwise, you can normally
--   use <a>functionMap</a> or <a>functionShow</a>.
class Function a
function :: Function a => (a -> b) -> a :-> b

-- | Generation of random shrinkable, showable functions.
--   
--   To generate random values of type <tt><a>Fun</a> a b</tt>, you must
--   have an instance <tt><a>Function</a> a</tt>.
--   
--   See also <a>applyFun</a>, and <a>Fn</a> with GHC &gt;= 7.8.
data Fun a b
Fun :: (a :-> b, b, Shrunk) -> (a -> b) -> Fun a b

-- | <tt>Blind x</tt>: as x, but x does not have to be in the <a>Show</a>
--   class.
newtype Blind a
Blind :: a -> Blind a
[getBlind] :: Blind a -> a

-- | <tt>Fixed x</tt>: as x, but will not be shrunk.
newtype Fixed a
Fixed :: a -> Fixed a
[getFixed] :: Fixed a -> a

-- | <tt>Ordered xs</tt>: guarantees that xs is ordered.
newtype OrderedList a
Ordered :: [a] -> OrderedList a
[getOrdered] :: OrderedList a -> [a]

-- | <tt>NonEmpty xs</tt>: guarantees that xs is non-empty.
newtype NonEmptyList a
NonEmpty :: [a] -> NonEmptyList a
[getNonEmpty] :: NonEmptyList a -> [a]

-- | <tt>InfiniteList xs _</tt>: guarantees that xs is an infinite list.
--   When a counterexample is found, only prints the prefix of xs that was
--   used by the program.
--   
--   Here is a contrived example property:
--   
--   <pre>
--   prop_take_10 :: InfiniteList Char -&gt; Bool
--   prop_take_10 (InfiniteList xs _) =
--     or [ x == 'a' | x &lt;- take 10 xs ]
--   </pre>
--   
--   In the following counterexample, the list must start with
--   <tt>"bbbbbbbbbb"</tt> but the remaining (infinite) part can contain
--   anything:
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_take_10
--   *** Failed! Falsified (after 1 test and 14 shrinks):
--   "bbbbbbbbbb" ++ ...
--   </pre>
data InfiniteList a
InfiniteList :: [a] -> InfiniteListInternalData a -> InfiniteList a
[getInfiniteList] :: InfiniteList a -> [a]
[infiniteListInternalData] :: InfiniteList a -> InfiniteListInternalData a

-- | <tt>Sorted xs</tt>: guarantees that xs is sorted.
newtype SortedList a
Sorted :: [a] -> SortedList a
[getSorted] :: SortedList a -> [a]

-- | <tt>Positive x</tt>: guarantees that <tt>x &gt; 0</tt>.
newtype Positive a
Positive :: a -> Positive a
[getPositive] :: Positive a -> a

-- | <tt>Negative x</tt>: guarantees that <tt>x &lt; 0</tt>.
newtype Negative a
Negative :: a -> Negative a
[getNegative] :: Negative a -> a

-- | <tt>NonZero x</tt>: guarantees that <tt>x /= 0</tt>.
newtype NonZero a
NonZero :: a -> NonZero a
[getNonZero] :: NonZero a -> a

-- | <tt>NonNegative x</tt>: guarantees that <tt>x &gt;= 0</tt>.
newtype NonNegative a
NonNegative :: a -> NonNegative a
[getNonNegative] :: NonNegative a -> a

-- | <tt>NonPositive x</tt>: guarantees that <tt>x &lt;= 0</tt>.
newtype NonPositive a
NonPositive :: a -> NonPositive a
[getNonPositive] :: NonPositive a -> a

-- | <tt>Large x</tt>: by default, QuickCheck generates <a>Int</a>s drawn
--   from a small range. <tt>Large Int</tt> gives you values drawn from the
--   entire range instead.
newtype Large a
Large :: a -> Large a
[getLarge] :: Large a -> a

-- | <tt>Small x</tt>: generates values of <tt>x</tt> drawn from a small
--   range. The opposite of <a>Large</a>.
newtype Small a
Small :: a -> Small a
[getSmall] :: Small a -> a

-- | <tt>Shrink2 x</tt>: allows 2 shrinking steps at the same time when
--   shrinking x
newtype Shrink2 a
Shrink2 :: a -> Shrink2 a
[getShrink2] :: Shrink2 a -> a

-- | <tt>Smart _ x</tt>: tries a different order when shrinking.
data Smart a
Smart :: Int -> a -> Smart a

-- | <tt>Shrinking _ x</tt>: allows for maintaining a state during
--   shrinking.
data Shrinking s a
Shrinking :: s -> a -> Shrinking s a
class ShrinkState s a
shrinkInit :: ShrinkState s a => a -> s
shrinkState :: ShrinkState s a => a -> s -> [(a, s)]

-- | <tt>ASCIIString</tt>: generates an ASCII string.
newtype ASCIIString
ASCIIString :: String -> ASCIIString
[getASCIIString] :: ASCIIString -> String

-- | <tt>UnicodeString</tt>: generates a unicode String. The string will
--   not contain surrogate pairs.
newtype UnicodeString
UnicodeString :: String -> UnicodeString
[getUnicodeString] :: UnicodeString -> String

-- | <tt>PrintableString</tt>: generates a printable unicode String. The
--   string will not contain surrogate pairs.
newtype PrintableString
PrintableString :: String -> PrintableString
[getPrintableString] :: PrintableString -> String

-- | Generates an infinite list.
infiniteList :: Arbitrary a => Gen [a]

-- | Generates an ordered list.
orderedList :: (Ord a, Arbitrary a) => Gen [a]

-- | Generates a list of a given length.
vector :: Arbitrary a => Int -> Gen [a]

-- | A <a>coarbitrary</a> implementation for enums.
coarbitraryEnum :: Enum a => a -> Gen b -> Gen b

-- | <a>coarbitrary</a> helper for lazy people :-).
coarbitraryShow :: Show a => a -> Gen b -> Gen b

-- | A <a>coarbitrary</a> implementation for real numbers.
coarbitraryReal :: Real a => a -> Gen b -> Gen b

-- | A <a>coarbitrary</a> implementation for integral numbers.
coarbitraryIntegral :: Integral a => a -> Gen b -> Gen b

-- | Combine two generator perturbing functions, for example the results of
--   calls to <a>variant</a> or <a>coarbitrary</a>.
(><) :: () => (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a

-- | Generic CoArbitrary implementation.
genericCoarbitrary :: (Generic a, GCoArbitrary (Rep a)) => a -> Gen b -> Gen b

-- | Shrink a real number, preferring numbers with shorter decimal
--   representations. See also <a>shrinkRealFrac</a>.
shrinkDecimal :: RealFrac a => a -> [a]

-- | Shrink a fraction, preferring numbers with smaller numerators or
--   denominators. See also <a>shrinkDecimal</a>.
shrinkRealFrac :: RealFrac a => a -> [a]

-- | Shrink an integral number.
shrinkIntegral :: Integral a => a -> [a]

-- | Non-overloaded version of <a>shrinkMap</a>.
shrinkMapBy :: () => (a -> b) -> (b -> a) -> (a -> [a]) -> b -> [b]

-- | Map a shrink function to another domain. This is handy if your data
--   type has special invariants, but is <i>almost</i> isomorphic to some
--   other type.
--   
--   <pre>
--   shrinkOrderedList :: (Ord a, Arbitrary a) =&gt; [a] -&gt; [[a]]
--   shrinkOrderedList = shrinkMap sort id
--   
--   shrinkSet :: (Ord a, Arbitrary a) =&gt; Set a -&gt; Set [a]
--   shrinkSet = shrinkMap fromList toList
--   </pre>
shrinkMap :: Arbitrary a => (a -> b) -> (b -> a) -> b -> [b]

-- | Returns no shrinking alternatives.
shrinkNothing :: () => a -> [a]

-- | Generates a printable Unicode character.
arbitraryPrintableChar :: Gen Char

-- | Generates a random ASCII character (0-127).
arbitraryASCIIChar :: Gen Char

-- | Generates any Unicode character (but not a surrogate)
arbitraryUnicodeChar :: Gen Char

-- | Generates an integral number from a bounded domain. The number is
--   chosen from the entire range of the type, but small numbers are
--   generated more often than big numbers. Inspired by demands from Phil
--   Wadler.
arbitrarySizedBoundedIntegral :: (Bounded a, Integral a) => Gen a

-- | Generates an element of a bounded enumeration.
arbitraryBoundedEnum :: (Bounded a, Enum a) => Gen a

-- | Generates an element of a bounded type. The element is chosen from the
--   entire range of the type.
arbitraryBoundedRandom :: (Bounded a, Random a) => Gen a

-- | Generates an integral number. The number is chosen uniformly from the
--   entire range of the type. You may want to use
--   <a>arbitrarySizedBoundedIntegral</a> instead.
arbitraryBoundedIntegral :: (Bounded a, Integral a) => Gen a

-- | Generates a fractional number. The number can be positive or negative
--   and its maximum absolute value depends on the size parameter.
arbitrarySizedFractional :: Fractional a => Gen a

-- | Generates a natural number. The number's maximum value depends on the
--   size parameter.
arbitrarySizedNatural :: Integral a => Gen a

-- | Generates an integral number. The number can be positive or negative
--   and its maximum absolute value depends on the size parameter.
arbitrarySizedIntegral :: Integral a => Gen a

-- | Apply a function of arity 4 to random arguments.
applyArbitrary4 :: (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d) => (a -> b -> c -> d -> r) -> Gen r

-- | Apply a ternary function to random arguments.
applyArbitrary3 :: (Arbitrary a, Arbitrary b, Arbitrary c) => (a -> b -> c -> r) -> Gen r

-- | Apply a binary function to random arguments.
applyArbitrary2 :: (Arbitrary a, Arbitrary b) => (a -> b -> r) -> Gen r

-- | Shrink a list of values given a shrinking function for individual
--   values.
shrinkList :: () => (a -> [a]) -> [a] -> [[a]]

-- | All immediate subterms of a term.
subterms :: (Generic a, GSubterms (Rep a) a) => a -> [a]

-- | Recursively shrink all immediate subterms.
recursivelyShrink :: (Generic a, RecursivelyShrink (Rep a)) => a -> [a]

-- | Shrink a term to any of its immediate subterms, and also recursively
--   shrink all subterms.
genericShrink :: (Generic a, RecursivelyShrink (Rep a), GSubterms (Rep a) a) => a -> [a]
shrink2 :: (Arbitrary2 f, Arbitrary a, Arbitrary b) => f a b -> [f a b]
arbitrary2 :: (Arbitrary2 f, Arbitrary a, Arbitrary b) => Gen (f a b)
shrink1 :: (Arbitrary1 f, Arbitrary a) => f a -> [f a]
arbitrary1 :: (Arbitrary1 f, Arbitrary a) => Gen (f a)

-- | Random generation and shrinking of values.
--   
--   QuickCheck provides <tt>Arbitrary</tt> instances for most types in
--   <tt>base</tt>, except those which incur extra dependencies. For a
--   wider range of <tt>Arbitrary</tt> instances see the
--   <a>quickcheck-instances</a> package.
class Arbitrary a

-- | A generator for values of the given type.
--   
--   It is worth spending time thinking about what sort of test data you
--   want - good generators are often the difference between finding bugs
--   and not finding them. You can use <a>sample</a>, <tt>label</tt> and
--   <tt>classify</tt> to check the quality of your test data.
--   
--   There is no generic <tt>arbitrary</tt> implementation included because
--   we don't know how to make a high-quality one. If you want one,
--   consider using the <a>testing-feat</a> or <a>generic-random</a>
--   packages.
--   
--   The <a>QuickCheck manual</a> goes into detail on how to write good
--   generators. Make sure to look at it, especially if your type is
--   recursive!
arbitrary :: Arbitrary a => Gen a

-- | Produces a (possibly) empty list of all the possible immediate shrinks
--   of the given value.
--   
--   The default implementation returns the empty list, so will not try to
--   shrink the value. If your data type has no special invariants, you can
--   enable shrinking by defining <tt>shrink = <a>genericShrink</a></tt>,
--   but by customising the behaviour of <tt>shrink</tt> you can often get
--   simpler counterexamples.
--   
--   Most implementations of <a>shrink</a> should try at least three
--   things:
--   
--   <ol>
--   <li>Shrink a term to any of its immediate subterms. You can use
--   <a>subterms</a> to do this.</li>
--   <li>Recursively apply <a>shrink</a> to all immediate subterms. You can
--   use <a>recursivelyShrink</a> to do this.</li>
--   <li>Type-specific shrinkings such as replacing a constructor by a
--   simpler constructor.</li>
--   </ol>
--   
--   For example, suppose we have the following implementation of binary
--   trees:
--   
--   <pre>
--   data Tree a = Nil | Branch a (Tree a) (Tree a)
--   </pre>
--   
--   We can then define <a>shrink</a> as follows:
--   
--   <pre>
--   shrink Nil = []
--   shrink (Branch x l r) =
--     -- shrink Branch to Nil
--     [Nil] ++
--     -- shrink to subterms
--     [l, r] ++
--     -- recursively shrink subterms
--     [Branch x' l' r' | (x', l', r') &lt;- shrink (x, l, r)]
--   </pre>
--   
--   There are a couple of subtleties here:
--   
--   <ul>
--   <li>QuickCheck tries the shrinking candidates in the order they appear
--   in the list, so we put more aggressive shrinking steps (such as
--   replacing the whole tree by <tt>Nil</tt>) before smaller ones (such as
--   recursively shrinking the subtrees).</li>
--   <li>It is tempting to write the last line as <tt>[Branch x' l' r' | x'
--   &lt;- shrink x, l' &lt;- shrink l, r' &lt;- shrink r]</tt> but this is
--   the <i>wrong thing</i>! It will force QuickCheck to shrink <tt>x</tt>,
--   <tt>l</tt> and <tt>r</tt> in tandem, and shrinking will stop once
--   <i>one</i> of the three is fully shrunk.</li>
--   </ul>
--   
--   There is a fair bit of boilerplate in the code above. We can avoid it
--   with the help of some generic functions. The function
--   <a>genericShrink</a> tries shrinking a term to all of its subterms
--   and, failing that, recursively shrinks the subterms. Using it, we can
--   define <a>shrink</a> as:
--   
--   <pre>
--   shrink x = shrinkToNil x ++ genericShrink x
--     where
--       shrinkToNil Nil = []
--       shrinkToNil (Branch _ l r) = [Nil]
--   </pre>
--   
--   <a>genericShrink</a> is a combination of <a>subterms</a>, which
--   shrinks a term to any of its subterms, and <a>recursivelyShrink</a>,
--   which shrinks all subterms of a term. These may be useful if you need
--   a bit more control over shrinking than <a>genericShrink</a> gives you.
--   
--   A final gotcha: we cannot define <a>shrink</a> as simply
--   <tt><a>shrink</a> x = Nil:<a>genericShrink</a> x</tt> as this shrinks
--   <tt>Nil</tt> to <tt>Nil</tt>, and shrinking will go into an infinite
--   loop.
--   
--   If all this leaves you bewildered, you might try <tt><a>shrink</a> =
--   <a>genericShrink</a></tt> to begin with, after deriving
--   <tt>Generic</tt> for your type. However, if your data type has any
--   special invariants, you will need to check that <a>genericShrink</a>
--   can't break those invariants.
shrink :: Arbitrary a => a -> [a]

-- | Lifting of the <a>Arbitrary</a> class to unary type constructors.
class Arbitrary1 (f :: Type -> Type)
liftArbitrary :: Arbitrary1 f => Gen a -> Gen (f a)
liftShrink :: Arbitrary1 f => (a -> [a]) -> f a -> [f a]

-- | Lifting of the <a>Arbitrary</a> class to binary type constructors.
class Arbitrary2 (f :: Type -> Type -> Type)
liftArbitrary2 :: Arbitrary2 f => Gen a -> Gen b -> Gen (f a b)
liftShrink2 :: Arbitrary2 f => (a -> [a]) -> (b -> [b]) -> f a b -> [f a b]

-- | Used for random generation of functions. You should consider using
--   <a>Fun</a> instead, which can show the generated functions as strings.
--   
--   If you are using a recent GHC, there is a default definition of
--   <a>coarbitrary</a> using <a>genericCoarbitrary</a>, so if your type
--   has a <a>Generic</a> instance it's enough to say
--   
--   <pre>
--   instance CoArbitrary MyType
--   </pre>
--   
--   You should only use <a>genericCoarbitrary</a> for data types where
--   equality is structural, i.e. if you can't have two different
--   representations of the same value. An example where it's not safe is
--   sets implemented using binary search trees: the same set can be
--   represented as several different trees. Here you would have to
--   explicitly define <tt>coarbitrary s = coarbitrary (toList s)</tt>.
class CoArbitrary a

-- | Used to generate a function of type <tt>a -&gt; b</tt>. The first
--   argument is a value, the second a generator. You should use
--   <a>variant</a> to perturb the random generator; the goal is that
--   different values for the first argument will lead to different calls
--   to <a>variant</a>. An example will help:
--   
--   <pre>
--   instance CoArbitrary a =&gt; CoArbitrary [a] where
--     coarbitrary []     = <a>variant</a> 0
--     coarbitrary (x:xs) = <a>variant</a> 1 . coarbitrary (x,xs)
--   </pre>
coarbitrary :: CoArbitrary a => a -> Gen b -> Gen b

-- | Generates an infinite list.
infiniteListOf :: () => Gen a -> Gen [a]

-- | Generates a list of the given length.
vectorOf :: () => Int -> Gen a -> Gen [a]

-- | Generates a non-empty list of random length. The maximum length
--   depends on the size parameter.
listOf1 :: () => Gen a -> Gen [a]

-- | Generates a list of random length. The maximum length depends on the
--   size parameter.
listOf :: () => Gen a -> Gen [a]

-- | Takes a list of elements of increasing size, and chooses among an
--   initial segment of the list. The size of this initial segment
--   increases with the size parameter. The input list must be non-empty.
growingElements :: () => [a] -> Gen a

-- | Generates a random permutation of the given list.
shuffle :: () => [a] -> Gen [a]

-- | Generates a random subsequence of the given list.
sublistOf :: () => [a] -> Gen [a]

-- | Generates one of the given values. The input list must be non-empty.
elements :: () => [a] -> Gen a

-- | Chooses one of the given generators, with a weighted random
--   distribution. The input list must be non-empty.
frequency :: () => [(Int, Gen a)] -> Gen a

-- | Randomly uses one of the given generators. The input list must be
--   non-empty.
oneof :: () => [Gen a] -> Gen a

-- | Tries to generate a value that satisfies a predicate. If it fails to
--   do so after enough attempts, returns <tt>Nothing</tt>.
suchThatMaybe :: () => Gen a -> (a -> Bool) -> Gen (Maybe a)

-- | Generates a value for which the given function returns a <a>Just</a>,
--   and then applies the function.
suchThatMap :: () => Gen a -> (a -> Maybe b) -> Gen b

-- | Generates a value that satisfies a predicate.
suchThat :: () => Gen a -> (a -> Bool) -> Gen a

-- | Generates some example values and prints them to <tt>stdout</tt>.
sample :: Show a => Gen a -> IO ()

-- | Generates some example values.
sample' :: () => Gen a -> IO [a]

-- | Run a generator. The size passed to the generator is always 30; if you
--   want another size then you should explicitly use <a>resize</a>.
generate :: () => Gen a -> IO a

-- | Generates a random element in the given inclusive range.
choose :: Random a => (a, a) -> Gen a

-- | Adjust the size parameter, by transforming it with the given function.
scale :: () => (Int -> Int) -> Gen a -> Gen a

-- | Overrides the size parameter. Returns a generator which uses the given
--   size instead of the runtime-size parameter.
resize :: () => Int -> Gen a -> Gen a

-- | Returns the size parameter. Used to construct generators that depend
--   on the size parameter.
--   
--   For example, <a>listOf</a>, which uses the size parameter as an upper
--   bound on length of lists it generates, can be defined like this:
--   
--   <pre>
--   listOf :: Gen a -&gt; Gen [a]
--   listOf gen = do
--     n &lt;- getSize
--     k &lt;- choose (0,n)
--     vectorOf k gen
--   </pre>
--   
--   You can also do this using <a>sized</a>.
getSize :: Gen Int

-- | Used to construct generators that depend on the size parameter.
--   
--   For example, <a>listOf</a>, which uses the size parameter as an upper
--   bound on length of lists it generates, can be defined like this:
--   
--   <pre>
--   listOf :: Gen a -&gt; Gen [a]
--   listOf gen = sized $ \n -&gt;
--     do k &lt;- choose (0,n)
--        vectorOf k gen
--   </pre>
--   
--   You can also do this using <a>getSize</a>.
sized :: () => (Int -> Gen a) -> Gen a

-- | Modifies a generator using an integer seed.
variant :: Integral n => n -> Gen a -> Gen a

-- | A generator for values of type <tt>a</tt>.
--   
--   The third-party packages <a>QuickCheck-GenT</a> and
--   <a>quickcheck-transformer</a> provide monad transformer versions of
--   <tt>Gen</tt>.
data Gen a

-- | A special error value. If a property evaluates <a>discard</a>, it
--   causes QuickCheck to discard the current test case. This can be useful
--   if you want to discard the current test case, but are somewhere you
--   can't use <a>==&gt;</a>, such as inside a generator.
discard :: () => a
newtype QC
QC :: Property -> QC

-- | Convert tasty options into QuickCheck options.
--   
--   This is a low-level function that was originally added for tasty-hspec
--   but may be used by others.
optionSetToArgs :: OptionSet -> IO (Int, Args)
instance GHC.Real.Integral Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance GHC.Enum.Enum Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance GHC.Real.Real Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance GHC.Classes.Eq Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance GHC.Classes.Ord Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance GHC.Num.Num Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance GHC.Real.Integral Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance GHC.Enum.Enum Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance GHC.Real.Real Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance GHC.Classes.Eq Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance GHC.Classes.Ord Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance GHC.Num.Num Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance GHC.Real.Integral Test.Tasty.QuickCheck.QuickCheckMaxSize
instance GHC.Enum.Enum Test.Tasty.QuickCheck.QuickCheckMaxSize
instance GHC.Real.Real Test.Tasty.QuickCheck.QuickCheckMaxSize
instance GHC.Classes.Eq Test.Tasty.QuickCheck.QuickCheckMaxSize
instance GHC.Classes.Ord Test.Tasty.QuickCheck.QuickCheckMaxSize
instance GHC.Num.Num Test.Tasty.QuickCheck.QuickCheckMaxSize
instance GHC.Real.Integral Test.Tasty.QuickCheck.QuickCheckTests
instance GHC.Enum.Enum Test.Tasty.QuickCheck.QuickCheckTests
instance GHC.Real.Real Test.Tasty.QuickCheck.QuickCheckTests
instance GHC.Classes.Eq Test.Tasty.QuickCheck.QuickCheckTests
instance GHC.Classes.Ord Test.Tasty.QuickCheck.QuickCheckTests
instance GHC.Num.Num Test.Tasty.QuickCheck.QuickCheckTests
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckMaxShrinks
instance Test.Tasty.Core.IsTest Test.Tasty.QuickCheck.QC
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckVerbose
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckMaxRatio
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckMaxSize
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckShowReplay
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckReplay
instance Test.Tasty.Options.IsOption Test.Tasty.QuickCheck.QuickCheckTests
