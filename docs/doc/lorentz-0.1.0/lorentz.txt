-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | EDSL for the Michelson Language
--   
--   Lorentz is a powerful meta-programming tool which allows one to write
--   Michelson contracts directly in Haskell. It has the same instructions
--   as Michelson, but operates on Haskell values and allows one to use
--   Haskell features.
@package lorentz
@version 0.1.0


-- | Scope-related constraints used in Lorentz.
--   
--   This contains constraints from <a>Scope</a> modified for use in
--   Lorentz.
module Lorentz.Constraints.Scopes

-- | Constraint applied to any part of parameter type.
--   
--   Note that you don't usually apply this constraint to the whole
--   parameter, consider using <a>NiceParameterFull</a> in such case.
--   
--   Using this type is justified e.g. when calling another contract, there
--   you usually supply an entrypoint argument, not the whole parameter.
type NiceParameter a = (KnownValue a, ProperParameterBetterErrors (ToT a))
type NiceStorage a = (KnownValue a, ProperStorageBetterErrors (ToT a))
type NiceConstant a = (KnownValue a, ProperConstantBetterErrors (ToT a))
type NicePackedValue a = (KnownValue a, ProperPackedValBetterErrors (ToT a))
type NiceUnpackedValue a = (KnownValue a, ProperUnpackedValBetterErrors (ToT a))
type NiceFullPackedValue a = (NicePackedValue a, NiceUnpackedValue a)
type NicePrintedValue a = (KnownValue a, ProperPrintedValBetterErrors (ToT a))
type NiceComparable a = (KnownValue a, ProperComparabilityBetterErrors (ToT a))
niceParameterEvi :: forall a. NiceParameter a :- ParameterScope (ToT a)
niceStorageEvi :: forall a. NiceStorage a :- StorageScope (ToT a)
niceConstantEvi :: forall a. NiceConstant a :- ConstantScope (ToT a)
nicePackedValueEvi :: forall a. NicePackedValue a :- PackedValScope (ToT a)
niceUnpackedValueEvi :: forall a. NiceUnpackedValue a :- UnpackedValScope (ToT a)
nicePrintedValueEvi :: forall a. NicePrintedValue a :- PrintedValScope (ToT a)
class (IsoValue a, HasNoNestedBigMaps (ToT a)) => CanHaveBigMap a

-- | Gathers constraints, commonly required for values.
class (IsoValue a, Typeable (ToT a), SingI (ToT a)) => KnownValue a
class (IsoValue a, Typeable (ToCT a), SingI (ToCT a)) => KnownCValue a

-- | Ensure given type does not contain "operation".
class (IsoValue a, ForbidOp (ToT a)) => NoOperation a
class (IsoValue a, ForbidContract (ToT a)) => NoContractType a
class (IsoValue a, ForbidBigMap (ToT a)) => NoBigMap a

-- | From a <a>Dict</a>, takes a value in an environment where the instance
--   witnessed by the <a>Dict</a> is in scope, and evaluates it.
--   
--   Essentially a deconstruction of a <a>Dict</a> into its
--   continuation-style form.
--   
--   Can also be used to deconstruct an entailment, <tt>a <a>:-</a> b</tt>,
--   using a context <tt>a</tt>.
--   
--   <pre>
--   withDict :: <a>Dict</a> c -&gt; (c =&gt; r) -&gt; r
--   withDict :: a =&gt; (a <a>:-</a> c) -&gt; (c =&gt; r) -&gt; r
--   </pre>
withDict :: HasDict c e => e -> (c -> r) -> r
instance (Michelson.Typed.Haskell.Value.IsoValue a, Michelson.Typed.Scope.HasNoNestedBigMaps (Michelson.Typed.Haskell.Value.ToT a)) => Lorentz.Constraints.Scopes.CanHaveBigMap a
instance (Michelson.Typed.Haskell.Value.IsoValue a, Michelson.Typed.Scope.ForbidBigMap (Michelson.Typed.Haskell.Value.ToT a)) => Lorentz.Constraints.Scopes.NoBigMap a
instance (Michelson.Typed.Haskell.Value.IsoValue a, Michelson.Typed.Scope.ForbidContract (Michelson.Typed.Haskell.Value.ToT a)) => Lorentz.Constraints.Scopes.NoContractType a
instance (Michelson.Typed.Haskell.Value.IsoValue a, Michelson.Typed.Scope.ForbidOp (Michelson.Typed.Haskell.Value.ToT a)) => Lorentz.Constraints.Scopes.NoOperation a
instance (Michelson.Typed.Haskell.Value.IsoValue a, Data.Typeable.Internal.Typeable (Michelson.Typed.Haskell.Value.ToCT a), Data.Singletons.Internal.SingI (Michelson.Typed.Haskell.Value.ToCT a)) => Lorentz.Constraints.Scopes.KnownCValue a
instance (Michelson.Typed.Haskell.Value.IsoValue a, Data.Typeable.Internal.Typeable (Michelson.Typed.Haskell.Value.ToT a), Data.Singletons.Internal.SingI (Michelson.Typed.Haskell.Value.ToT a)) => Lorentz.Constraints.Scopes.KnownValue a

module Lorentz.EntryPoints.Helpers
ctorNameToAnn :: forall ctor. (KnownSymbol ctor, HasCallStack) => FieldAnn
ctorNameToEp :: forall ctor. (KnownSymbol ctor, HasCallStack) => EpName

-- | Used to understand whether a type can potentially declare any
--   entrypoints.
type family CanHaveEntryPoints (p :: Type) :: Bool

-- | A special type which wraps over a primitive type and states that it
--   has entrypoints (one).
--   
--   Assuming that any type can have entrypoints makes use of Lorentz
--   entrypoints too annoying, so for declaring entrypoints for not sum
--   types we require an explicit wrapper.
newtype ShouldHaveEntryPoints a
ShouldHaveEntryPoints :: a -> ShouldHaveEntryPoints a
[unHasEntryPoints] :: ShouldHaveEntryPoints a -> a

-- | Ensure that given type is a sum type.
--   
--   This helps to prevent attempts to apply a function to, for instance, a
--   pair.
type family RequireSumType (a :: Type) :: Constraint
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.EntryPoints.Helpers.ShouldHaveEntryPoints a)
instance GHC.Generics.Generic (Lorentz.EntryPoints.Helpers.ShouldHaveEntryPoints a)


-- | Type families from <a>Polymorphic</a> lifted to Haskell types.
module Lorentz.Polymorphic

-- | Lifted <a>MemOpKey</a>.
class (MemOp (ToT c), ToT (MemOpKeyHs c) ~  'Tc (MemOpKey (ToT c))) => MemOpHs c where {
    type family MemOpKeyHs c :: Type;
}

-- | Lifted <a>MapOp</a>.
class (MapOp (ToT c), ToT (MapOpInpHs c) ~ MapOpInp (ToT c), ToT (MapOpResHs c ()) ~ MapOpRes (ToT c) (ToT ())) => MapOpHs c where {
    type family MapOpInpHs c :: Type;
    type family MapOpResHs c :: Type -> Type;
}

-- | Lifted <a>IterOp</a>.
class (IterOp (ToT c), ToT (IterOpElHs c) ~ IterOpEl (ToT c)) => IterOpHs c where {
    type family IterOpElHs c :: Type;
}

-- | Lifted <a>SizeOp</a>.
--   
--   This could be just a constraint alias, but to avoid <a>T</a> types
--   appearance in error messages we make a full type class with concrete
--   instances.
class SizeOp (ToT c) => SizeOpHs c

-- | Lifted <a>UpdOp</a>.
class (UpdOp (ToT c), ToT (UpdOpKeyHs c) ~  'Tc (UpdOpKey (ToT c)), ToT (UpdOpParamsHs c) ~ UpdOpParams (ToT c)) => UpdOpHs c where {
    type family UpdOpKeyHs c :: Type;
    type family UpdOpParamsHs c :: Type;
}

-- | Lifted <a>GetOp</a>.
class (GetOp (ToT c), ToT (GetOpKeyHs c) ~  'Tc (GetOpKey (ToT c)), ToT (GetOpValHs c) ~ GetOpVal (ToT c)) => GetOpHs c where {
    type family GetOpKeyHs c :: Type;
    type family GetOpValHs c :: Type;
}

-- | Lifted <a>ConcatOp</a>.
class ConcatOp (ToT c) => ConcatOpHs c

-- | Lifted <a>SliceOp</a>.
class SliceOp (ToT c) => SliceOpHs c

-- | Lifted <a>EDivOp</a>.
class (EDivOp (ToCT n) (ToCT m), IsComparable n, IsComparable m, ToT (EDivOpResHs n m) ~  'Tc (EDivOpRes (ToCT n) (ToCT m)), ToT (EModOpResHs n m) ~  'Tc (EModOpRes (ToCT n) (ToCT m))) => EDivOpHs n m where {
    type family EDivOpResHs n m :: Type;
    type family EModOpResHs n m :: Type;
}

-- | A useful property which holds for reasonable <a>MapOp</a> instances.
--   
--   It's a separate thing from <a>MapOpHs</a> because it mentions
--   <tt>b</tt> type parameter.
type family IsoMapOpRes c b
instance Lorentz.Polymorphic.EDivOpHs GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Lorentz.Polymorphic.EDivOpHs GHC.Integer.Type.Integer GHC.Natural.Natural
instance Lorentz.Polymorphic.EDivOpHs GHC.Natural.Natural GHC.Integer.Type.Integer
instance Lorentz.Polymorphic.EDivOpHs GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Polymorphic.EDivOpHs Tezos.Core.Mutez Tezos.Core.Mutez
instance Lorentz.Polymorphic.EDivOpHs Tezos.Core.Mutez GHC.Natural.Natural
instance Lorentz.Polymorphic.SliceOpHs Michelson.Text.MText
instance Lorentz.Polymorphic.SliceOpHs Data.ByteString.Internal.ByteString
instance Lorentz.Polymorphic.ConcatOpHs Michelson.Text.MText
instance Lorentz.Polymorphic.ConcatOpHs Data.ByteString.Internal.ByteString
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.GetOpHs (Data.Map.Internal.Map k v)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.GetOpHs (Michelson.Typed.Haskell.Value.BigMap k v)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.UpdOpHs (Data.Map.Internal.Map k v)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.UpdOpHs (Michelson.Typed.Haskell.Value.BigMap k v)
instance Michelson.Typed.Haskell.Value.IsComparable a => Lorentz.Polymorphic.UpdOpHs (Data.Set.Internal.Set a)
instance Lorentz.Polymorphic.SizeOpHs Michelson.Text.MText
instance Lorentz.Polymorphic.SizeOpHs Data.ByteString.Internal.ByteString
instance Lorentz.Polymorphic.SizeOpHs (Data.Set.Internal.Set a)
instance Lorentz.Polymorphic.SizeOpHs [a]
instance Lorentz.Polymorphic.SizeOpHs (Data.Map.Internal.Map k v)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.IterOpHs (Data.Map.Internal.Map k v)
instance Lorentz.Polymorphic.IterOpHs [e]
instance Michelson.Typed.Haskell.Value.IsComparable e => Lorentz.Polymorphic.IterOpHs (Data.Set.Internal.Set e)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.MapOpHs (Data.Map.Internal.Map k v)
instance Lorentz.Polymorphic.MapOpHs [e]
instance Michelson.Typed.Haskell.Value.IsComparable e => Lorentz.Polymorphic.MemOpHs (Data.Set.Internal.Set e)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.MemOpHs (Data.Map.Internal.Map k v)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.MemOpHs (Michelson.Typed.Haskell.Value.BigMap k v)


-- | Commonly used parts of regular Prelude.
module Lorentz.Prelude

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>($)</tt> is levity-polymorphic in its result type, so
--   that foo $ True where foo :: Bool -&gt; Int# is well-typed
($) :: () => (a -> b) -> a -> b
infixr 0 $

-- | Function composition.
(.) :: () => (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | Infix application.
--   
--   <pre>
--   f :: Either String $ Maybe Int
--   =
--   f :: Either String (Maybe Int)
--   </pre>
type ($) (f :: k -> k1) (a :: k) = f a
infixr 2 $

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the associativity law:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</pre></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <tt>&lt;&gt;</tt>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in <i>O(1)</i> by picking
--   <tt>stimes = <tt>stimesIdempotent</tt></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> <a>mempty</a> = x</pre></li>
--   <li><pre><a>mempty</a> <a>&lt;&gt;</a> x = x</pre></li>
--   <li><tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a> law)</li>
--   <li><pre><a>mconcat</a> = <a>foldr</a> '(&lt;&gt;)'
--   <a>mempty</a></pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = '(&lt;&gt;)'</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <tt>id</tt>
--   <a>to</a> . <a>from</a> ≡ <tt>id</tt>
--   </pre>
class Generic a

-- | A space efficient, packed, unboxed Unicode text type.
data Text

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt>'undefined :: a'</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k) :: forall k. () => k -> Type
Proxy :: Proxy
fromString :: IsString a => String -> a

-- | <a>undefined</a> that leaves a warning in code on every usage.
undefined :: HasCallStack => a

-- | <a>error</a> that takes <a>Text</a> as an argument.
error :: HasCallStack => Text -> a


-- | Type annotations for Lorentz types.
module Lorentz.TypeAnns
class HasTypeAnn a
getTypeAnn :: HasTypeAnn a => Notes (ToT a)
getTypeAnn :: (HasTypeAnn a, GHasTypeAnn (Rep a), GValueType (Rep a) ~ ToT a) => Notes (ToT a)
class GHasTypeAnn a
gGetTypeAnn :: GHasTypeAnn a => Notes (GValueType a)
instance (Lorentz.TypeAnns.HasTypeAnn a, GHC.TypeLits.KnownSymbol name) => Lorentz.TypeAnns.HasTypeAnn (Named.Internal.NamedF Data.Functor.Identity.Identity a name)
instance (Lorentz.TypeAnns.HasTypeAnn (GHC.Maybe.Maybe a), GHC.TypeLits.KnownSymbol name) => Lorentz.TypeAnns.HasTypeAnn (Named.Internal.NamedF GHC.Maybe.Maybe a name)
instance Lorentz.TypeAnns.HasTypeAnn a => Lorentz.TypeAnns.HasTypeAnn (GHC.Maybe.Maybe a)
instance Lorentz.TypeAnns.HasTypeAnn ()
instance Lorentz.TypeAnns.HasTypeAnn GHC.Integer.Type.Integer
instance Lorentz.TypeAnns.HasTypeAnn GHC.Natural.Natural
instance Lorentz.TypeAnns.HasTypeAnn Michelson.Text.MText
instance Lorentz.TypeAnns.HasTypeAnn GHC.Types.Bool
instance Lorentz.TypeAnns.HasTypeAnn Data.ByteString.Internal.ByteString
instance Lorentz.TypeAnns.HasTypeAnn Tezos.Core.Mutez
instance Lorentz.TypeAnns.HasTypeAnn Tezos.Address.Address
instance Lorentz.TypeAnns.HasTypeAnn Michelson.Typed.EntryPoints.EpAddress
instance Lorentz.TypeAnns.HasTypeAnn Tezos.Crypto.KeyHash
instance Lorentz.TypeAnns.HasTypeAnn Tezos.Core.Timestamp
instance Lorentz.TypeAnns.HasTypeAnn Tezos.Crypto.PublicKey
instance Lorentz.TypeAnns.HasTypeAnn Tezos.Crypto.Signature
instance Lorentz.TypeAnns.HasTypeAnn a => Lorentz.TypeAnns.HasTypeAnn (Michelson.Typed.Haskell.Value.ContractRef a)
instance Lorentz.TypeAnns.HasTypeAnn v => Lorentz.TypeAnns.HasTypeAnn (Data.Map.Internal.Map k v)
instance Lorentz.TypeAnns.HasTypeAnn v => Lorentz.TypeAnns.HasTypeAnn (Michelson.Typed.Haskell.Value.BigMap k v)
instance (Data.Singletons.Internal.SingI (Michelson.Typed.Haskell.Value.ToCT v), Data.Typeable.Internal.Typeable (Michelson.Typed.Haskell.Value.ToCT v)) => Lorentz.TypeAnns.HasTypeAnn (Data.Set.Internal.Set v)
instance Lorentz.TypeAnns.HasTypeAnn a => Lorentz.TypeAnns.HasTypeAnn [a]
instance Lorentz.TypeAnns.HasTypeAnn Michelson.Typed.Aliases.Operation
instance (Lorentz.TypeAnns.HasTypeAnn a, Lorentz.TypeAnns.HasTypeAnn b) => Lorentz.TypeAnns.HasTypeAnn (a, b)
instance (Lorentz.TypeAnns.HasTypeAnn a, Lorentz.TypeAnns.HasTypeAnn b, Lorentz.TypeAnns.HasTypeAnn c) => Lorentz.TypeAnns.HasTypeAnn (a, b, c)
instance (Lorentz.TypeAnns.HasTypeAnn a, Lorentz.TypeAnns.HasTypeAnn b, Lorentz.TypeAnns.HasTypeAnn c, Lorentz.TypeAnns.HasTypeAnn d) => Lorentz.TypeAnns.HasTypeAnn (a, b, c, d)
instance (Lorentz.TypeAnns.HasTypeAnn a, Lorentz.TypeAnns.HasTypeAnn b, Lorentz.TypeAnns.HasTypeAnn c, Lorentz.TypeAnns.HasTypeAnn d, Lorentz.TypeAnns.HasTypeAnn e) => Lorentz.TypeAnns.HasTypeAnn (a, b, c, d, e)
instance (Lorentz.TypeAnns.HasTypeAnn a, Lorentz.TypeAnns.HasTypeAnn b, Lorentz.TypeAnns.HasTypeAnn c, Lorentz.TypeAnns.HasTypeAnn d, Lorentz.TypeAnns.HasTypeAnn e, Lorentz.TypeAnns.HasTypeAnn f) => Lorentz.TypeAnns.HasTypeAnn (a, b, c, d, e, f)
instance (Lorentz.TypeAnns.HasTypeAnn a, Lorentz.TypeAnns.HasTypeAnn b, Lorentz.TypeAnns.HasTypeAnn c, Lorentz.TypeAnns.HasTypeAnn d, Lorentz.TypeAnns.HasTypeAnn e, Lorentz.TypeAnns.HasTypeAnn f, Lorentz.TypeAnns.HasTypeAnn g) => Lorentz.TypeAnns.HasTypeAnn (a, b, c, d, e, f, g)
instance Lorentz.TypeAnns.HasTypeAnn x => Lorentz.TypeAnns.GHasTypeAnn (GHC.Generics.Rec0 x)
instance Lorentz.TypeAnns.GHasTypeAnn GHC.Generics.U1
instance Lorentz.TypeAnns.GHasTypeAnn x => Lorentz.TypeAnns.GHasTypeAnn (GHC.Generics.M1 i0 i1 x)
instance (Lorentz.TypeAnns.GHasTypeAnn x, Lorentz.TypeAnns.GHasTypeAnn y) => Lorentz.TypeAnns.GHasTypeAnn (x GHC.Generics.:+: y)
instance (Lorentz.TypeAnns.GHasTypeAnn x, Lorentz.TypeAnns.GHasTypeAnn y) => Lorentz.TypeAnns.GHasTypeAnn (x GHC.Generics.:*: y)


-- | Primitives supplying entrypoints declarations and lookup.
module Lorentz.EntryPoints.Core

-- | Used to understand whether a type can potentially declare any
--   entrypoints.
type family CanHaveEntryPoints (p :: Type) :: Bool

-- | Defines a generalized way to declare entrypoints for various parameter
--   types.
--   
--   When defining instances of this typeclass, set concrete <tt>deriv</tt>
--   argument and leave variable <tt>cp</tt> argument. Also keep in mind,
--   that in presence of explicit default entrypoint, all other <a>Or</a>
--   arms should be callable, though you can put this burden on user if
--   very necessary.
--   
--   Methods of this typeclass aim to better type-safety when making up an
--   implementation and they may be not too convenient to use; users should
--   exploit their counterparts.
class EntryPointsDerivation deriv cp where {
    
    -- | Name and argument of each entrypoint. This may include intermediate
    --   ones, even root if necessary.
    --   
    --   Touching this type family is costly (<tt>O(N^2)</tt>), don't use it
    --   often.
    --   
    --   Note [order of entrypoints children]: If this contains entrypoints
    --   referring to indermediate nodes (not leaves) in <tt>or</tt> tree, then
    --   each such entrypoint should be mentioned eariler than all of its
    --   children.
    type family EpdAllEntryPoints deriv cp :: [(Symbol, Type)];
    
    -- | Get entrypoint argument by name.
    type family EpdLookupEntryPoint deriv cp :: Symbol -> Exp (Maybe Type);
}

-- | Construct parameter annotations corresponding to expected entrypoints
--   set.
--   
--   This method is implementation detail, for actual notes construction
--   use <a>parameterEntryPointsToNotes</a>.
--   
--   TODO [#35]: Should also return field annotation
epdNotes :: EntryPointsDerivation deriv cp => Notes (ToT cp)

-- | Construct entrypoint caller.
--   
--   This does not treat calls to default entrypoint in a special way.
--   
--   This method is implementation detail, for actual entrypoint lookup use
--   <a>parameterEntryPointCall</a>.
epdCall :: (EntryPointsDerivation deriv cp, ParameterScope (ToT cp)) => Label name -> EpConstructionRes (ToT cp) (Eval (EpdLookupEntryPoint deriv cp name))

-- | Description of how each of the entrypoints is constructed.
epdDescs :: EntryPointsDerivation deriv cp => Rec EpCallingDesc (EpdAllEntryPoints deriv cp)

-- | Result of entrypoint lookup at term level.
data EpConstructionRes (param :: T) (marg :: Maybe Type)
[EpConstructed] :: ParameterScope (ToT arg) => EpLiftSequence (ToT arg) param -> EpConstructionRes param ( 'Just arg)
[EpConstructionFailed] :: EpConstructionRes param  'Nothing

-- | How one of the entrypoints is called.
--   
--   Type arguments are name of the constructor which eventually gave name
--   to the entrypoint and this entrypoint's argument.
data EpCallingDesc (info :: (Symbol, Type))
[EpCallingDesc] :: {epcdArg :: Proxy (arg :: Type) " Entrypoint argument type.", epcdEntrypoint :: EpName " Name of assigned entrypoint.", epcdSteps :: [EpCallingStep] " If we emulated entrypoints calling via just wrapping an argument into constructors until getting the full parameter, how would it look like. Steps are enlisted in reversed order - top-level constructors go last."} -> EpCallingDesc '(name, arg)
data EpCallingStep

-- | Wrap into constructor with given name.
EpsWrapIn :: Text -> EpCallingStep

-- | Ensure that all declared entrypoints are unique.
type RequireAllUniqueEntryPoints cp = RequireAllUniqueEntryPoints' (ParameterEntryPointsDerivation cp) cp

-- | Which entrypoints given parameter declares.
--   
--   Note that usually this function should not be used as constraint, use
--   <a>ParameterDeclaresEntryPoints</a> for this purpose.
class (EntryPointsDerivation (ParameterEntryPointsDerivation cp) cp, RequireAllUniqueEntryPoints cp) => ParameterHasEntryPoints cp where {
    type family ParameterEntryPointsDerivation cp :: Type;
}

-- | Parameter declares some entrypoints.
--   
--   This is a version of <a>ParameterHasEntryPoints</a> which we actually
--   use in constraints. When given type is a sum type or newtype, we refer
--   to <a>ParameterHasEntryPoints</a> instance, otherwise this instance is
--   not necessary.
type ParameterDeclaresEntryPoints cp = (If (CanHaveEntryPoints cp) (ParameterHasEntryPoints cp) (() :: Constraint), NiceParameter cp, EntryPointsDerivation (GetParameterEpDerivation cp) cp)

-- | Version of <a>ParameterEntryPointsDerivation</a> which we actually use
--   in function signatures. When given type is sum type or newtype, we
--   refer to <a>ParameterEntryPointsDerivation</a>, otherwise we suppose
--   that no entrypoints are declared.
type GetParameterEpDerivation cp = If (CanHaveEntryPoints cp) (ParameterEntryPointsDerivation cp) EpdNone

-- | Version of <a>epdNotes</a> which we actually use in code. It hides
--   derivations stuff inside, and treats primitive types specially like
--   <a>GetParameterEpDerivation</a> does.
pepNotes :: forall cp. ParameterDeclaresEntryPoints cp => Notes (ToT cp)

-- | Version of <a>epdCall</a> which we actually use in code. It hides
--   derivations stuff inside, and treats primitive types specially like
--   <a>GetParameterEpDerivation</a> does.
pepCall :: forall cp name. (ParameterDeclaresEntryPoints cp, ParameterScope (ToT cp)) => Label name -> EpConstructionRes (ToT cp) (Eval (LookupParameterEntryPoint cp name))

-- | Version of <a>epdDescs</a> which we actually use in code. It hides
--   derivations stuff inside, and treats primitive types specially like
--   <a>GetParameterEpDerivation</a> does.
pepDescs :: forall cp. ParameterDeclaresEntryPoints cp => Rec EpCallingDesc (AllParameterEntryPoints cp)

-- | Descriptions of how each of the entrypoints is constructed.
--   
--   Similar to <a>pepDescs</a>, but includes default entrypoint disregard
--   whether it is explicit or not, while <a>pepDescs</a> includes it only
--   if it is explicit. Also this returns list, not <a>Rec</a>, for
--   simplicity.
--   
--   Note that [order of entrypoints children] property still holds here.
pepDescsWithDef :: forall cp. ParameterDeclaresEntryPoints cp => [Some1 EpCallingDesc]

-- | Get all entrypoints declared for parameter.
type family AllParameterEntryPoints (cp :: Type) :: [(Symbol, Type)]

-- | Lookup for entrypoint type by name.
--   
--   Does not treat default entrypoints in a special way.
type family LookupParameterEntryPoint (cp :: Type) :: Symbol -> Exp (Maybe Type)

-- | Derive annotations for given parameter.
parameterEntryPointsToNotes :: forall cp. (Typeable cp, ParameterDeclaresEntryPoints cp) => ParamNotes (ToT cp)

-- | Get type of entrypoint with given name, fail if not found.
type GetEntryPointArg cp name = Eval (LiftM2 FromMaybe (TError ( 'Text "Entrypoint not found: " :<>:  'ShowType name :$$:  'Text "In contract parameter `" :<>:  'ShowType cp :<>:  'Text "`")) (LookupParameterEntryPoint cp name))

-- | Prepare call to given entrypoint.
--   
--   This does not treat calls to default entrypoint in a special way. To
--   call default entrypoint properly use
--   <a>parameterEntryPointCallDefault</a>.
parameterEntryPointCall :: forall cp name. ParameterDeclaresEntryPoints cp => Label name -> EntryPointCall cp (GetEntryPointArg cp name)

-- | Get type of entrypoint with given name, fail if not found.
type GetDefaultEntryPointArg cp = Eval (LiftM2 FromMaybe (Pure cp) (LookupParameterEntryPoint cp DefaultEpName))

-- | Call the default entrypoint.
parameterEntryPointCallDefault :: forall cp. ParameterDeclaresEntryPoints cp => EntryPointCall cp (GetDefaultEntryPointArg cp)

-- | Ensure that there is no explicit "default" entrypoint.
type ForbidExplicitDefaultEntryPoint cp = Eval (LiftM3 UnMaybe (Pure (Pure (() :: Constraint))) (TError ( 'Text "Parameter used here must have no explicit \"default\" entrypoint" :$$:  'Text "In parameter type `" :<>:  'ShowType cp :<>:  'Text "`")) (LookupParameterEntryPoint cp DefaultEpName))

-- | Similar to <a>ForbidExplicitDefaultEntryPoint</a>, but in a version
--   which the compiler can work with (and which produces errors confusing
--   for users :/)
type NoExplicitDefaultEntryPoint cp = Eval (LookupParameterEntryPoint cp DefaultEpName) ~  'Nothing

-- | Call root entrypoint safely.
sepcCallRootChecked :: forall cp. (NiceParameter cp, ForbidExplicitDefaultEntryPoint cp) => SomeEntryPointCall cp

-- | Which entrypoint to call.
--   
--   We intentionally distinguish default and non-default cases because
--   this makes API more details-agnostic.
data EntryPointRef (mname :: Maybe Symbol)

-- | Call the default entrypoint, or root if no explicit default is
--   assigned.
[CallDefault] :: EntryPointRef  'Nothing

-- | Call the given entrypoint; calling default is not treated specially.
--   You have to provide entrypoint name via passing it as type argument.
--   
--   Unfortunatelly, here we cannot accept a label because in most cases
--   our entrypoints begin from capital letter (being derived from
--   constructor name), while labels must start from a lower-case letter,
--   and there is no way to make a conversion at type-level.
[Call] :: NiceEntryPointName name => EntryPointRef ( 'Just name)

-- | Constraint on type-level entrypoint name specifier.
type NiceEntryPointName name = (KnownSymbol name, ForbidDefaultName name)
eprName :: forall mname. EntryPointRef mname -> EpName

-- | Universal entrypoint lookup.
type family GetEntryPointArgCustom cp mname :: Type

-- | This wrapper allows to pass untyped <a>EpName</a> and bypass checking
--   that entrypoint with given name and type exists.
newtype TrustEpName
TrustEpName :: EpName -> TrustEpName

-- | When we call a Lorentz contract we should pass entrypoint name and
--   corresponding argument. Ideally we want to statically check that
--   parameter has entrypoint with given name and argument. Constraint
--   defined by this type class holds for contract with parameter
--   <tt>cp</tt> that have entrypoint matching <tt>name</tt> with type
--   <tt>arg</tt>.
--   
--   In order to check this property statically, we need to know entrypoint
--   name in compile time, <a>EntryPointRef</a> type serves this purpose.
--   If entrypoint name is not known, one can use <a>TrustEpName</a>
--   wrapper to take responsibility for presence of this entrypoint.
--   
--   If you want to call a function which has this constraint, you have two
--   options: 1. Pass contract parameter <tt>cp</tt> using type
--   application, pass <a>EntryPointRef</a> as a value and pass entrypoint
--   argument. Type system will check that <tt>cp</tt> has an entrypoint
--   with given reference and type. 2. Pass <a>EpName</a> wrapped into
--   <a>TrustEpName</a> and entrypoint argument. In this case passing
--   contract parameter is not necessary, you do not even have to know it.
class HasEntryPointArg cp name arg

-- | Data returned by this method may look somewhat arbitrary.
--   <a>EpName</a> is obviously needed because <tt>name</tt> can be
--   <a>EntryPointRef</a> or <a>TrustEpName</a>. <tt>Dict</tt> is returned
--   because in <a>EntryPointRef</a> case we get this evidence for free and
--   don't want to use it. We seem to always need it anyway.
useHasEntryPointArg :: HasEntryPointArg cp name arg => name -> (Dict (ParameterScope (ToT arg)), EpName)

-- | <a>HasEntryPointArg</a> constraint specialized to default entrypoint.
type HasDefEntryPointArg cp defEpName defArg = (defEpName ~ EntryPointRef  'Nothing, HasEntryPointArg cp defEpName defArg)

-- | Checks that the given parameter consists of some specific entrypoint.
--   Similar as <a>HasEntryPointArg</a> but ensures that the argument
--   matches the following datatype.
type HasEntryPointOfType param con exp = (GetEntryPointArgCustom param ( 'Just con) ~ exp, ParameterDeclaresEntryPoints param)

-- | Check that the given entrypoint has some fields inside. This interface
--   allows for an abstraction of contract parameter so that it requires
--   some *minimal* specification, but not a concrete one.
type family ParameterContainsEntryPoints param (fields :: [NamedEp]) :: Constraint

-- | Universal entrypoint calling.
parameterEntryPointCallCustom :: forall cp mname. ParameterDeclaresEntryPoints cp => EntryPointRef mname -> EntryPointCall cp (GetEntryPointArgCustom cp mname)

-- | No entrypoints declared, parameter type will serve as argument type of
--   the only existing entrypoint (default one).
data EpdNone
type n :> ty =  'NamedEp n ty
infixr 0 :>
type RequireAllUniqueEntryPoints' deriv cp = RequireAllUnique "entrypoint name" (Eval (Map Fst $ EpdAllEntryPoints deriv cp))
instance GHC.Classes.Eq Lorentz.EntryPoints.Core.EpCallingStep
instance GHC.Show.Show Lorentz.EntryPoints.Core.EpCallingStep
instance GHC.Show.Show (Lorentz.EntryPoints.Core.EpCallingDesc info)
instance (Lorentz.EntryPoints.Core.GetEntryPointArgCustom cp mname Data.Type.Equality.~ arg, Lorentz.EntryPoints.Core.ParameterDeclaresEntryPoints cp) => Lorentz.EntryPoints.Core.HasEntryPointArg cp (Lorentz.EntryPoints.Core.EntryPointRef mname) arg
instance Lorentz.TypeAnns.HasTypeAnn cp => Lorentz.EntryPoints.Core.EntryPointsDerivation Lorentz.EntryPoints.Core.EpdNone cp
instance forall k arg (cp :: k). Lorentz.Constraints.Scopes.NiceParameter arg => Lorentz.EntryPoints.Core.HasEntryPointArg cp Lorentz.EntryPoints.Core.TrustEpName arg


-- | Some derivative constraints.
--   
--   They are moved to separate module because they need to lie quite high
--   in modules dependencies graph (unlike
--   <a>Lorentz.Constraints.Scopes</a>).
module Lorentz.Constraints.Derivative

-- | Constraint applied to a whole parameter type.
type NiceParameterFull cp = (Typeable cp, ParameterDeclaresEntryPoints cp)

module Lorentz.Constraints


-- | Packing utilities.
module Lorentz.Pack
lPackValue :: forall a. NicePackedValue a => a -> ByteString
lUnpackValue :: forall a. NiceUnpackedValue a => ByteString -> Either UnpackError a
lEncodeValue :: forall a. NicePrintedValue a => a -> ByteString


-- | Allows specifying entrypoints without declaring
--   <tt>ParamterHasEntryPoints</tt> instance.
module Lorentz.EntryPoints.Manual

-- | Wrap parameter into this to locally assign a way to derive entrypoints
--   for it.
newtype ParameterWrapper (deriv :: Type) cp
ParameterWrapper :: cp -> ParameterWrapper cp
[unParameterWraper] :: ParameterWrapper cp -> cp
instance Michelson.Typed.Haskell.Value.IsoValue cp => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.EntryPoints.Manual.ParameterWrapper deriv cp)
instance GHC.Generics.Generic (Lorentz.EntryPoints.Manual.ParameterWrapper deriv cp)
instance Lorentz.EntryPoints.Core.EntryPointsDerivation deriv cp => Lorentz.EntryPoints.Core.EntryPointsDerivation (Lorentz.EntryPoints.Manual.PwDeriv deriv) (Lorentz.EntryPoints.Manual.ParameterWrapper deriv cp)
instance (Lorentz.Constraints.Scopes.NiceParameter cp, Lorentz.EntryPoints.Core.EntryPointsDerivation epd cp, Lorentz.EntryPoints.Core.RequireAllUniqueEntryPoints' epd cp) => Lorentz.EntryPoints.Core.ParameterHasEntryPoints (Lorentz.EntryPoints.Manual.ParameterWrapper epd cp)
instance Control.Lens.Wrapped.Wrapped (Lorentz.EntryPoints.Manual.ParameterWrapper deriv cp)


-- | Foundation of Lorentz development.
module Lorentz.Base

-- | Alias for instruction which hides inner types representation via
--   <tt>T</tt>.
newtype (inp :: [Type]) :-> (out :: [Type])
LorentzInstr :: RemFail Instr (ToTs inp) (ToTs out) -> (:->)
[unLorentzInstr] :: (:->) -> RemFail Instr (ToTs inp) (ToTs out)
infixr 1 :->

-- | Alias for <a>:-&gt;</a>, seems to make signatures more readable
--   sometimes.
--   
--   Let's someday decide which one of these two should remain.
type (%>) = (:->)
infixr 1 %>
type (&) (a :: Type) (b :: [Type]) = a : b
infixr 2 &
(#) :: (a :-> b) -> (b :-> c) -> a :-> c
infixl 8 #

-- | Version of <a>#</a> which performs some optimizations immediately.
(##) :: (a :-> b) -> (b :-> c) -> a :-> c
pattern I :: Instr (ToTs inp) (ToTs out) -> inp :-> out
pattern FI :: (forall out'. Instr (ToTs inp) out') -> inp :-> out
iGenericIf :: (forall s'. Instr (ToTs a) s' -> Instr (ToTs b) s' -> Instr (ToTs c) s') -> (a :-> s) -> (b :-> s) -> c :-> s
iAnyCode :: (inp :-> out) -> Instr (ToTs inp) (ToTs out)
iNonFailingCode :: HasCallStack => (inp :-> out) -> Instr (ToTs inp) (ToTs out)
iMapAnyCode :: (forall o'. Instr (ToTs i1) o' -> Instr (ToTs i2) o') -> (i1 :-> o) -> i2 :-> o
iForceNotFail :: (i :-> o) -> i :-> o

-- | Wrap Lorentz instruction with variable annotations, <tt>annots</tt>
--   list has to be non-empty, otherwise this function raises an error.
iWithVarAnnotations :: HasCallStack => [Text] -> (inp :-> out) -> inp :-> out

-- | Parse textual representation of a Michelson value and turn it into
--   corresponding Haskell value.
--   
--   Note: it won't work in some complex cases, e. g. if there is a lambda
--   which uses an instruction which depends on current contract's type.
--   Obviously it can not work, because we don't have any information about
--   a contract to which this value belongs (there is no such contract at
--   all).
parseLorentzValue :: forall v. (IsoValue v, SingI (ToT v), Typeable (ToT v)) => Text -> Either ParseLorentzError v

-- | Lorentz version of <a>transformStrings</a>.
transformStringsLorentz :: Bool -> (MText -> MText) -> (inp :-> out) -> inp :-> out

-- | Lorentz version of <a>transformBytes</a>.
transformBytesLorentz :: Bool -> (ByteString -> ByteString) -> (inp :-> out) -> inp :-> out
optimizeLorentz :: (inp :-> out) -> inp :-> out
optimizeLorentzWithConf :: OptimizerConf -> (inp :-> out) -> inp :-> out
type ContractOut st = '[([Operation], st)]
type ContractCode cp st = '[(cp, st)] :-> ContractOut st
data SomeContract
[SomeContract] :: (NiceParameterFull cp, NiceStorage st) => ContractCode cp st -> SomeContract
type Lambda i o = '[i] :-> '[o]
instance GHC.Classes.Eq Lorentz.Base.ParseLorentzError
instance GHC.Show.Show Lorentz.Base.ParseLorentzError
instance GHC.Classes.Eq (inp Lorentz.Base.:-> out)
instance GHC.Show.Show (inp Lorentz.Base.:-> out)
instance Formatting.Buildable.Buildable Lorentz.Base.ParseLorentzError
instance GHC.Base.Semigroup (s Lorentz.Base.:-> s)
instance GHC.Base.Monoid (s Lorentz.Base.:-> s)

module Lorentz.Ext
stackRef :: forall (gn :: Nat) st n. (n ~ ToPeano gn, SingI n, KnownPeano n, RequireLongerThan st n) => PrintComment st
printComment :: PrintComment (ToTs s) -> s :-> s
testAssert :: (Typeable (ToTs out), HasCallStack) => Text -> PrintComment (ToTs inp) -> (inp :-> (Bool & out)) -> inp :-> inp
stackType :: forall s. s :-> s


-- | Common primitives.
module Lorentz.Common

-- | Single entrypoint of a contract.
--   
--   Note that we cannot make it return <tt>[[Operation], store]</tt>
--   because such entrypoint should've been followed by <tt>pair</tt>, and
--   this is not possible if entrypoint implementation ends with
--   <tt>failWith</tt>.
type Entrypoint param store = '[param, store] :-> ContractOut store

-- | Version of <a>Entrypoint</a> which accepts no argument.
type Entrypoint_ store = '[store] :-> ContractOut store


-- | This module introduces several types for safe work with
--   <tt>address</tt> and <tt>contract</tt> types. All available types for
--   that are represented in the following table:
--   
--   TODO: table
--   
--   This module also provides functions for converting between these types
--   in Haskell and Michelson worlds. In the latter you can additionally
--   use coercions and dedicated instructions from <a>Lorentz.Instr</a>.
module Lorentz.Address

-- | Address which remembers the parameter type of the contract it refers
--   to.
--   
--   It differs from Michelson's <tt>contract</tt> type because it cannot
--   contain entrypoint, and it always refers to entire contract parameter
--   even if this contract has explicit default entrypoint.
newtype TAddress p
TAddress :: Address -> TAddress p
[unTAddress] :: TAddress p -> Address

-- | Address associated with value of <tt>contract arg</tt> type.
--   
--   Places where <a>ContractRef</a> can appear are now severely limited,
--   this type gives you type-safety of <a>ContractRef</a> but still can be
--   used everywhere. This type is not a full-featured one rather a helper;
--   in particular, once pushing it on stack, you cannot return it back to
--   Haskell world.
--   
--   Note that it refers to an entrypoint of the contract, not just the
--   contract as a whole. In this sense this type differs from
--   <a>TAddress</a>.
--   
--   Unlike with <a>ContractRef</a>, having this type you still cannot be
--   sure that the referred contract exists and need to perform a lookup
--   before calling it.
newtype FutureContract arg
FutureContract :: ContractRef arg -> FutureContract arg
[unFutureContract] :: FutureContract arg -> ContractRef arg

-- | Turn <a>TAddress</a> to <a>ContractRef</a> in <i>Haskell</i> world.
--   
--   This is an analogy of <tt>address</tt> to <tt>contract</tt> convertion
--   in Michelson world, thus you have to supply an entrypoint (or call the
--   default one explicitly).
callingTAddress :: forall cp mname. NiceParameterFull cp => TAddress cp -> EntryPointRef mname -> ContractRef (GetEntryPointArgCustom cp mname)

-- | Specification of <tt>callTAddress</tt> to call the default entrypoint.
callingDefTAddress :: forall cp. NiceParameterFull cp => TAddress cp -> ContractRef (GetDefaultEntryPointArg cp)

-- | Convert something to <a>Address</a> in <i>Haskell</i> world.
--   
--   Use this when you want to access state of the contract and are not
--   interested in calling it.
class ToAddress a
toAddress :: ToAddress a => a -> Address

-- | Convert something referring to a contract (not specific entrypoint) to
--   <a>TAddress</a> in <i>Haskell</i> world.
class ToTAddress (cp :: Type) (a :: Type)
toTAddress :: ToTAddress cp a => a -> TAddress cp

-- | Something coercible to 'TAddress cp'.
type ToTAddress_ cp addr = (ToTAddress cp addr, ToT addr ~ ToT Address)

-- | Cast something appropriate to <a>TAddress</a>.
toTAddress_ :: forall cp addr s. ToTAddress_ cp addr => (addr : s) :-> (TAddress cp : s)

-- | Convert something to <a>ContractRef</a> in <i>Haskell</i> world.
class ToContractRef (cp :: Type) (contract :: Type)
toContractRef :: (ToContractRef cp contract, HasCallStack) => contract -> ContractRef cp

-- | Convert something from <tt>ContractAddr</tt> in <i>Haskell</i> world.
class FromContractRef (cp :: Type) (contract :: Type)
fromContractRef :: FromContractRef cp contract => ContractRef cp -> contract
convertContractRef :: forall cp contract2 contract1. (ToContractRef cp contract1, FromContractRef cp contract2) => contract1 -> contract2

-- | Data type corresponding to address structure in Tezos.
data Address

-- | Address with optional entrypoint name attached to it. TODO: come up
--   with better name?
data EpAddress
EpAddress :: Address -> EpName -> EpAddress

-- | Address itself
[eaAddress] :: EpAddress -> Address

-- | Entrypoint name (might be empty)
[eaEntryPoint] :: EpAddress -> EpName

-- | Since <tt>Contract</tt> name is used to designate contract code, lets
--   call analogy of <a>TContract</a> type as follows.
--   
--   Note that type argument always designates an argument of entrypoint.
--   If a contract has explicit default entrypoint (and no root
--   entrypoint), <tt>ContractRef</tt> referring to it can never have the
--   entire parameter as its type argument.
data ContractRef arg
ContractRef :: Address -> SomeEntryPointCall arg -> ContractRef arg
[crAddress] :: ContractRef arg -> Address
[crEntryPoint] :: ContractRef arg -> SomeEntryPointCall arg

-- | Replace type argument of <tt>ContractAddr</tt> with isomorphic one.
coerceContractRef :: ToT a ~ ToT b => ContractRef a -> ContractRef b
instance forall k (p :: k). Lorentz.TypeAnns.HasTypeAnn (Lorentz.Address.TAddress p)
instance forall k (p :: k). Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Address.TAddress p)
instance forall k (p :: k). GHC.Generics.Generic (Lorentz.Address.TAddress p)
instance (cp Data.Type.Equality.~ cp') => Lorentz.Address.FromContractRef cp (Michelson.Typed.Haskell.Value.ContractRef cp')
instance (cp Data.Type.Equality.~ cp') => Lorentz.Address.FromContractRef cp (Lorentz.Address.FutureContract cp')
instance Lorentz.Address.FromContractRef cp Michelson.Typed.EntryPoints.EpAddress
instance Lorentz.Address.FromContractRef cp Tezos.Address.Address
instance (cp Data.Type.Equality.~ cp') => Lorentz.Address.ToContractRef cp (Michelson.Typed.Haskell.Value.ContractRef cp')
instance (Lorentz.Constraints.Scopes.NiceParameter cp, cp Data.Type.Equality.~ cp') => Lorentz.Address.ToContractRef cp (Lorentz.Address.FutureContract cp')
instance (Util.Type.FailWhen cond msg, cond Data.Type.Equality.~ (Lorentz.EntryPoints.Helpers.CanHaveEntryPoints cp Data.Type.Bool.&& Data.Type.Bool.Not (Lorentz.EntryPoints.Core.ParameterEntryPointsDerivation cp Data.Type.Equality.== Lorentz.EntryPoints.Core.EpdNone)), msg Data.Type.Equality.~ (((('GHC.TypeLits.Text "Cannot apply `ToContractRef` to `TAddress`" 'GHC.TypeLits.:$$: 'GHC.TypeLits.Text "Consider using call(Def)TAddress first`") 'GHC.TypeLits.:$$: 'GHC.TypeLits.Text "(or if you know your parameter type is primitive,") 'GHC.TypeLits.:$$: 'GHC.TypeLits.Text " make sure typechecker also knows about that)") 'GHC.TypeLits.:$$: (('GHC.TypeLits.Text "For parameter `" 'GHC.TypeLits.:<>: 'GHC.TypeLits.ShowType cp) 'GHC.TypeLits.:<>: 'GHC.TypeLits.Text "`")), cp Data.Type.Equality.~ arg, Lorentz.Constraints.Scopes.NiceParameter arg, Lorentz.Constraints.Derivative.NiceParameterFull cp, Lorentz.EntryPoints.Core.GetDefaultEntryPointArg cp Data.Type.Equality.~ cp) => Lorentz.Address.ToContractRef arg (Lorentz.Address.TAddress cp)
instance Lorentz.Address.ToTAddress cp Tezos.Address.Address
instance (cp Data.Type.Equality.~ cp') => Lorentz.Address.ToTAddress cp (Lorentz.Address.TAddress cp')
instance Lorentz.Address.ToAddress Tezos.Address.Address
instance Lorentz.Address.ToAddress Michelson.Typed.EntryPoints.EpAddress
instance forall k (cp :: k). Lorentz.Address.ToAddress (Lorentz.Address.TAddress cp)
instance Lorentz.Address.ToAddress (Lorentz.Address.FutureContract cp)
instance Lorentz.Address.ToAddress (Michelson.Typed.Haskell.Value.ContractRef cp)
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Address.FutureContract arg)
instance Lorentz.TypeAnns.HasTypeAnn (Lorentz.Address.FutureContract a)

module Lorentz.UStore.Common
fieldNameToMText :: forall field. KnownSymbol field => MText


-- | Re-exports typed Value, CValue, some core types, some helpers and
--   defines aliases for constructors of typed values.
module Lorentz.Value
type Value = Value' Instr

-- | Isomorphism between Michelson values and plain Haskell types.
--   
--   Default implementation of this typeclass converts ADTs to Michelson
--   "pair"s and "or"s.
class IsoValue a where {
    
    -- | Type function that converts a regular Haskell type into a <tt>T</tt>
    --   type.
    type family ToT a :: T;
}

-- | Converts a Haskell structure into <tt>Value</tt> representation.
toVal :: IsoValue a => a -> Value (ToT a)

-- | Converts a <tt>Value</tt> into Haskell type.
fromVal :: IsoValue a => Value (ToT a) -> a

-- | Isomorphism between Michelson primitive values and plain Haskell
--   types.
class IsoCValue a where {
    
    -- | Type function that converts a regular Haskell type into a comparable
    --   type (which has kind <tt>CT</tt>).
    type family ToCT a :: CT;
}

-- | Converts a single Haskell value into <tt>CVal</tt> representation.
toCVal :: IsoCValue a => a -> CValue (ToCT a)

-- | Converts a <tt>CVal</tt> value into a single Haskell value.
fromCVal :: IsoCValue a => CValue (ToCT a) -> a

-- | Representation of comparable value in Michelson language.
--   
--   By specification, we're allowed to compare only following types: int,
--   nat, string, bytes, mutez, bool, key_hash, timestamp, address.
--   
--   Only these values can be used as map keys or set elements.
data CValue (t :: CT)
[CvInt] :: forall (t :: CT). () => Integer -> CValue CInt
[CvNat] :: forall (t :: CT). () => Natural -> CValue CNat
[CvString] :: forall (t :: CT). () => MText -> CValue CString
[CvBytes] :: forall (t :: CT). () => ByteString -> CValue CBytes
[CvMutez] :: forall (t :: CT). () => Mutez -> CValue CMutez
[CvBool] :: forall (t :: CT). () => Bool -> CValue CBool
[CvKeyHash] :: forall (t :: CT). () => KeyHash -> CValue CKeyHash
[CvTimestamp] :: forall (t :: CT). () => Timestamp -> CValue CTimestamp
[CvAddress] :: forall (t :: CT). () => EpAddress -> CValue CAddress

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><tt>throw</tt>
--   (<tt>Underflow</tt> :: <tt>ArithException</tt>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | Michelson string value.
--   
--   This is basically a mere text with limits imposed by the language:
--   <a>https://tezos.gitlab.io/whitedoc/michelson.html#constants</a>
--   Although, this document seems to be not fully correct, and thus we
--   applied constraints deduced empirically.
--   
--   You construct an item of this type using one of the following ways:
--   
--   <ul>
--   <li>With QuasyQuotes when need to create a string literal.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; [mt|Some text|]
--   MTextUnsafe { unMText = "Some text" }
--   </pre>
--   
--   <ul>
--   <li>With <a>mkMText</a> when constructing from a runtime text
--   value.</li>
--   <li>With <a>mkMTextUnsafe</a> or <a>MTextUnsafe</a> when absolutelly
--   sure that given string does not violate invariants.</li>
--   <li>With <a>mkMTextCut</a> when not sure about text contents and want
--   to make it compliant with Michelson constraints.</li>
--   </ul>
data MText
data Bool
False :: Bool
True :: Bool

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | Data type corresponding to address structure in Tezos.
data Address

-- | Address with optional entrypoint name attached to it. TODO: come up
--   with better name?
data EpAddress
EpAddress :: Address -> EpName -> EpAddress

-- | Address itself
[eaAddress] :: EpAddress -> Address

-- | Entrypoint name (might be empty)
[eaEntryPoint] :: EpAddress -> EpName

-- | Mutez is a wrapper over integer data type. 1 mutez is 1 token (μTz).
data Mutez

-- | Time in the real world. Use the functions below to convert it to/from
--   Unix time in seconds.
data Timestamp

-- | Identifier of a network (babylonnet, mainnet, test network or other).
--   Evaluated as hash of the genesis block.
--   
--   The only operation supported for this type is packing. Use case:
--   multisig contract, for instance, now includes chain ID into signed
--   data "in order to add extra replay protection between the main chain
--   and the test chain".
data ChainId

-- | Blake2b_160 hash of a public key.
data KeyHash

-- | Public cryptographic key used by Tezos. There are three cryptographic
--   curves each represented by its own constructor.
data PublicKey

-- | Cryptographic signatures used by Tezos. Constructors correspond to
--   <a>PublicKey</a> constructors.
--   
--   Tezos distinguishes signatures for different curves. For instance,
--   ed25519 signatures and secp256k1 signatures are printed differently
--   (have different prefix). However, signatures are packed without
--   information about the curve. For this purpose there is a generic
--   signature which only stores bytes and doesn't carry information about
--   the curve. Apparently unpacking from bytes always produces such
--   signature. Unpacking from string produces a signature with curve
--   information.
data Signature

-- | A set of values <tt>a</tt>.
data Set a

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a
newtype BigMap k v
BigMap :: Map k v -> BigMap k v
[unBigMap] :: BigMap k v -> Map k v
type Operation = Operation' Instr

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
type List = []

-- | Since <tt>Contract</tt> name is used to designate contract code, lets
--   call analogy of <a>TContract</a> type as follows.
--   
--   Note that type argument always designates an argument of entrypoint.
--   If a contract has explicit default entrypoint (and no root
--   entrypoint), <tt>ContractRef</tt> referring to it can never have the
--   entire parameter as its type argument.
data ContractRef arg
ContractRef :: Address -> SomeEntryPointCall arg -> ContractRef arg
[crAddress] :: ContractRef arg -> Address
[crEntryPoint] :: ContractRef arg -> SomeEntryPointCall arg

-- | Address which remembers the parameter type of the contract it refers
--   to.
--   
--   It differs from Michelson's <tt>contract</tt> type because it cannot
--   contain entrypoint, and it always refers to entire contract parameter
--   even if this contract has explicit default entrypoint.
newtype TAddress p
TAddress :: Address -> TAddress p
[unTAddress] :: TAddress p -> Address

-- | Address associated with value of <tt>contract arg</tt> type.
--   
--   Places where <a>ContractRef</a> can appear are now severely limited,
--   this type gives you type-safety of <a>ContractRef</a> but still can be
--   used everywhere. This type is not a full-featured one rather a helper;
--   in particular, once pushing it on stack, you cannot return it back to
--   Haskell world.
--   
--   Note that it refers to an entrypoint of the contract, not just the
--   contract as a whole. In this sense this type differs from
--   <a>TAddress</a>.
--   
--   Unlike with <a>ContractRef</a>, having this type you still cannot be
--   sure that the referred contract exists and need to perform a lookup
--   before calling it.
newtype FutureContract arg
FutureContract :: ContractRef arg -> FutureContract arg
[unFutureContract] :: FutureContract arg -> ContractRef arg

-- | Entrypoint name.
--   
--   Empty if this entrypoint is default one. Cannot be equal to "default",
--   the reference implementation forbids that. Also, set of allowed
--   characters should be the same as in annotations.
data EpName
pattern DefEpName :: () => () => EpName
type EntryPointCall param arg = EntryPointCallT ToT param ToT arg
type SomeEntryPointCall arg = SomeEntryPointCallT ToT arg

-- | Safely create <a>Mutez</a>.
--   
--   This is recommended way to create <tt>Mutez</tt> from a numeric
--   literal; you can't construct all valid <tt>Mutez</tt> values using
--   this function but for small values it works neat.
--   
--   Warnings displayed when trying to construct invalid <a>Natural</a> or
--   <a>Word</a> literal are hardcoded for these types in GHC
--   implementation, so we can only exploit these existing rules.
toMutez :: Word32 -> Mutez

-- | QuasyQuoter for constructing Michelson strings.
--   
--   Validity of result will be checked at compile time. Note:
--   
--   <ul>
--   <li>slash must be escaped</li>
--   <li>newline character must appear as '\n'</li>
--   <li>use quotes as is</li>
--   <li>other special characters are not allowed.</li>
--   </ul>
mt :: QuasiQuoter
timestampFromSeconds :: Integer -> Timestamp
timestampFromUTCTime :: UTCTime -> Timestamp

-- | Quote a value of type <a>Timestamp</a> in
--   <tt>yyyy-mm-ddThh:mm:ss[.sss]Z</tt> format.
--   
--   <pre>
--   &gt;&gt;&gt; formatTimestamp [timestampQuote| 2019-02-21T16:54:12.2344523Z |]
--   "2019-02-21T16:54:12Z"
--   </pre>
--   
--   Inspired by 'time-quote' library.
timestampQuote :: QuasiQuoter

-- | Replace type argument of <tt>ContractAddr</tt> with isomorphic one.
coerceContractRef :: ToT a ~ ToT b => ContractRef a -> ContractRef b

-- | Turn <a>TAddress</a> to <a>ContractRef</a> in <i>Haskell</i> world.
--   
--   This is an analogy of <tt>address</tt> to <tt>contract</tt> convertion
--   in Michelson world, thus you have to supply an entrypoint (or call the
--   default one explicitly).
callingTAddress :: forall cp mname. NiceParameterFull cp => TAddress cp -> EntryPointRef mname -> ContractRef (GetEntryPointArgCustom cp mname)

-- | Specification of <tt>callTAddress</tt> to call the default entrypoint.
callingDefTAddress :: forall cp. NiceParameterFull cp => TAddress cp -> ContractRef (GetDefaultEntryPointArg cp)

-- | Convert something to <a>Address</a> in <i>Haskell</i> world.
--   
--   Use this when you want to access state of the contract and are not
--   interested in calling it.
class ToAddress a
toAddress :: ToAddress a => a -> Address

-- | Convert something referring to a contract (not specific entrypoint) to
--   <a>TAddress</a> in <i>Haskell</i> world.
class ToTAddress (cp :: Type) (a :: Type)
toTAddress :: ToTAddress cp a => a -> TAddress cp

-- | Convert something to <a>ContractRef</a> in <i>Haskell</i> world.
class ToContractRef (cp :: Type) (contract :: Type)
toContractRef :: (ToContractRef cp contract, HasCallStack) => contract -> ContractRef cp

-- | Convert something from <tt>ContractAddr</tt> in <i>Haskell</i> world.
class FromContractRef (cp :: Type) (contract :: Type)
fromContractRef :: FromContractRef cp contract => ContractRef cp -> contract
convertContractRef :: forall cp contract2 contract1. (ToContractRef cp contract1, FromContractRef cp contract2) => contract1 -> contract2

-- | A class for types with a default value.
class Default a

-- | The default value for this type.
def :: Default a => a

-- | Proxy for a label type that includes the <a>KnownSymbol</a> constraint
data Label (name :: Symbol)
[Label] :: forall (name :: Symbol). KnownSymbol name => Label name


-- | Common implementations of entrypoints.
module Lorentz.EntryPoints.Impl

-- | Implementation of <a>ParameterHasEntryPoints</a> which fits for case
--   when your contract exposes multiple entrypoints via having sum type as
--   its parameter.
--   
--   In particular, each constructor would produce a homonymous entrypoint
--   with argument type equal to type of constructor field (each
--   constructor should have only one field). Constructor called
--   <a>Default</a> will designate the default entrypoint.
data EpdPlain

-- | Extension of <a>EpdPlain</a> on parameters being defined as several
--   nested datatypes.
--   
--   In particular, this will traverse sum types recursively, stopping at
--   Michelson primitives (like <a>Natural</a>) and constructors with
--   number of fields different from one.
--   
--   It does not assign names to intermediate nodes of <a>Or</a> tree, only
--   to the very leaves.
--   
--   If some entrypoint arguments have custom <a>IsoValue</a> instance,
--   this derivation way will not work. As a workaround, you can wrap your
--   argument into some primitive (e.g. <tt>:!</tt>).
data EpdRecursive

-- | Extension of <a>EpdPlain</a> on parameters being defined as several
--   nested datatypes.
--   
--   In particular, it will traverse the immediate sum type, and require
--   another <a>ParameterHasEntryPoints</a> for the inner complex
--   datatypes. Only those inner types are considered which are the only
--   fields in their respective constructors. Inner types should not
--   themselves declare default entrypoint, we enforce this for better
--   modularity. Each top-level constructor will be treated as entrypoint
--   even if it contains a complex datatype within, in such case that would
--   be an entrypoint corresponding to intermediate node in <tt>or</tt>
--   tree.
--   
--   Comparing to <a>EpdRecursive</a> this gives you more control over
--   where and how entrypoints will be derived.
data EpdDelegate
instance (Lorentz.TypeAnns.GHasTypeAnn x, GHC.TypeLits.KnownSymbol ctor, Michelson.Typed.Haskell.Value.ToT (Lorentz.EntryPoints.Impl.GExtractField x) Data.Type.Equality.~ Michelson.Typed.Haskell.Value.GValueType x) => Lorentz.EntryPoints.Impl.GEntryPointsNotes mode 'Lorentz.EntryPoints.Impl.EPLeaf (GHC.Generics.C1 ('GHC.Generics.MetaCons ctor _1 _2) x)
instance (ep Data.Type.Equality.~ 'Lorentz.EntryPoints.Impl.EPDelegate, Lorentz.EntryPoints.Impl.GEntryPointsNotes mode ep x, GHC.TypeLits.KnownSymbol ctor, Michelson.Typed.Haskell.Value.ToT (Lorentz.EntryPoints.Impl.GExtractField x) Data.Type.Equality.~ Michelson.Typed.Haskell.Value.GValueType x) => Lorentz.EntryPoints.Impl.GEntryPointsNotes mode 'Lorentz.EntryPoints.Impl.EPDelegate (GHC.Generics.C1 ('GHC.Generics.MetaCons ctor _1 _2) x)
instance Lorentz.EntryPoints.Impl.PlainEntryPointsC Lorentz.EntryPoints.Impl.EpdPlain cp => Lorentz.EntryPoints.Core.EntryPointsDerivation Lorentz.EntryPoints.Impl.EpdPlain cp
instance Lorentz.EntryPoints.Impl.PlainEntryPointsC Lorentz.EntryPoints.Impl.EpdRecursive cp => Lorentz.EntryPoints.Core.EntryPointsDerivation Lorentz.EntryPoints.Impl.EpdRecursive cp
instance Lorentz.EntryPoints.Impl.PlainEntryPointsC Lorentz.EntryPoints.Impl.EpdDelegate cp => Lorentz.EntryPoints.Core.EntryPointsDerivation Lorentz.EntryPoints.Impl.EpdDelegate cp
instance (Lorentz.EntryPoints.Impl.EntryPointsNotes Lorentz.EntryPoints.Impl.EpdRecursive ep a, Michelson.Typed.Haskell.Value.GenericIsoValue a) => Lorentz.EntryPoints.Impl.GEntryPointsNotes Lorentz.EntryPoints.Impl.EpdRecursive ep (GHC.Generics.Rec0 a)
instance Lorentz.EntryPoints.Impl.GEntryPointsNotes mode ep x => Lorentz.EntryPoints.Impl.GEntryPointsNotes mode ep (GHC.Generics.D1 i x)
instance (Lorentz.EntryPoints.Impl.GEntryPointsNotes mode epx x, Lorentz.EntryPoints.Impl.GEntryPointsNotes mode epy y) => Lorentz.EntryPoints.Impl.GEntryPointsNotes mode ('Lorentz.EntryPoints.Impl.EPNode epx epy) (x GHC.Generics.:+: y)
instance (ep Data.Type.Equality.~ 'Lorentz.EntryPoints.Impl.EPNode epx epy, Lorentz.EntryPoints.Impl.GEntryPointsNotes mode ep x, GHC.TypeLits.KnownSymbol ctor) => Lorentz.EntryPoints.Impl.GEntryPointsNotes mode ('Lorentz.EntryPoints.Impl.EPNode epx epy) (GHC.Generics.C1 ('GHC.Generics.MetaCons ctor _1 _2) x)
instance Lorentz.EntryPoints.Impl.GEntryPointsNotes mode ep x => Lorentz.EntryPoints.Impl.GEntryPointsNotes mode ep (GHC.Generics.S1 i x)
instance Lorentz.EntryPoints.Core.ParameterDeclaresEntryPoints a => Lorentz.EntryPoints.Impl.GEntryPointsNotes Lorentz.EntryPoints.Impl.EpdDelegate 'Lorentz.EntryPoints.Impl.EPDelegate (GHC.Generics.Rec0 a)
instance Lorentz.EntryPoints.Impl.GEntryPointsNotes mode 'Lorentz.EntryPoints.Impl.EPLeaf GHC.Generics.U1
instance Universum.TypeOps.Each '[Data.Typeable.Internal.Typeable, Data.Singletons.Internal.SingI] '[Michelson.Typed.Haskell.Value.GValueType x, Michelson.Typed.Haskell.Value.GValueType y] => Lorentz.EntryPoints.Impl.GEntryPointsNotes mode 'Lorentz.EntryPoints.Impl.EPLeaf (x GHC.Generics.:*: y)


-- | Entrypoints utilities for Lorentz
module Lorentz.EntryPoints

-- | Defines a generalized way to declare entrypoints for various parameter
--   types.
--   
--   When defining instances of this typeclass, set concrete <tt>deriv</tt>
--   argument and leave variable <tt>cp</tt> argument. Also keep in mind,
--   that in presence of explicit default entrypoint, all other <a>Or</a>
--   arms should be callable, though you can put this burden on user if
--   very necessary.
--   
--   Methods of this typeclass aim to better type-safety when making up an
--   implementation and they may be not too convenient to use; users should
--   exploit their counterparts.
class EntryPointsDerivation deriv cp where {
    
    -- | Name and argument of each entrypoint. This may include intermediate
    --   ones, even root if necessary.
    --   
    --   Touching this type family is costly (<tt>O(N^2)</tt>), don't use it
    --   often.
    --   
    --   Note [order of entrypoints children]: If this contains entrypoints
    --   referring to indermediate nodes (not leaves) in <tt>or</tt> tree, then
    --   each such entrypoint should be mentioned eariler than all of its
    --   children.
    type family EpdAllEntryPoints deriv cp :: [(Symbol, Type)];
    
    -- | Get entrypoint argument by name.
    type family EpdLookupEntryPoint deriv cp :: Symbol -> Exp (Maybe Type);
}

-- | Construct parameter annotations corresponding to expected entrypoints
--   set.
--   
--   This method is implementation detail, for actual notes construction
--   use <a>parameterEntryPointsToNotes</a>.
--   
--   TODO [#35]: Should also return field annotation
epdNotes :: EntryPointsDerivation deriv cp => Notes (ToT cp)

-- | Construct entrypoint caller.
--   
--   This does not treat calls to default entrypoint in a special way.
--   
--   This method is implementation detail, for actual entrypoint lookup use
--   <a>parameterEntryPointCall</a>.
epdCall :: (EntryPointsDerivation deriv cp, ParameterScope (ToT cp)) => Label name -> EpConstructionRes (ToT cp) (Eval (EpdLookupEntryPoint deriv cp name))

-- | Description of how each of the entrypoints is constructed.
epdDescs :: EntryPointsDerivation deriv cp => Rec EpCallingDesc (EpdAllEntryPoints deriv cp)

-- | Which entrypoints given parameter declares.
--   
--   Note that usually this function should not be used as constraint, use
--   <a>ParameterDeclaresEntryPoints</a> for this purpose.
class (EntryPointsDerivation (ParameterEntryPointsDerivation cp) cp, RequireAllUniqueEntryPoints cp) => ParameterHasEntryPoints cp where {
    type family ParameterEntryPointsDerivation cp :: Type;
}

-- | Parameter declares some entrypoints.
--   
--   This is a version of <a>ParameterHasEntryPoints</a> which we actually
--   use in constraints. When given type is a sum type or newtype, we refer
--   to <a>ParameterHasEntryPoints</a> instance, otherwise this instance is
--   not necessary.
type ParameterDeclaresEntryPoints cp = (If (CanHaveEntryPoints cp) (ParameterHasEntryPoints cp) (() :: Constraint), NiceParameter cp, EntryPointsDerivation (GetParameterEpDerivation cp) cp)

-- | Get all entrypoints declared for parameter.
type family AllParameterEntryPoints (cp :: Type) :: [(Symbol, Type)]

-- | Lookup for entrypoint type by name.
--   
--   Does not treat default entrypoints in a special way.
type family LookupParameterEntryPoint (cp :: Type) :: Symbol -> Exp (Maybe Type)

-- | Derive annotations for given parameter.
parameterEntryPointsToNotes :: forall cp. (Typeable cp, ParameterDeclaresEntryPoints cp) => ParamNotes (ToT cp)

-- | Get type of entrypoint with given name, fail if not found.
type GetEntryPointArg cp name = Eval (LiftM2 FromMaybe (TError ( 'Text "Entrypoint not found: " :<>:  'ShowType name :$$:  'Text "In contract parameter `" :<>:  'ShowType cp :<>:  'Text "`")) (LookupParameterEntryPoint cp name))

-- | Prepare call to given entrypoint.
--   
--   This does not treat calls to default entrypoint in a special way. To
--   call default entrypoint properly use
--   <a>parameterEntryPointCallDefault</a>.
parameterEntryPointCall :: forall cp name. ParameterDeclaresEntryPoints cp => Label name -> EntryPointCall cp (GetEntryPointArg cp name)

-- | Get type of entrypoint with given name, fail if not found.
type GetDefaultEntryPointArg cp = Eval (LiftM2 FromMaybe (Pure cp) (LookupParameterEntryPoint cp DefaultEpName))

-- | Call the default entrypoint.
parameterEntryPointCallDefault :: forall cp. ParameterDeclaresEntryPoints cp => EntryPointCall cp (GetDefaultEntryPointArg cp)

-- | Ensure that there is no explicit "default" entrypoint.
type ForbidExplicitDefaultEntryPoint cp = Eval (LiftM3 UnMaybe (Pure (Pure (() :: Constraint))) (TError ( 'Text "Parameter used here must have no explicit \"default\" entrypoint" :$$:  'Text "In parameter type `" :<>:  'ShowType cp :<>:  'Text "`")) (LookupParameterEntryPoint cp DefaultEpName))

-- | Similar to <a>ForbidExplicitDefaultEntryPoint</a>, but in a version
--   which the compiler can work with (and which produces errors confusing
--   for users :/)
type NoExplicitDefaultEntryPoint cp = Eval (LookupParameterEntryPoint cp DefaultEpName) ~  'Nothing

-- | Call root entrypoint safely.
sepcCallRootChecked :: forall cp. (NiceParameter cp, ForbidExplicitDefaultEntryPoint cp) => SomeEntryPointCall cp

-- | Which entrypoint to call.
--   
--   We intentionally distinguish default and non-default cases because
--   this makes API more details-agnostic.
data EntryPointRef (mname :: Maybe Symbol)

-- | Call the default entrypoint, or root if no explicit default is
--   assigned.
[CallDefault] :: EntryPointRef  'Nothing

-- | Call the given entrypoint; calling default is not treated specially.
--   You have to provide entrypoint name via passing it as type argument.
--   
--   Unfortunatelly, here we cannot accept a label because in most cases
--   our entrypoints begin from capital letter (being derived from
--   constructor name), while labels must start from a lower-case letter,
--   and there is no way to make a conversion at type-level.
[Call] :: NiceEntryPointName name => EntryPointRef ( 'Just name)
eprName :: forall mname. EntryPointRef mname -> EpName

-- | Universal entrypoint lookup.
type family GetEntryPointArgCustom cp mname :: Type

-- | When we call a Lorentz contract we should pass entrypoint name and
--   corresponding argument. Ideally we want to statically check that
--   parameter has entrypoint with given name and argument. Constraint
--   defined by this type class holds for contract with parameter
--   <tt>cp</tt> that have entrypoint matching <tt>name</tt> with type
--   <tt>arg</tt>.
--   
--   In order to check this property statically, we need to know entrypoint
--   name in compile time, <a>EntryPointRef</a> type serves this purpose.
--   If entrypoint name is not known, one can use <a>TrustEpName</a>
--   wrapper to take responsibility for presence of this entrypoint.
--   
--   If you want to call a function which has this constraint, you have two
--   options: 1. Pass contract parameter <tt>cp</tt> using type
--   application, pass <a>EntryPointRef</a> as a value and pass entrypoint
--   argument. Type system will check that <tt>cp</tt> has an entrypoint
--   with given reference and type. 2. Pass <a>EpName</a> wrapped into
--   <a>TrustEpName</a> and entrypoint argument. In this case passing
--   contract parameter is not necessary, you do not even have to know it.
class HasEntryPointArg cp name arg

-- | Data returned by this method may look somewhat arbitrary.
--   <a>EpName</a> is obviously needed because <tt>name</tt> can be
--   <a>EntryPointRef</a> or <a>TrustEpName</a>. <tt>Dict</tt> is returned
--   because in <a>EntryPointRef</a> case we get this evidence for free and
--   don't want to use it. We seem to always need it anyway.
useHasEntryPointArg :: HasEntryPointArg cp name arg => name -> (Dict (ParameterScope (ToT arg)), EpName)

-- | <a>HasEntryPointArg</a> constraint specialized to default entrypoint.
type HasDefEntryPointArg cp defEpName defArg = (defEpName ~ EntryPointRef  'Nothing, HasEntryPointArg cp defEpName defArg)

-- | Checks that the given parameter consists of some specific entrypoint.
--   Similar as <a>HasEntryPointArg</a> but ensures that the argument
--   matches the following datatype.
type HasEntryPointOfType param con exp = (GetEntryPointArgCustom param ( 'Just con) ~ exp, ParameterDeclaresEntryPoints param)

-- | Check that the given entrypoint has some fields inside. This interface
--   allows for an abstraction of contract parameter so that it requires
--   some *minimal* specification, but not a concrete one.
type family ParameterContainsEntryPoints param (fields :: [NamedEp]) :: Constraint

-- | This wrapper allows to pass untyped <a>EpName</a> and bypass checking
--   that entrypoint with given name and type exists.
newtype TrustEpName
TrustEpName :: EpName -> TrustEpName

-- | Universal entrypoint calling.
parameterEntryPointCallCustom :: forall cp mname. ParameterDeclaresEntryPoints cp => EntryPointRef mname -> EntryPointCall cp (GetEntryPointArgCustom cp mname)

-- | Ensure that all declared entrypoints are unique.
type RequireAllUniqueEntryPoints cp = RequireAllUniqueEntryPoints' (ParameterEntryPointsDerivation cp) cp
type n :> ty =  'NamedEp n ty
infixr 0 :>

-- | No entrypoints declared, parameter type will serve as argument type of
--   the only existing entrypoint (default one).
data EpdNone

-- | Implementation of <a>ParameterHasEntryPoints</a> which fits for case
--   when your contract exposes multiple entrypoints via having sum type as
--   its parameter.
--   
--   In particular, each constructor would produce a homonymous entrypoint
--   with argument type equal to type of constructor field (each
--   constructor should have only one field). Constructor called
--   <a>Default</a> will designate the default entrypoint.
data EpdPlain

-- | Extension of <a>EpdPlain</a> on parameters being defined as several
--   nested datatypes.
--   
--   In particular, this will traverse sum types recursively, stopping at
--   Michelson primitives (like <a>Natural</a>) and constructors with
--   number of fields different from one.
--   
--   It does not assign names to intermediate nodes of <a>Or</a> tree, only
--   to the very leaves.
--   
--   If some entrypoint arguments have custom <a>IsoValue</a> instance,
--   this derivation way will not work. As a workaround, you can wrap your
--   argument into some primitive (e.g. <tt>:!</tt>).
data EpdRecursive

-- | Extension of <a>EpdPlain</a> on parameters being defined as several
--   nested datatypes.
--   
--   In particular, it will traverse the immediate sum type, and require
--   another <a>ParameterHasEntryPoints</a> for the inner complex
--   datatypes. Only those inner types are considered which are the only
--   fields in their respective constructors. Inner types should not
--   themselves declare default entrypoint, we enforce this for better
--   modularity. Each top-level constructor will be treated as entrypoint
--   even if it contains a complex datatype within, in such case that would
--   be an entrypoint corresponding to intermediate node in <tt>or</tt>
--   tree.
--   
--   Comparing to <a>EpdRecursive</a> this gives you more control over
--   where and how entrypoints will be derived.
data EpdDelegate

-- | Wrap parameter into this to locally assign a way to derive entrypoints
--   for it.
newtype ParameterWrapper (deriv :: Type) cp
ParameterWrapper :: cp -> ParameterWrapper cp
[unParameterWraper] :: ParameterWrapper cp -> cp

-- | A special type which wraps over a primitive type and states that it
--   has entrypoints (one).
--   
--   Assuming that any type can have entrypoints makes use of Lorentz
--   entrypoints too annoying, so for declaring entrypoints for not sum
--   types we require an explicit wrapper.
newtype ShouldHaveEntryPoints a
ShouldHaveEntryPoints :: a -> ShouldHaveEntryPoints a
[unHasEntryPoints] :: ShouldHaveEntryPoints a -> a

module Lorentz.Run
data CompilationOptions
CompilationOptions :: Bool -> CompilationOptions

-- | Flag which defines, whether compiled Michelson contract will have
--   <tt>CAST</tt> (which drops parameter annotations) as a first
--   instruction. Note, that when flag is false, there still can be no
--   <tt>CAST</tt> (in case when parameter type has no annotations).
[coDisableInitialCast] :: CompilationOptions -> Bool

-- | For use outside of Lorentz.
compileLorentz :: (inp :-> out) -> Instr (ToTs inp) (ToTs out)

-- | Version of <a>compileLorentz</a> specialized to instruction
--   corresponding to contract code.
compileLorentzContract :: forall cp st. (NiceParameterFull cp, NiceStorage st) => ContractCode cp st -> FullContract (ToT cp) (ToT st)

-- | Version on <a>compileLorentzContract</a> which accepts
--   <tt>CompilationOptions</tt>.
--   
--   Note that compiled contract can be ill-typed in terms of Michelson
--   code when some of the compilation options are used (e.g. when
--   coDoInitialCast is False, resulted contract can be ill-typed).
--   However, compilation with <tt>defaultCompilationOptions</tt> should be
--   valid.
compileLorentzContractWithOptions :: forall cp st. (NiceParameterFull cp, NiceStorage st) => CompilationOptions -> ContractCode cp st -> FullContract (ToT cp) (ToT st)

-- | Interpret a Lorentz instruction, for test purposes.
interpretLorentzInstr :: (IsoValuesStack inp, IsoValuesStack out) => ContractEnv -> (inp :-> out) -> Rec Identity inp -> Either MichelsonFailed (Rec Identity out)

-- | Like <a>interpretLorentzInstr</a>, but works on lambda rather than
--   arbitrary instruction.
interpretLorentzLambda :: (IsoValue inp, IsoValue out) => ContractEnv -> Lambda inp out -> inp -> Either MichelsonFailed out

-- | Lorentz version of analyzer.
analyzeLorentz :: (inp :-> out) -> AnalyzerRes


-- | Printing lorentz contracts.
module Lorentz.Print

-- | Pretty-print a Haskell value as Michelson one.
printLorentzValue :: forall v. NicePrintedValue v => Bool -> v -> LText

-- | Pretty-print a Lorentz contract into Michelson code.
printLorentzContract :: forall cp st. (NiceParameterFull cp, NiceStorage st) => Bool -> ContractCode cp st -> LText


-- | <i>Deprecated: Use morley-nettest instead</i>
module Lorentz.TestScenario

-- | Type that represents test scenario for Lorentz contract. Simply put,
--   it is sequence of pairs (<tt>sender</tt>, <tt>parameter</tt>). Using
--   this sequence we can perform transfers to the desired contract.
type TestScenario param = [(Address, param)]

-- | Function to get textual representation of <tt>TestScenario</tt>, each
--   Parameter is printed as a raw Michelson value. This representation can
--   later be used in order to run test scenario on real network.
--   
--   The format for a single contract call is the following: # `printed
--   Lorentz parameter` (actually comment) `sender address` `printed raw
--   Michelson parameter`
showTestScenario :: (Buildable param, NicePrintedValue param) => TestScenario param -> Text
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.TestScenario.Parameter
instance GHC.Generics.Generic Lorentz.TestScenario.Parameter


-- | Type families from <a>Arith</a> lifted to Haskell types.
module Lorentz.Arith

-- | Lifted <tt>AithOp</tt>.
class (ArithOp aop (ToCT n) (ToCT m), IsComparable n, IsComparable m, Typeable (ToCT n), Typeable (ToCT m), ToT (ArithResHs aop n m) ~  'Tc (ArithRes aop (ToCT n) (ToCT m))) => ArithOpHs (aop :: Type) (n :: Type) (m :: Type) where {
    type family ArithResHs aop n m :: Type;
}

-- | Lifted <tt>UnaryAithOp</tt>.
class (UnaryArithOp aop (ToCT n), IsComparable n, Typeable (ToCT n), ToT (UnaryArithResHs aop n) ~  'Tc (UnaryArithRes aop (ToCT n))) => UnaryArithOpHs (aop :: Type) (n :: Type) where {
    type family UnaryArithResHs aop n :: Type;
}
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Abs GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Neg GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Neg GHC.Natural.Natural
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Not GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Not GHC.Natural.Natural
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Not GHC.Types.Bool
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Eq' GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Neq GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Lt GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Gt GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Le GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Ge GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add GHC.Natural.Natural GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add GHC.Integer.Type.Integer GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add Tezos.Core.Timestamp GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add GHC.Integer.Type.Integer Tezos.Core.Timestamp
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add Tezos.Core.Mutez Tezos.Core.Mutez
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub GHC.Natural.Natural GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub GHC.Integer.Type.Integer GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub Tezos.Core.Timestamp GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub Tezos.Core.Timestamp Tezos.Core.Timestamp
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub Tezos.Core.Mutez Tezos.Core.Mutez
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Mul GHC.Natural.Natural GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Mul GHC.Integer.Type.Integer GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Mul GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Mul GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Mul GHC.Natural.Natural Tezos.Core.Mutez
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Mul Tezos.Core.Mutez GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Or GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Or GHC.Types.Bool GHC.Types.Bool
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.And GHC.Integer.Type.Integer GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.And GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.And GHC.Types.Bool GHC.Types.Bool
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Xor GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Xor GHC.Types.Bool GHC.Types.Bool
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Lsl GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Lsr GHC.Natural.Natural GHC.Natural.Natural


-- | Stack zipping.
--   
--   This module provides functions for flattening stacks into tuples.
--   
--   Also here we define an instance which turns any instruction, not only
--   lambdas, into a valid value.
module Lorentz.Zip

-- | Zipping stack into tuple and back.
class ZipInstr (s :: [Type]) where {
    
    -- | A type which contains the whole stack zipped.
    type family ZippedStack s :: Type;
}

-- | Fold given stack into single value.
zipInstr :: ZipInstr s => s :-> '[ZippedStack s]

-- | Unfold given stack from a single value.
unzipInstr :: ZipInstr s => '[ZippedStack s] :-> s

-- | Require several stacks to comply <a>ZipInstr</a> constraint.
type ZipInstrs ss = Each '[ZipInstr] ss

-- | Flatten both ends of instruction stack.
zippingStack :: ZipInstrs [inp, out] => (inp :-> out) -> Lambda (ZippedStack inp) (ZippedStack out)

-- | Unflatten both ends of instruction stack.
unzippingStack :: ZipInstrs [inp, out] => Lambda (ZippedStack inp) (ZippedStack out) -> inp :-> out
instance Lorentz.Zip.ZipInstr '[]
instance Lorentz.Zip.ZipInstr '[a]
instance Lorentz.Zip.ZipInstr ((a, b) : s) => Lorentz.Zip.ZipInstr (a : b : s)
instance (Lorentz.Zip.ZipInstr inp, Lorentz.Zip.ZipInstr out) => Michelson.Typed.Haskell.Value.IsoValue (inp Lorentz.Base.:-> out)
instance (Lorentz.TypeAnns.HasTypeAnn (Lorentz.Zip.ZippedStack i), Lorentz.TypeAnns.HasTypeAnn (Lorentz.Zip.ZippedStack o)) => Lorentz.TypeAnns.HasTypeAnn (i Lorentz.Base.:-> o)

module Lorentz.Instr
nop :: s :-> s
drop :: (a & s) :-> s

-- | Drop top <tt>n</tt> elements from the stack.
dropN :: forall (n :: Nat) (s :: [Type]). (SingI (ToPeano n), KnownPeano (ToPeano n), RequireLongerOrSameLength (ToTs s) (ToPeano n), Drop (ToPeano n) (ToTs s) ~ ToTs (Drop (ToPeano n) s)) => s :-> Drop (ToPeano n) s
dup :: (a & s) :-> (a & (a & s))
swap :: (a & (b & s)) :-> (b & (a & s))
type ConstraintDIGLorentz (n :: Peano) (inp :: [Type]) (out :: [Type]) (a :: Type) = (ConstraintDIG n (ToTs inp) (ToTs out) (ToT a), ConstraintDIG' Type n inp out a)

-- | Version of <a>dig</a> which uses Peano number. It is inteded for
--   internal usage in Lorentz.
digPeano :: forall (n :: Peano) inp out a. ConstraintDIGLorentz n inp out a => inp :-> out
dig :: forall (n :: Nat) inp out a. ConstraintDIGLorentz (ToPeano n) inp out a => inp :-> out
type ConstraintDUGLorentz (n :: Peano) (inp :: [Type]) (out :: [Type]) (a :: Type) = (ConstraintDUG n (ToTs inp) (ToTs out) (ToT a), ConstraintDUG' Type n inp out a)

-- | Version of <a>dug</a> which uses Peano number. It is inteded for
--   internal usage in Lorentz.
dugPeano :: forall (n :: Peano) inp out a. ConstraintDUGLorentz n inp out a => inp :-> out
dug :: forall (n :: Nat) inp out a. ConstraintDUGLorentz (ToPeano n) inp out a => inp :-> out
push :: forall t s. NiceConstant t => t -> s :-> (t & s)
some :: (a & s) :-> (Maybe a & s)
none :: forall a s. KnownValue a => s :-> (Maybe a & s)
unit :: s :-> (() & s)
ifNone :: (s :-> s') -> ((a & s) :-> s') -> (Maybe a & s) :-> s'
pair :: (a & (b & s)) :-> ((a, b) & s)
car :: ((a, b) & s) :-> (a & s)
cdr :: ((a, b) & s) :-> (b & s)
left :: forall a b s. KnownValue b => (a & s) :-> (Either a b & s)
right :: forall a b s. KnownValue a => (b & s) :-> (Either a b & s)
ifLeft :: ((a & s) :-> s') -> ((b & s) :-> s') -> (Either a b & s) :-> s'
nil :: KnownValue p => s :-> (List p & s)
cons :: (a & (List a & s)) :-> (List a & s)
size :: SizeOpHs c => (c & s) :-> (Natural & s)
emptySet :: KnownCValue e => s :-> (Set e & s)
emptyMap :: (KnownCValue k, KnownValue v) => s :-> (Map k v & s)
emptyBigMap :: (KnownCValue k, KnownValue v) => s :-> (BigMap k v & s)
map :: (MapOpHs c, IsoMapOpRes c b, HasCallStack) => ((MapOpInpHs c & s) :-> (b & s)) -> (c & s) :-> (MapOpResHs c b & s)
iter :: (IterOpHs c, HasCallStack) => ((IterOpElHs c & s) :-> s) -> (c & s) :-> s
mem :: MemOpHs c => (MemOpKeyHs c & (c & s)) :-> (Bool & s)
get :: GetOpHs c => (GetOpKeyHs c & (c & s)) :-> (Maybe (GetOpValHs c) & s)
update :: UpdOpHs c => (UpdOpKeyHs c & (UpdOpParamsHs c & (c & s))) :-> (c & s)

-- | Helper instruction.
--   
--   Checks whether given key present in the storage and fails if it is.
--   This instruction leaves stack intact.
failingWhenPresent :: forall c k s v st e. (MemOpHs c, k ~ MemOpKeyHs c, KnownValue e, st ~ (k & (v & (c & s)))) => (forall s0. (k : s0) :-> (e : s0)) -> st :-> st

-- | Like <a>update</a>, but throw an error on attempt to overwrite
--   existing entry.
updateNew :: forall c k s e. (UpdOpHs c, MemOpHs c, k ~ UpdOpKeyHs c, k ~ MemOpKeyHs c, KnownValue e) => (forall s0. (k : s0) :-> (e : s0)) -> (k & (UpdOpParamsHs c & (c & s))) :-> (c & s)
if_ :: (s :-> s') -> (s :-> s') -> (Bool & s) :-> s'
ifCons :: ((a & (List a & s)) :-> s') -> (s :-> s') -> (List a & s) :-> s'
loop :: (s :-> (Bool & s)) -> (Bool & s) :-> s
loopLeft :: ((a & s) :-> (Either a b & s)) -> (Either a b & s) :-> (b & s)
lambda :: (ZipInstrs [i, o], KnownValue (ZippedStack i), KnownValue (ZippedStack o)) => (i :-> o) -> s :-> ((i :-> o) & s)
exec :: (a & (Lambda a b & s)) :-> (b & s)

-- | Similar to <a>exec</a> but works for lambdas with arbitrary size of
--   input and output.
--   
--   Note that this instruction has its arguments flipped, lambda goes
--   first. This seems to be the only reasonable way to achieve good
--   inference.
execute :: forall i o s. Each [KnownList, ZipInstr] [i, o] => ((i :-> o) : (i ++ s)) :-> (o ++ s)
apply :: forall a b c s. NiceConstant a => (a & (Lambda (a, b) c & s)) :-> (Lambda b c & s)
dip :: forall a s s'. HasCallStack => (s :-> s') -> (a & s) :-> (a & s')
type ConstraintDIPNLorentz (n :: Peano) (inp :: [Type]) (out :: [Type]) (s :: [Type]) (s' :: [Type]) = (ConstraintDIPN n (ToTs inp) (ToTs out) (ToTs s) (ToTs s'), ConstraintDIPN' Type n inp out s s')

-- | Version of <a>dipN</a> which uses Peano number. It is inteded for
--   internal usage in Lorentz.
dipNPeano :: forall (n :: Peano) (inp :: [Type]) (out :: [Type]) (s :: [Type]) (s' :: [Type]). ConstraintDIPNLorentz n inp out s s' => (s :-> s') -> inp :-> out
dipN :: forall (n :: Nat) (inp :: [Type]) (out :: [Type]) (s :: [Type]) (s' :: [Type]). ConstraintDIPNLorentz (ToPeano n) inp out s s' => (s :-> s') -> inp :-> out
failWith :: KnownValue a => (a & s) :-> t
cast :: KnownValue a => (a & s) :-> (a & s)
pack :: forall a s. NicePackedValue a => (a & s) :-> (ByteString & s)
unpack :: forall a s. NiceUnpackedValue a => (ByteString & s) :-> (Maybe a & s)
concat :: ConcatOpHs c => (c & (c & s)) :-> (c & s)
concat' :: ConcatOpHs c => (List c & s) :-> (c & s)
slice :: SliceOpHs c => (Natural & (Natural & (c & s))) :-> (Maybe c & s)
isNat :: (Integer & s) :-> (Maybe Natural & s)
add :: ArithOpHs Add n m => (n & (m & s)) :-> (ArithResHs Add n m & s)
sub :: ArithOpHs Sub n m => (n & (m & s)) :-> (ArithResHs Sub n m & s)
rsub :: ArithOpHs Sub n m => (m & (n & s)) :-> (ArithResHs Sub n m & s)
mul :: ArithOpHs Mul n m => (n & (m & s)) :-> (ArithResHs Mul n m & s)
ediv :: EDivOpHs n m => (n & (m & s)) :-> (Maybe (EDivOpResHs n m, EModOpResHs n m) & s)
abs :: UnaryArithOpHs Abs n => (n & s) :-> (UnaryArithResHs Abs n & s)
neg :: UnaryArithOpHs Neg n => (n & s) :-> (UnaryArithResHs Neg n & s)
lsl :: ArithOpHs Lsl n m => (n & (m & s)) :-> (ArithResHs Lsl n m & s)
lsr :: ArithOpHs Lsr n m => (n & (m & s)) :-> (ArithResHs Lsr n m & s)
or :: ArithOpHs Or n m => (n & (m & s)) :-> (ArithResHs Or n m & s)
and :: ArithOpHs And n m => (n & (m & s)) :-> (ArithResHs And n m & s)
xor :: ArithOpHs Xor n m => (n & (m & s)) :-> (ArithResHs Xor n m & s)
not :: UnaryArithOpHs Not n => (n & s) :-> (UnaryArithResHs Not n & s)
compare :: NiceComparable n => (n & (n & s)) :-> (Integer & s)
eq0 :: UnaryArithOpHs Eq' n => (n & s) :-> (UnaryArithResHs Eq' n & s)
neq0 :: UnaryArithOpHs Neq n => (n & s) :-> (UnaryArithResHs Neq n & s)
lt0 :: UnaryArithOpHs Lt n => (n & s) :-> (UnaryArithResHs Lt n & s)
gt0 :: UnaryArithOpHs Gt n => (n & s) :-> (UnaryArithResHs Gt n & s)
le0 :: UnaryArithOpHs Le n => (n & s) :-> (UnaryArithResHs Le n & s)
ge0 :: UnaryArithOpHs Ge n => (n & s) :-> (UnaryArithResHs Ge n & s)
int :: (Natural & s) :-> (Integer & s)

-- | Cast something appropriate to <a>TAddress</a>.
toTAddress_ :: forall cp addr s. ToTAddress_ cp addr => (addr : s) :-> (TAddress cp : s)

-- | Get a reference to the current contract.
--   
--   Note that, similar to <a>CONTRACT</a> instruction, in Michelson
--   <a>SELF</a> instruction can accept an entrypoint as field annotation,
--   and without annotation specified it creates a <tt>contract</tt> value
--   which calls the default entrypoint.
--   
--   This particular function carries the behaviour of <tt>SELF</tt> before
--   introduction of lightweight entrypoints feature. Thus the contract
--   must <b>not</b> have explicit "default" entrypoint for this to work.
--   
--   If you are going to call a specific entrypoint of the contract, see
--   <a>selfCalling</a>.
self :: forall p s. (NiceParameterFull p, ForbidExplicitDefaultEntryPoint p) => s :-> (ContractRef p & s)

-- | Make a reference to the current contract, maybe a specific entrypoint.
--   
--   Note that, since information about parameter of the current contract
--   is not carried around, in this function you need to specify parameter
--   type <tt>p</tt> explicitly.
selfCalling :: forall p mname s. NiceParameterFull p => EntryPointRef mname -> s :-> (ContractRef (GetEntryPointArgCustom p mname) & s)

-- | Get a reference to a contract by its address.
--   
--   This instruction carries the behaviour of <tt>CONTRACT</tt> before
--   introduction of lightweight entrypoints feature. The contract must
--   <b>not</b> have explicit "default" entrypoint for this to work.
--   
--   If you are going to call a specific entrypoint of the contract, see
--   <a>contractCalling</a>.
contract :: forall p addr s. (NiceParameterFull p, ForbidExplicitDefaultEntryPoint p, ToTAddress_ p addr) => (addr & s) :-> (Maybe (ContractRef p) & s)

-- | Make a reference to a contract, maybe a specific entrypoint.
--   
--   When calling this function, make sure that parameter type is known.
--   It's recommended that you supply <a>TAddress</a> with a concrete
--   parameter as the stack argument.
contractCalling :: forall cp epRef epArg addr s. (HasEntryPointArg cp epRef epArg, ToTAddress_ cp addr) => epRef -> (addr & s) :-> (Maybe (ContractRef epArg) & s)

-- | Specialized version of <a>contractCalling</a> for the case when you do
--   not have compile-time evidence of appropriate <a>HasEntryPointArg</a>.
--   For instance, if you have untyped <a>EpName</a> you can not have this
--   evidence (the value is only available in runtime). If you have typed
--   <a>EntryPointRef</a>, use <a>eprName</a> to construct <a>EpName</a>.
contractCallingUnsafe :: forall arg s. NiceParameter arg => EpName -> (Address & s) :-> (Maybe (ContractRef arg) & s)

-- | Version of <a>contract</a> instruction which may accept address with
--   already specified entrypoint name.
--   
--   Also you cannot specify entrypoint name here because this could result
--   in conflict.
runFutureContract :: forall p s. NiceParameter p => (FutureContract p & s) :-> (Maybe (ContractRef p) & s)

-- | Similar to <a>runFutureContract</a>, works with <a>EpAddress</a>.
--   
--   Validity of such operation cannot be ensured at compile time.
epAddressToContract :: forall p s. NiceParameter p => (EpAddress & s) :-> (Maybe (ContractRef p) & s)
transferTokens :: forall p s. NiceParameter p => (p & (Mutez & (ContractRef p & s))) :-> (Operation & s)
setDelegate :: (Maybe KeyHash & s) :-> (Operation & s)
createContract :: forall p g s. (NiceStorage g, NiceParameterFull p) => ContractCode p g -> (Maybe KeyHash & (Mutez & (g & s))) :-> (Operation & (Address & s))
implicitAccount :: (KeyHash & s) :-> (ContractRef () & s)
now :: s :-> (Timestamp & s)
amount :: s :-> (Mutez & s)
balance :: s :-> (Mutez & s)
checkSignature :: (PublicKey & (Signature & (ByteString & s))) :-> (Bool & s)
sha256 :: (ByteString & s) :-> (ByteString & s)
sha512 :: (ByteString & s) :-> (ByteString & s)
blake2B :: (ByteString & s) :-> (ByteString & s)
hashKey :: (PublicKey & s) :-> (KeyHash & s)

-- | <i>Warning: STEPS_TO_QUOTA instruction is deprecated in Michelson
--   005</i>
stepsToQuota :: s :-> (Natural & s)

-- | <i>Warning: Using <a>source</a> is considered a bad practice. Consider
--   using <a>sender</a> instead until further investigation</i>
source :: s :-> (Address & s)
sender :: s :-> (Address & s)
address :: (ContractRef a & s) :-> (Address & s)
chainId :: s :-> (ChainId & s)

-- | Execute given instruction on truncated stack.
--   
--   This instruction requires you to specify the piece of stack to
--   truncate as type argument.
framed :: forall s i o. (KnownList i, KnownList o) => (i :-> o) -> (i ++ s) :-> (o ++ s)
class LorentzFunctor (c :: Type -> Type)
lmap :: (LorentzFunctor c, KnownValue b) => ((a : s) :-> (b : s)) -> (c a : s) :-> (c b : s)

-- | Retain the value only if it is not zero.
nonZero :: NonZero t => (t : s) :-> (Maybe t : s)
instance Lorentz.Instr.NonZero GHC.Integer.Type.Integer
instance Lorentz.Instr.NonZero GHC.Natural.Natural
instance Lorentz.Instr.LorentzFunctor GHC.Maybe.Maybe


-- | Referenced-by-type versions of some instructions.
--   
--   They allow to "dip" into stack or copy elements of stack referring
--   them by type. Their use is justified, because in most cases there is
--   only one element of each type of stack, and in cases when this does
--   not hold (e.g. entrypoint with multiple parameters of the same type),
--   it might be a good idea to wrap those types into a newtype or to use
--   primitives from <tt>named</tt> package.
--   
--   This module is experimental, i.e. everything here should work but may
--   be removed in favor of better development practices.
--   
--   Each instruction is followed with usage example.
module Lorentz.Referenced

-- | Duplicate an element of stack referring it by type.
--   
--   If stack contains multiple entries of this type, compile error is
--   raised.
dupT :: forall a st. DupT st a st => st :-> (a : st)

-- | Dip repeatedly until element of the given type is on top of the stack.
--   
--   If stack contains multiple entries of this type, compile error is
--   raised.
dipT :: forall a inp dinp dout out. DipT inp a inp dinp dout out => (dinp :-> dout) -> inp :-> out

-- | Remove element with the given type from the stack.
dropT :: forall a inp dinp dout out. (DipT inp a inp dinp dout out, dinp ~ (a : dout)) => inp :-> out
instance ((TypeError ...), dipInp Data.Type.Equality.~ (TypeError ...), out Data.Type.Equality.~ (TypeError ...)) => Lorentz.Referenced.DipT origSt a '[] dipInp dipOut out
instance (Data.Type.Bool.If (Util.Type.IsElem a st) (TypeError ...) (() :: Constraint), dipInp Data.Type.Equality.~ (a : st), dipOut Data.Type.Equality.~ out) => Lorentz.Referenced.DipT origSt a (a : st) dipInp dipOut out
instance (Lorentz.Referenced.DipT origSt a st dipInp dipOut out, out1 Data.Type.Equality.~ (b : out)) => Lorentz.Referenced.DipT origSt a (b : st) dipInp dipOut out1
instance (TypeError ...) => Lorentz.Referenced.DupT origSt a '[]
instance Data.Type.Bool.If (Util.Type.IsElem a st) (TypeError ...) (() :: Constraint) => Lorentz.Referenced.DupT origSt a (a : st)
instance Lorentz.Referenced.DupT origSt a st => Lorentz.Referenced.DupT origSt a (b : st)

module Lorentz.Doc

-- | Put a document item.
doc :: DocItem di => di -> s :-> s

-- | Group documentation built in the given piece of code into block
--   dedicated to one thing, e.g. to one entrypoint.
docGroup :: DocGrouping -> (inp :-> out) -> inp :-> out
buildLorentzDoc :: (inp :-> out) -> ContractDoc
renderLorentzDoc :: (inp :-> out) -> LText

-- | Give a name to given contract. Apply it to the whole contract code.
contractName :: Text -> (inp :-> out) -> inp :-> out

-- | Leave only instructions related to documentation.
--   
--   This function is useful when your method executes a lambda coming from
--   outside, but you know its properties and want to propagate its
--   documentation to your contract code.
cutLorentzNonDoc :: (inp :-> out) -> s :-> s

-- | A piece of markdown document.
--   
--   This is opposed to <a>Text</a> type, which in turn is not supposed to
--   contain markup elements.
type Markdown = Builder

-- | A piece of documentation describing one property of a thing, be it a
--   name or description of a contract, or an error throwable by given
--   endpoint.
--   
--   Items of the same type appear close to each other in a rendered
--   documentation and form a <i>section</i>.
--   
--   Doc items are later injected into a contract code via a dedicated
--   nop-like instruction. Normally doc items which belong to one section
--   appear in resulting doc in the same order in which they appeared in
--   the contract.
--   
--   While documentation framework grows, this typeclass acquires more and
--   more methods for fine tuning of existing rendering logic because we
--   don't want to break backward compatibility, hope one day we will make
--   everything concise :( E.g. all rendering and reording stuff could be
--   merged in one method, and we could have several template
--   implementations for it which would allow user to specify only stuff
--   relevant to his case.
class (Typeable d, DOrd d, KnownNat DocItemPosition d) => DocItem d where {
    
    -- | Position of this item in the resulting documentation; the smaller the
    --   value, the higher the section with this element will be placed.
    --   
    --   Documentation structure is not necessarily flat. If some doc item
    --   consolidates a whole documentation block within it, this block will
    --   have its own placement of items independent from outer parts of the
    --   doc.
    type family DocItemPosition d = (pos :: Nat) | pos -> d;
    
    -- | Defines where given doc item should be put. There are two options: 1.
    --   Inline right here (default behaviour); 2. Put into definitions
    --   section.
    --   
    --   Note that we require all doc items with "in definitions" placement to
    --   have <a>Eq</a> and <a>Ord</a> instances which comply the following
    --   law: if two documentation items describe the same entity or property,
    --   they should be considered equal.
    type family DocItemPlacement d :: DocItemPlacementKind;
}

-- | When multiple items of the same type belong to one section, how this
--   section will be called.
--   
--   If not provided, section will contain just untitled content.
docItemSectionName :: DocItem d => Maybe Text

-- | Description of a section.
--   
--   Can be used to mention some common things about all elements of this
--   section. Markdown syntax is permitted here.
docItemSectionDescription :: DocItem d => Maybe Markdown

-- | How to render section name.
--   
--   Takes effect only if section name is set.
docItemSectionNameStyle :: DocItem d => DocSectionNameStyle

-- | Defines a function which constructs an unique identifier of given doc
--   item, if it has been decided to put the doc item into definitions
--   section.
--   
--   Identifier should be unique both among doc items of the same type and
--   items of other types. Thus, consider using "typeId-contentId" pattern.
docItemRef :: DocItem d => d -> DocItemRef (DocItemPlacement d)

-- | Render given doc item to Markdown, preferably one line, optionally
--   with header.
--   
--   Accepts the smallest allowed level of header. (Using smaller value
--   than provided one will interfere with existing headers thus delivering
--   mess).
docItemToMarkdown :: DocItem d => HeaderLevel -> d -> Markdown

-- | All doc items which this doc item refers to.
--   
--   They will automatically be put to definitions as soon as given doc
--   item is detected.
docItemDependencies :: DocItem d => d -> [SomeDocDefinitionItem]

-- | This function accepts doc items put under the same section in the
--   order in which they appeared in the contract and returns their new
--   desired order. It's also fine to use this function for filtering or
--   merging doc items.
--   
--   Default implementation * leaves inlined items as is; * for items put
--   to definitions, lexicographically sorts them by their id.
docItemsOrder :: DocItem d => [d] -> [d]

-- | Get doc item position at term-level.
docItemPosition :: DocItem d => DocItemPos

-- | Some unique identifier of a doc item.
--   
--   All doc items which should be refer-able need to have this identifier.
newtype DocItemId
DocItemId :: Text -> DocItemId

-- | Where do we place given doc item.
data DocItemPlacementKind

-- | Placed in the document content itself.
DocItemInlined :: DocItemPlacementKind

-- | Placed in dedicated definitions section; can later be referenced.
DocItemInDefinitions :: DocItemPlacementKind

-- | Defines an identifier which given doc item can be referenced with.
data DocItemRef (p :: DocItemPlacementKind)
[DocItemRef] :: forall (p :: DocItemPlacementKind). () => DocItemId -> DocItemRef DocItemInDefinitions
[DocItemNoRef] :: forall (p :: DocItemPlacementKind). () => DocItemRef DocItemInlined

-- | How to render section name.
data DocSectionNameStyle

-- | Suitable for block name.
DocSectionNameBig :: DocSectionNameStyle

-- | Suitable for subsection title within block.
DocSectionNameSmall :: DocSectionNameStyle

-- | Hides some documentation item.
data SomeDocItem
[SomeDocItem] :: forall d. DocItem d => d -> SomeDocItem

-- | Hides some documentation item which is put to "definitions" section.
data SomeDocDefinitionItem
[SomeDocDefinitionItem] :: forall d. (DocItem d, DocItemPlacement d ~ DocItemInDefinitions) => d -> SomeDocDefinitionItem

-- | A part of documentation to be grouped. Essentially incapsulates
--   <a>DocBlock</a>.
newtype SubDoc
SubDoc :: DocBlock -> SubDoc

-- | A function which groups a piece of doc under one doc item.
type DocGrouping = SubDoc -> SomeDocItem

-- | Keeps documentation gathered for some piece of contract code.
--   
--   Used for building documentation of a contract.
data ContractDoc
ContractDoc :: DocBlock -> DocBlock -> Set SomeDocDefinitionItem -> Set DocItemId -> ContractDoc

-- | All inlined doc items.
[cdContents] :: ContractDoc -> DocBlock

-- | Definitions used in document.
--   
--   Usually you put some large and repetitive descriptions here. This
--   differs from the document content in that it contains sections which
--   are always at top-level, disregard the nesting.
--   
--   All doc items which define <tt>docItemId</tt> method go here, and only
--   they.
[cdDefinitions] :: ContractDoc -> DocBlock

-- | We remember all already declared entries to avoid cyclic dependencies
--   in documentation items discovery.
[cdDefinitionsSet] :: ContractDoc -> Set SomeDocDefinitionItem

-- | We remember all already used identifiers. (Documentation naturally
--   should not declare multiple items with the same identifier because
--   that would make references to the respective anchors ambiguous).
[cdDefinitionIds] :: ContractDoc -> Set DocItemId

-- | Description of something.
data DDescription
DDescription :: Markdown -> DDescription
data DGitRevision
DGitRevisionKnown :: DGitRevisionInfo -> DGitRevision
DGitRevisionUnknown :: DGitRevision

-- | Repository settings for <a>DGitRevision</a>.
newtype GitRepoSettings
GitRepoSettings :: (Text -> Text) -> GitRepoSettings

-- | By commit sha make up a url to that commit in remote repository.
[grsMkGitRevision] :: GitRepoSettings -> Text -> Text

-- | Make <a>DGitRevision</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :t $mkDGitRevision
--   GitRepoSettings -&gt; DGitRevision
--   </pre>
mkDGitRevision :: ExpQ
morleyRepoSettings :: GitRepoSettings

-- | Comment in the doc (mostly used for licenses)
data DComment
DComment :: Text -> DComment

-- | A hand-made anchor.
data DAnchor
DAnchor :: Anchor -> DAnchor

-- | Doc element with description of a type.
data DType
[DType] :: forall a. TypeHasDoc a => Proxy a -> DType

-- | Make a reference to doc item in definitions.
docDefinitionRef :: (DocItem d, DocItemPlacement d ~ DocItemInDefinitions) => Markdown -> d -> Markdown

-- | Render given contract documentation to markdown document.
contractDocToMarkdown :: ContractDoc -> LText

-- | Render documentation for <a>SubDoc</a>.
subDocToMarkdown :: HeaderLevel -> SubDoc -> Markdown

-- | Description for a Haskell type appearing in documentation.
class Typeable a => TypeHasDoc a

-- | Name of type as it appears in definitions section.
--   
--   Each type must have its own unique name because it will be used in
--   identifier for references.
--   
--   Default definition derives name from Generics. If it does not fit,
--   consider defining this function manually. (We tried using <a>Data</a>
--   for this, but it produces names including module names which is not do
--   we want).
typeDocName :: TypeHasDoc a => Proxy a -> Text

-- | Explanation of a type. Markdown formatting is allowed.
typeDocMdDescription :: TypeHasDoc a => Markdown

-- | How reference to this type is rendered, in Markdown.
--   
--   Examples: * <tt><a>Integer</a></tt>, * <tt><a>Maybe</a>
--   <a>()</a></tt>.
--   
--   Consider using one of the following functions as default
--   implementation; which one to use depends on number of type arguments
--   in your type: * <a>homomorphicTypeDocMdReference</a> *
--   <a>poly1TypeDocMdReference</a> * <a>poly2TypeDocMdReference</a>
--   
--   If none of them fits your purposes precisely, consider using
--   <a>customTypeDocMdReference</a>.
typeDocMdReference :: TypeHasDoc a => Proxy a -> WithinParens -> Markdown

-- | All types which this type directly contains.
--   
--   Used in automatic types discovery.
typeDocDependencies :: TypeHasDoc a => Proxy a -> [SomeTypeWithDoc]

-- | For complex types - their immediate Haskell representation.
--   
--   For primitive types set this to <a>Nothing</a>.
--   
--   For homomorphic types use <a>homomorphicTypeDocHaskellRep</a>
--   implementation.
--   
--   For polymorhpic types consider using <a>concreteTypeDocHaskellRep</a>
--   as implementation.
--   
--   Modifier <a>haskellRepNoFields</a> can be used to hide names of
--   fields, beneficial for newtypes.
--   
--   Another modifier called <a>haskellRepStripFieldPrefix</a> can be used
--   for datatypes to leave only meaningful part of name in every field.
typeDocHaskellRep :: TypeHasDoc a => TypeDocHaskellRep a

-- | Final michelson representation of a type.
--   
--   For homomorphic types use <a>homomorphicTypeDocMichelsonRep</a>
--   implementation.
--   
--   For polymorhpic types consider using
--   <a>concreteTypeDocMichelsonRep</a> as implementation.
typeDocMichelsonRep :: TypeHasDoc a => TypeDocMichelsonRep a

-- | Data hides some type implementing <a>TypeHasDoc</a>.
data SomeTypeWithDoc
[SomeTypeWithDoc] :: forall td. TypeHasDoc td => Proxy td -> SomeTypeWithDoc

-- | Require two types to be built from the same type constructor.
--   
--   E.g. <tt>HaveCommonTypeCtor (Maybe Integer) (Maybe Natural)</tt> is
--   defined, while <tt>HaveCmmonTypeCtor (Maybe Integer) [Integer]</tt> is
--   not.
class HaveCommonTypeCtor (a :: k) (b :: k1)

-- | Require this type to be homomorphic.
class IsHomomorphic (a :: k)

-- | Implement <a>typeDocDependencies</a> via getting all immediate fields
--   of a datatype.
--   
--   Note: this will not include phantom types, I'm not sure yet how this
--   scenario should be handled (@martoon).
genericTypeDocDependencies :: (Generic a, GTypeHasDoc (Rep a)) => Proxy a -> [SomeTypeWithDoc]

-- | Render a reference to a type which consists of type constructor (you
--   have to provide name of this type constructor and documentation for
--   the whole type) and zero or more type arguments.
customTypeDocMdReference :: (Text, DType) -> [DType] -> WithinParens -> Markdown

-- | Derive <a>typeDocMdReference</a>, for homomorphic types only.
homomorphicTypeDocMdReference :: (Typeable t, TypeHasDoc t, IsHomomorphic t) => Proxy t -> WithinParens -> Markdown

-- | Derive <a>typeDocMdReference</a>, for polymorphic type with one type
--   argument, like <tt>Maybe Integer</tt>.
poly1TypeDocMdReference :: (r ~ t a, Typeable t, Each (TypeHasDoc : ([] :: [Type -> Constraint])) (r : (a : ([] :: [Type]))), IsHomomorphic t) => Proxy r -> WithinParens -> Markdown

-- | Derive <a>typeDocMdReference</a>, for polymorphic type with two type
--   arguments, like <tt>Lambda Integer Natural</tt>.
poly2TypeDocMdReference :: (r ~ t a b, Typeable t, Each (TypeHasDoc : ([] :: [Type -> Constraint])) (r : (a : (b : ([] :: [Type])))), IsHomomorphic t) => Proxy r -> WithinParens -> Markdown

-- | Implement <a>typeDocHaskellRep</a> for a homomorphic type.
--   
--   Note that it does not require your type to be of <a>IsHomomorphic</a>
--   instance, which can be useful for some polymorhpic types which, for
--   documentation purposes, we want to consider homomorphic. Example:
--   <a>Operation</a> is in fact polymorhpic, but we don't want this fact
--   to be reflected in the documentation.
homomorphicTypeDocHaskellRep :: (Generic a, GTypeHasDoc (Rep a)) => TypeDocHaskellRep a

-- | Implement <a>typeDocHaskellRep</a> on example of given concrete type.
--   
--   This is a best effort attempt to implement <a>typeDocHaskellRep</a>
--   for polymorhpic types, as soon as there is no simple way to preserve
--   type variables when automatically deriving Haskell representation of a
--   type.
concreteTypeDocHaskellRep :: (Typeable a, GenericIsoValue a, GTypeHasDoc (Rep a), HaveCommonTypeCtor b a) => TypeDocHaskellRep b

-- | Version of <a>concreteTypeDocHaskellRep</a> which does not ensure
--   whether the type for which representation is built is any similar to
--   the original type which you implement a <a>TypeHasDoc</a> instance
--   for.
concreteTypeDocHaskellRepUnsafe :: (Typeable a, GenericIsoValue a, GTypeHasDoc (Rep a)) => TypeDocHaskellRep b

-- | Erase fields from Haskell datatype representation.
--   
--   Use this when rendering fields names is undesired.
haskellRepNoFields :: () => TypeDocHaskellRep a -> TypeDocHaskellRep a

-- | Cut fields prefixes which we use according to the style guide.
--   
--   E.g. <tt>cmMyField</tt> field will be transformed to <tt>myField</tt>.
haskellRepStripFieldPrefix :: HasCallStack => TypeDocHaskellRep a -> TypeDocHaskellRep a

-- | Implement <a>typeDocMichelsonRep</a> for homomorphic type.
homomorphicTypeDocMichelsonRep :: SingI (ToT a) => TypeDocMichelsonRep a

-- | Implement <a>typeDocMichelsonRep</a> on example of given concrete
--   type.
--   
--   This function exists for the same reason as
--   <a>concreteTypeDocHaskellRep</a>.
concreteTypeDocMichelsonRep :: (Typeable a, SingI (ToT a), HaveCommonTypeCtor b a) => TypeDocMichelsonRep b

-- | Version of <a>concreteTypeDocHaskellRepUnsafe</a> which does not
--   ensure whether the type for which representation is built is any
--   similar to the original type which you implement a <a>TypeHasDoc</a>
--   instance for.
concreteTypeDocMichelsonRepUnsafe :: (Typeable a, SingI (ToT a)) => TypeDocMichelsonRep b
instance Universum.TypeOps.Each '[Data.Typeable.Internal.Typeable, Util.Type.ReifyList Michelson.Typed.Haskell.Doc.TypeHasDoc] '[i, o] => Michelson.Typed.Haskell.Doc.TypeHasDoc (i Lorentz.Base.:-> o)


-- | <a>UStore</a> definition and common type-level stuff.
module Lorentz.UStore.Types

-- | Gathers multple fields and <a>BigMap</a>s under one object.
--   
--   Type argument of this datatype stands for a "store template" - a
--   datatype with one constructor and multiple fields, each containing an
--   object of type <a>UStoreFieldExt</a> or <a>|~&gt;</a> and
--   corresponding to single virtual field or <a>BigMap</a> respectively.
--   It's also possible to parameterize it with a larger type which is a
--   product of types satisfying the above property.
newtype UStore (a :: Type)
UStore :: BigMap ByteString ByteString -> UStore
[unUStore] :: UStore -> BigMap ByteString ByteString

-- | Describes one virtual big map in the storage.
newtype k |~> v
UStoreSubMap :: Map k v -> (|~>) k v
[unUStoreSubMap] :: (|~>) k v -> Map k v

-- | Describes plain field in the storage.
newtype UStoreFieldExt (m :: UStoreMarkerType) (v :: Type)
UStoreField :: v -> UStoreFieldExt
[unUStoreField] :: UStoreFieldExt -> v

-- | Just a plain field used as data.
type UStoreField = UStoreFieldExt UMarkerPlainField

-- | Specific kind used to designate markers for <a>UStoreFieldExt</a>.
--   
--   We suggest that fields may serve different purposes and so annotated
--   with special markers accordingly. See example below.
--   
--   This kind is implemented like that because we want markers to differ
--   from all other types in kind; herewith <a>UStoreMarkerType</a> is
--   still an open kind (has potentially infinite number of inhabitants).
type UStoreMarkerType = UStoreMarker -> Type
data UMarkerPlainField :: UStoreMarkerType

-- | Allows to specify format of key under which fields of this type are
--   stored. Useful to avoid collisions.
class KnownUStoreMarker (marker :: UStoreMarkerType) where {
    
    -- | Display type-level information about UStore field with given marker
    --   and field value type. Used for error messages.
    type family ShowUStoreField marker v :: ErrorMessage;
    type ShowUStoreField marker v =  'Text "field of type " :<>:  'ShowType v;
}

-- | By field name derive key under which field should be stored.
mkFieldMarkerUKey :: KnownUStoreMarker marker => MText -> ByteString

-- | By field name derive key under which field should be stored.
mkFieldMarkerUKey :: KnownUStoreMarker marker => MText -> ByteString

-- | Version of <a>mkFieldMarkerUKey</a> which accepts label.
mkFieldMarkerUKeyL :: forall marker field. KnownUStoreMarker marker => Label field -> ByteString

-- | Shortcut for <a>mkFieldMarkerUKey</a> which accepts not marker but
--   store template and name of entry.
mkFieldUKey :: forall (store :: Type) field. KnownUStoreMarker (GetUStoreFieldMarker store field) => Label field -> ByteString

-- | What do we serialize when constructing big_map key for accessing an
--   UStore submap.
type UStoreSubmapKey k = (MText, k)
type UStoreSubmapKeyT k =  'TPair (ToT MText) k

-- | Get type of submap key.
type GetUStoreKey store name = MSKey (GetUStore name store)

-- | Get type of submap value.
type GetUStoreValue store name = MSValue (GetUStore name store)

-- | Get type of plain field. This ignores marker with field type.
type GetUStoreField store name = FSValue (GetUStore name store)

-- | Get kind of field.
type GetUStoreFieldMarker store name = FSMarker (GetUStore name store)

-- | Collect all fields with the given marker.
type PickMarkedFields marker template = GPickMarkedFields marker (Rep template)

-- | What was found on lookup by constructor name.
--   
--   This keeps either type arguments of <a>|~&gt;</a> or
--   <a>UStoreFieldExt</a>.
data ElemSignature
MapSignature :: Type -> Type -> ElemSignature
FieldSignature :: UStoreMarkerType -> Type -> ElemSignature

-- | Get map signature from the constructor with a given name.
type GetUStore name a = MERequireFound name a (GLookupStore name (Rep a))
type family MSKey (ms :: ElemSignature) :: Type
type family MSValue (ms :: ElemSignature) :: Type
type family FSValue (ms :: ElemSignature) :: Type
type family FSMarker (ms :: ElemSignature) :: UStoreMarkerType
instance Test.QuickCheck.Arbitrary.Arbitrary v => Test.QuickCheck.Arbitrary.Arbitrary (Lorentz.UStore.Types.UStoreFieldExt m v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Lorentz.UStore.Types.UStoreFieldExt m v)
instance GHC.Show.Show v => GHC.Show.Show (Lorentz.UStore.Types.UStoreFieldExt m v)
instance (GHC.Classes.Ord k, Test.QuickCheck.Arbitrary.Arbitrary k, Test.QuickCheck.Arbitrary.Arbitrary v) => Test.QuickCheck.Arbitrary.Arbitrary (k Lorentz.UStore.Types.|~> v)
instance Data.Default.Class.Default (k Lorentz.UStore.Types.|~> v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (k Lorentz.UStore.Types.|~> v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (k Lorentz.UStore.Types.|~> v)
instance Lorentz.TypeAnns.HasTypeAnn (Lorentz.UStore.Types.UStore a)
instance Lorentz.Polymorphic.UpdOpHs (Lorentz.UStore.Types.UStore a)
instance Lorentz.Polymorphic.GetOpHs (Lorentz.UStore.Types.UStore a)
instance Lorentz.Polymorphic.MemOpHs (Lorentz.UStore.Types.UStore a)
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.UStore.Types.UStore a)
instance GHC.Base.Monoid (Lorentz.UStore.Types.UStore a)
instance GHC.Base.Semigroup (Lorentz.UStore.Types.UStore a)
instance Data.Default.Class.Default (Lorentz.UStore.Types.UStore a)
instance GHC.Generics.Generic (Lorentz.UStore.Types.UStore a)
instance GHC.Show.Show (Lorentz.UStore.Types.UStore a)
instance GHC.Classes.Eq (Lorentz.UStore.Types.UStore a)
instance Lorentz.UStore.Types.KnownUStoreMarker Lorentz.UStore.Types.UMarkerPlainField
instance Control.Lens.Wrapped.Wrapped (Lorentz.UStore.Types.UStore a)
instance Data.Typeable.Internal.Typeable template => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.UStore.Types.UStore template)

module Lorentz.UStore.Migration.Diff

-- | Information about single field of UStore.
type FieldInfo = (Symbol, Type)

-- | What should happen with a particular <tt>UStoreItem</tt>.
data DiffKind
ToAdd :: DiffKind
ToDel :: DiffKind

-- | Single piece of a diff.
type DiffItem = (DiffKind, FieldInfo)

-- | Make up a migration diff between given old and new <a>UStore</a>
--   templates.
type BuildDiff oldTemplate newTemplate = LiftToDiff  'ToAdd (LinearizeUStore newTemplate // LinearizeUStore oldTemplate) ++ LiftToDiff  'ToDel (LinearizeUStore oldTemplate // LinearizeUStore newTemplate)

-- | Renders human-readable message describing given diff.
type ShowDiff diff =  'Text "Migration is incomplete, remaining diff:" :$$: ShowDiffItems diff

-- | Helper type family which dumps error message about remaining diff if
--   such is present.
type family RequireEmptyDiff (diff :: [DiffItem]) :: Constraint

-- | Get information about all fields of UStore template in a list.
--   
--   In particular, this recursivelly traverses template and retrives names
--   and types of fields. Semantic wrappers like <a>UStoreFieldExt</a> and
--   <a>|~&gt;</a> in field types are returned as-is.
type LinearizeUStore a = GLinearizeUStore (Rep a)
data LinearizeUStoreF (template :: Type) :: Exp [FieldInfo]

-- | Get only field names of UStore template.
type family AllUStoreFieldsF (template :: Type) :: Exp [Symbol]

-- | Cover the respective part of diff. Maybe fail if such action is not
--   required.
--   
--   This type is very similar to <a>DiffKind</a>, but we still use another
--   type as 1. Their kinds will differ - no chance to mix up anything. 2.
--   One day there might appear more complex actions.
data DiffCoverage
DcAdd :: DiffCoverage
DcRemove :: DiffCoverage

-- | Apply given diff coverage, returning type of affected field and
--   modified diff.
type family CoverDiff (cover :: DiffCoverage) (field :: Symbol) (diff :: [DiffItem]) :: (Type, [DiffItem])

-- | Apply multiple coverage steps.
type family CoverDiffMany (diff :: [DiffItem]) (covers :: [DiffCoverageItem]) :: [DiffItem]

module Lorentz.Errors

-- | Haskell type representing error.
class (Typeable e, ErrorHasDoc e) => IsError e

-- | Converts a Haskell error into <tt>Value</tt> representation.
errorToVal :: IsError e => e -> (forall t. ErrorScope t => Value t -> r) -> r

-- | Converts a <tt>Value</tt> into Haskell error.
errorFromVal :: (IsError e, Typeable t, SingI t) => Value t -> Either Text e

-- | Implementation of <a>errorToVal</a> via <a>IsoValue</a>.
isoErrorToVal :: (KnownError e, IsoValue e) => e -> (forall t. ErrorScope t => Value t -> r) -> r

-- | Implementation of <a>errorFromVal</a> via <a>IsoValue</a>.
isoErrorFromVal :: (Typeable t, Typeable (ToT e), IsoValue e) => Value t -> Either Text e
class Typeable e => ErrorHasDoc (e :: Type) where {
    
    -- | Constraints which we require in a particular instance. You are not
    --   oblidged to often instantiate this correctly, it is only useful for
    --   some utilities.
    type family ErrorRequirements e :: Constraint;
    type ErrorRequirements e = ();
}

-- | Name of error as it appears in the corresponding section title.
errorDocName :: ErrorHasDoc e => Text

-- | What should happen for this error to be raised.
errorDocMdCause :: ErrorHasDoc e => Markdown

-- | Brief version of <a>errorDocMdCause</a>.
--   
--   This will appear along with the error when mentioned in entrypoint
--   description. By default, the first sentence of the full description is
--   used.
errorDocMdCauseInEntrypoint :: ErrorHasDoc e => Markdown

-- | How this error is represented in Haskell.
errorDocHaskellRep :: ErrorHasDoc e => Markdown

-- | Error class.
errorDocClass :: ErrorHasDoc e => ErrorClass

-- | Which definitions documentation for this error mentions.
errorDocDependencies :: ErrorHasDoc e => [SomeDocDefinitionItem]

-- | Captured constraints which we require in a particular instance. This
--   is a way to encode a bidirectional instance in the nowaday Haskell,
--   for <tt>class MyConstraint =&gt; ErrorHasDoc MyType</tt> instance it
--   lets deducing <tt>MyConstraint</tt> by <tt>ErrorHasDoc MyType</tt>.
--   
--   You are not oblidged to always instantiate, it is only useful for some
--   utilities which otherwise would not compile.
errorDocRequirements :: ErrorHasDoc e => Dict (ErrorRequirements e)

-- | Captured constraints which we require in a particular instance. This
--   is a way to encode a bidirectional instance in the nowaday Haskell,
--   for <tt>class MyConstraint =&gt; ErrorHasDoc MyType</tt> instance it
--   lets deducing <tt>MyConstraint</tt> by <tt>ErrorHasDoc MyType</tt>.
--   
--   You are not oblidged to always instantiate, it is only useful for some
--   utilities which otherwise would not compile.
errorDocRequirements :: (ErrorHasDoc e, ErrorRequirements e) => Dict (ErrorRequirements e)

-- | Implementation of <a>typeDocMdDescription</a> (of <a>TypeHasDoc</a>
--   typeclass) for Haskell types which sole purpose is to be error.
typeDocMdDescriptionReferToError :: forall e. IsError e => Markdown

-- | Description of error representation in Haskell.
customErrorDocHaskellRepGeneral :: (SingI (ToT (ErrorArg tag)), IsError (CustomError tag), TypeHasDoc (ErrorArg tag), CustomErrorHasDoc tag) => Text -> Proxy tag -> Markdown

-- | Use this type as replacement for <tt>()</tt> when you <b>really</b>
--   want to leave error cause unspecified.
data UnspecifiedError
UnspecifiedError :: UnspecifiedError

-- | Fail with the given Haskell value.
failUsing :: forall e s t. IsError e => e -> s :-> t

-- | Fail, providing a reference to the place in the code where this
--   function is called.
--   
--   Like <a>error</a> in Haskell code, this instruction is for internal
--   errors only.
failUnexpected :: MText -> s :-> t

-- | Declares a custom error, defining <tt>error name - error argument</tt>
--   relation.
--   
--   If your error is supposed to carry no argument, then provide
--   <tt>()</tt>.
--   
--   Note that this relation is defined globally rather than on
--   per-contract basis, so define errors accordingly. If your error has
--   argument specific to your contract, call it such that error name
--   reflects its belonging to this contract.
--   
--   This is the basic [error format].
type family ErrorArg (tag :: Symbol) :: Type

-- | Material custom error.
--   
--   Use this in pattern matches against error (e.g. in tests).
data CustomError (tag :: Symbol)
CustomError :: Label tag -> ErrorArg tag -> CustomError
[ceTag] :: CustomError -> Label tag
[ceArg] :: CustomError -> ErrorArg tag

-- | Fail with given custom error.
failCustom :: forall tag err s any. (err ~ ErrorArg tag, CustomErrorHasDoc tag, KnownError err) => Label tag -> (err : s) :-> any
type RequireNoArgError tag msg = (TypeErrorUnless (ErrorArg tag == ()) msg, msg ~ ( 'Text "Expected no-arg error, but given error requires argument of type " :<>:  'ShowType (ErrorArg tag)))

-- | Specialization of <a>failCustom</a> for no-arg errors.
failCustom_ :: forall tag s any notVoidErrorMsg. (RequireNoArgError tag notVoidErrorMsg, CustomErrorHasDoc tag) => Label tag -> s :-> any

-- | Error class on how the error should be handled by the client.
data ErrorClass

-- | Normal expected error. Examples: "insufficient balance", "wallet does
--   not exist".
ErrClassActionException :: ErrorClass

-- | Invalid argument passed to entrypoint. Examples: your entrypoint
--   accepts an enum represented as <tt>nat</tt>, and unknown value is
--   provided. This includes more complex cases which involve multiple
--   entrypoints. E.g. API provides iterator interface, middleware should
--   care about using it hiding complex details and exposing a simpler API
--   to user; then an attempt to request non-existing element would also
--   correspond to an error from this class.
ErrClassBadArgument :: ErrorClass

-- | Unexpected error. Most likely it means that there is a bug in the
--   contract or the contract has been deployed incorrectly.
ErrClassContractInternal :: ErrorClass

-- | It's possible to leave error class unspecified.
ErrClassUnknown :: ErrorClass
class (KnownSymbol tag, TypeHasDoc (ErrorArg tag), IsError (CustomError tag)) => CustomErrorHasDoc tag

-- | What should happen for this error to be raised.
customErrDocMdCause :: CustomErrorHasDoc tag => Markdown

-- | Brief version of <a>customErrDocMdCause</a>. This will appear along
--   with the error when mentioned in entrypoint description.
--   
--   By default, the first sentence of the full description is used.
customErrDocMdCauseInEntrypoint :: CustomErrorHasDoc tag => Markdown

-- | Error class.
--   
--   By default this returns "unknown error" class; though you should
--   provide explicit implementation in order to avoid a warning.
customErrClass :: CustomErrorHasDoc tag => ErrorClass

-- | Clarification of error argument meaning.
--   
--   Provide when it's not obvious, e.g. argument is not named with
--   <tt>:!</tt>.
--   
--   NOTE: This should <i>not</i> be an entire sentence, rather just the
--   semantic backbone.
--   
--   Bad: * <tt>Error argument stands for the previous value of
--   approval.</tt>
--   
--   Good: * <tt>the previous value of approval</tt> * <tt>pair, first
--   argument of which is one thing, and the second is another</tt>
customErrArgumentSemantics :: CustomErrorHasDoc tag => Maybe Markdown

-- | Mentions that contract uses given error.
data DError
[DError] :: ErrorHasDoc e => Proxy e -> DError

-- | Documentation for custom errors.
--   
--   Mentions that entrypoint throws given error.
data DThrows
[DThrows] :: ErrorHasDoc e => Proxy e -> DThrows

-- | Implementation of <a>errorToVal</a> for custom errors.

-- | <i>Deprecated: Datatype error declarations has been deprecated</i>
customErrorToVal :: (LooseSumC e, HasCallStack) => e -> (forall t. ErrorScope t => Value t -> r) -> r

-- | Implementation of <a>errorFromVal</a> for custom errors.
--   
--   This function is deprecated.

-- | <i>Deprecated: Datatype error declarations has been deprecated</i>
customErrorFromVal :: forall t e. (SingI t, LooseSumC e) => Value t -> Either Text e

-- | Fail with given error, picking argument for error from the top of the
--   stack.
--   
--   If your error constructor does not carry an argument, use
--   <a>failUsing</a> function instead. Consider the following practice:
--   once error datatype for your contract is defined, create a
--   specialization of this function to the error type.
--   
--   This function is deprecated.

-- | <i>Deprecated: Datatype error declarations has been deprecated</i>
failUsingArg :: forall err name fieldTy s s'. FailUsingArg err name fieldTy s s'

-- | Signature of <tt>userFailWith</tt>.
type FailUsingArg e name fieldTy s s' = (KnownSymbol name, IsError e, IsoValue fieldTy, CtorHasOnlyField name e fieldTy, Each [Typeable, SingI] '[ToT fieldTy], HasCallStack) => Label name -> fieldTy : s :-> s'

-- | Prompt an error message saying that <a>IsoValue</a> is not applicable
--   for this type.
type family CustomErrorNoIsoValue a

-- | Derive <a>IsError</a> instance for given type.
--   
--   This will also forbid deriving <a>IsoValue</a> instance for that type
--   to avoid having multiple different Michelson representations.

-- | <i>Deprecated: Datatype error declarations has been deprecated</i>
deriveCustomError :: Name -> Q [Dec]
errorTagToText :: forall tag. KnownSymbol tag => Text

-- | Demote error tag to term level.
errorTagToMText :: Label tag -> MText
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Errors.UnspecifiedError
instance GHC.Generics.Generic Lorentz.Errors.UnspecifiedError
instance GHC.Classes.Eq (Lorentz.Errors.ErrorArg tag) => GHC.Classes.Eq (Lorentz.Errors.CustomError tag)
instance GHC.Show.Show (Lorentz.Errors.ErrorArg tag) => GHC.Show.Show (Lorentz.Errors.CustomError tag)
instance GHC.Classes.Eq Lorentz.Errors.DThrows
instance Michelson.Doc.DocItem Lorentz.Errors.DThrows
instance GHC.Classes.Eq Lorentz.Errors.DError
instance GHC.Classes.Ord Lorentz.Errors.DError
instance Michelson.Doc.DocItem Lorentz.Errors.DError
instance (Lorentz.Errors.CustomErrorHasDoc tag, Lorentz.Errors.KnownError (Lorentz.Errors.ErrorArg tag), Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Errors.ErrorArg tag)) => Lorentz.Errors.IsError (Lorentz.Errors.CustomError tag)
instance (Lorentz.Errors.CustomErrorHasDoc tag, Data.Singletons.Internal.SingI (Michelson.Typed.Haskell.Value.ToT (Lorentz.Errors.ErrorArg tag))) => Lorentz.Errors.ErrorHasDoc (Lorentz.Errors.CustomError tag)
instance Lorentz.Errors.IsError Michelson.Text.MText
instance (TypeError ...) => Lorentz.Errors.IsError ()
instance Lorentz.Errors.IsError Lorentz.Errors.UnspecifiedError
instance (Data.Typeable.Internal.Typeable arg, Lorentz.Errors.IsError (Lorentz.Errors.CustomError tag), Util.TypeLits.TypeErrorUnless (arg Data.Type.Equality.== ()) notVoidError, arg Data.Type.Equality.~ Lorentz.Errors.ErrorArg tag, notVoidError Data.Type.Equality.~ ('GHC.TypeLits.Text "This error requires argument of type " 'GHC.TypeLits.:<>: 'GHC.TypeLits.ShowType (Lorentz.Errors.ErrorArg tag))) => Lorentz.Errors.IsError (arg -> Lorentz.Errors.CustomError tag)
instance Lorentz.Errors.ErrorHasDoc Michelson.Text.MText
instance (TypeError ...) => Lorentz.Errors.ErrorHasDoc ()
instance Lorentz.Errors.ErrorHasDoc Lorentz.Errors.UnspecifiedError
instance (Data.Typeable.Internal.Typeable arg, Lorentz.Errors.ErrorHasDoc (Lorentz.Errors.CustomError tag)) => Lorentz.Errors.ErrorHasDoc (arg -> Lorentz.Errors.CustomError tag)
instance Formatting.Buildable.Buildable Lorentz.Errors.ErrorClass
instance (TypeError ...) => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Errors.CustomError tag)
instance GHC.Classes.Eq (Lorentz.Errors.ErrorArg tag) => GHC.Classes.Eq (() -> Lorentz.Errors.CustomError tag)
instance GHC.Show.Show (Lorentz.Errors.ErrorArg tag) => GHC.Show.Show (() -> Lorentz.Errors.CustomError tag)


-- | By default we represent error tags using strings. This module makes it
--   possible to use numbers instead. It introduces new [error format].
--   
--   There are two possible ways to use it: 1. If you have just one Lorentz
--   instruction (potentially a big one), just use <a>useNumericErrors</a>
--   function. It will change error representation there and return a map
--   that can be used to interpret new error codes. 2. If your contract
--   consists of multiple parts, start with gathering all error tags
--   (<a>gatherErrorTags</a>). Then build <a>ErrorTagMap</a> using
--   <a>addNewErrorTags</a>. Pass empty map if you are building from
--   scratch (you can use <a>buildErrorTagMap</a> shortcut) or an existing
--   map if you have one (e. g. you are upgrading a contract).
module Lorentz.Errors.Numeric.Contract

-- | This is a bidirectional map with correspondence between numeric and
--   textual error tags.
type ErrorTagMap = Bimap Natural MText

-- | Tags excluded from map.
type ErrorTagExclusions = HashSet MText

-- | Find all textual error tags that are used in typical <tt>FAILWITH</tt>
--   patterns within given instruction. Map them to natural numbers.
gatherErrorTags :: (inp :-> out) -> HashSet MText

-- | Add more error tags to an existing <a>ErrorTagMap</a>. It is useful
--   when your contract consists of multiple parts (e. g. in case of
--   contract upgrade), you have existing map for some part and want to add
--   tags from another part to it. You can pass empty map as existing one
--   if you just want to build <a>ErrorTagMap</a> from a set of textual
--   tags. See <a>buildErrorTagMap</a>.
addNewErrorTags :: ErrorTagMap -> HashSet MText -> ErrorTagMap

-- | Build <a>ErrorTagMap</a> from a set of textual tags.
buildErrorTagMap :: HashSet MText -> ErrorTagMap

-- | Remove some error tags from map. This way you say to remain these
--   string tags intact, while others will be converted to numbers when
--   this map is applied.
--   
--   Note that later you have to apply this map using
--   <a>applyErrorTagMapWithExclusions</a>, otherwise an error would be
--   raised.
excludeErrorTags :: HasCallStack => ErrorTagExclusions -> ErrorTagMap -> ErrorTagMap

-- | For each typical <a>FAILWITH</a> that uses a string to represent error
--   tag this function changes error tag to be a number using the supplied
--   conversion map. It assumes that supplied map contains all such strings
--   (and will error out if it does not). It will always be the case if you
--   gather all error tags using <a>gatherErrorTags</a> and build
--   <a>ErrorTagMap</a> from them using <a>addNewErrorTags</a>.
applyErrorTagMap :: HasCallStack => ErrorTagMap -> (inp :-> out) -> inp :-> out

-- | Similar to <a>applyErrorTagMap</a>, but for case when you have
--   excluded some tags from map via <a>excludeErrorTags</a>. Needed,
--   because both <a>excludeErrorTags</a> and this function do not tolerate
--   unknown errors in contract code (for your safety).
applyErrorTagMapWithExclusions :: HasCallStack => ErrorTagMap -> ErrorTagExclusions -> (inp :-> out) -> inp :-> out

-- | This function implements the simplest scenario of using this module's
--   functionality: 1. Gather all error tags from a single instruction. 2.
--   Turn them into error conversion map. 3. Apply this conversion.
useNumericErrors :: HasCallStack => (inp :-> out) -> (inp :-> out, ErrorTagMap)

-- | If you apply numeric error representation in your contract,
--   <a>errorFromVal</a> will stop working because it doesn't know about
--   this transformation. This function takes this transformation into
--   account. If a number is used as a tag, but it is not found in the
--   passed map, we conservatively preserve that number (because this whole
--   approach is rather a heuristic).
errorFromValNumeric :: (Typeable t, SingI t, IsError e) => ErrorTagMap -> Value t -> Either Text e


-- | Some common errors.
--   
--   Such registry makes sense, as soon as errors are declared globally.
module Lorentz.Errors.Common
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "senderIsNotAdmin")
instance Lorentz.Errors.CustomErrorHasDoc "senderIsNotAdmin"


-- | Support for uninhabited type.
--   
--   Currently they are not supported my Michelson, so we provide a sort of
--   replacement.
--   
--   This module should be removed once the proposal is implemented:
--   <a>https://gitlab.com/tezos/tezos/issues/662</a>
module Lorentz.Empty

-- | Replacement for uninhabited type.
data Empty

-- | Witness of that this code is unreachable.
absurd_ :: (Empty : s) :-> s'
instance Lorentz.TypeAnns.HasTypeAnn Lorentz.Empty.Empty
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Empty.Empty
instance GHC.Generics.Generic Lorentz.Empty.Empty
instance Michelson.Typed.Haskell.Doc.TypeHasDoc Lorentz.Empty.Empty
instance Lorentz.Errors.CustomErrorHasDoc "emptySupplied"
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "emptySupplied")


-- | This module contains various datatypes and functions which are common
--   for contract registry packages (e.g. morley-ledgers and
--   morley-multisig).
module Lorentz.ContractRegistry
data ContractInfo
ContractInfo :: ContractCode cp st -> Bool -> ContractInfo
[ciContract] :: ContractInfo -> ContractCode cp st
[ciIsDocumented] :: ContractInfo -> Bool
newtype ContractRegistry
ContractRegistry :: Map Text ContractInfo -> ContractRegistry
[unContractRegistry] :: ContractRegistry -> Map Text ContractInfo
getContract :: Text -> ContractRegistry -> Either String ContractInfo
printContractFromRegistryDoc :: Text -> ContractRegistry -> Maybe FilePath -> IO ()
(?::) :: Text -> a -> (Text, a)
data CmdLnArgs
List :: CmdLnArgs
Print :: Text -> Maybe FilePath -> Bool -> CmdLnArgs
Document :: Text -> Maybe FilePath -> CmdLnArgs
argParser :: Parser CmdLnArgs
instance Formatting.Buildable.Buildable Lorentz.ContractRegistry.ContractRegistry


-- | Identity transformations between different Haskell types.
module Lorentz.Coercions

-- | Explicitly allowed coercions.
--   
--   <tt>a <a>CanCastTo</a> b</tt> proclaims that <tt>a</tt> can be casted
--   to <tt>b</tt> without violating any invariants of <tt>b</tt>.
--   
--   This relation is reflexive; it <i>may</i> be symmetric or not. It
--   tends to be composable: casting complex types usually requires
--   permission to cast their respective parts; for such types consider
--   using <a>castDummyG</a> as implementation of the method of this
--   typeclass.
--   
--   For cases when a cast from <tt>a</tt> to <tt>b</tt> requires some
--   validation, consider rather making a dedicated function which performs
--   the necessary checks and then calls <tt>forcedCoerce</tt>.
class a `CanCastTo` b

-- | An optional method which helps passing -Wredundant-constraints check.
--   Also, you can set specific implementation for it with specific sanity
--   checks.
castDummy :: CanCastTo a b => Proxy a -> Proxy b -> ()

-- | Implementation of <a>castDummy</a> for types composed from smaller
--   types. It helps to ensure that all necessary constraints are requested
--   in instance head.
castDummyG :: (Generic a, Generic b, GCanCastTo (Rep a) (Rep b)) => Proxy a -> Proxy b -> ()

-- | Coercion in Haskell world which respects <a>CanCastTo</a>.
checkedCoerce :: forall a b. (CanCastTo a b, Coercible a b) => a -> b

-- | Coercions between <tt>a</tt> to <tt>b</tt> are permitted and safe.
type Coercible_ a b = (MichelsonCoercible a b, CanCastTo a b, CanCastTo b a)

-- | Coerce between types which have an explicit permission for that in the
--   face of <a>CanCastTo</a> constraint.
checkedCoerce_ :: forall a b s. Castable_ a b => (a : s) :-> (b : s)

-- | Pretends that the top item of the stack was coerced.
checkedCoercing_ :: forall a b s. Coercible_ a b => ((b : s) :-> (b : s)) -> (a : s) :-> (a : s)

-- | Locally provide given <a>CanCastTo</a> instance.
allowCheckedCoerceTo :: forall b a. Dict (CanCastTo a b)

-- | Locally provide bidirectional <a>CanCastTo</a> instance.
allowCheckedCoerce :: forall a b. Dict (CanCastTo a b, CanCastTo b a)

-- | Specialized version of <tt>coerce_</tt> to unwrap a haskell newtype.
coerceUnwrap :: forall newtyp inner s. (inner ~ Unwrapped newtyp, MichelsonCoercible newtyp (Unwrapped newtyp)) => (newtyp : s) :-> (inner : s)

-- | Specialized version of <tt>coerce_</tt> to wrap into a haskell
--   newtype.
coerceWrap :: forall newtyp inner s. (inner ~ Unwrapped newtyp, MichelsonCoercible newtyp (Unwrapped newtyp)) => (inner : s) :-> (newtyp : s)

-- | Lift given value to a named value.
toNamed :: Label name -> (a : s) :-> (NamedF Identity a name : s)

-- | Unpack named value.
fromNamed :: Label name -> (NamedF Identity a name : s) :-> (a : s)

-- | Whether two types have the same Michelson representation.
type MichelsonCoercible a b = ToT a ~ ToT b

-- | Coercion for Haskell world.
--   
--   We discourage using this function on Lorentz types, consider using
--   <tt>coerce</tt> instead. One of the reasons forthat is that in Lorentz
--   it's common to declare types as newtypes consisting of existing
--   primitives, and <tt>forcedCoerce</tt> tends to ignore all phantom type
--   variables of newtypes thus violating their invariants.
forcedCoerce :: Coercible a b => a -> b

-- | Convert between values of types that have the same representation.
--   
--   This function is not safe in a sense that this allows breaking
--   invariants of casted type (example: <tt>UStore</tt>) or may stop
--   compile on code changes (example: coercion of pair to a datatype with
--   two fields will break if new field is added). Still, produced
--   Michelson code will always be valid.
--   
--   Prefer using one of more specific functions from this module.
forcedCoerce_ :: MichelsonCoercible a b => (a & s) :-> (b & s)
gForcedCoerce_ :: MichelsonCoercible (t a) (t b) => (t a : s) :-> (t b : s)

-- | Convert between two stacks via failing.
fakeCoerce :: s1 :-> s2
fakeCoercing :: (s1 :-> s2) -> s1' :-> s2'

-- | <a>Wrapped</a> provides isomorphisms to wrap and unwrap newtypes or
--   data types with one constructor.
class Wrapped s where {
    type family Unwrapped s :: Type;
}

-- | An isomorphism between <tt>s</tt> and <tt>a</tt>.
--   
--   If your type has a <a>Generic</a> instance, <a>_Wrapped'</a> will
--   default to <a>_GWrapped'</a>, and you can choose to not override it
--   with your own definition.
_Wrapped' :: Wrapped s => Iso' s (Unwrapped s)
instance forall k (a :: k). Lorentz.Coercions.CanCastTo a a
instance Lorentz.Coercions.CanCastTo a b => Lorentz.Coercions.CanCastTo [a] [b]
instance Lorentz.Coercions.CanCastTo a b => Lorentz.Coercions.CanCastTo (GHC.Maybe.Maybe a) (GHC.Maybe.Maybe b)
instance (Lorentz.Coercions.CanCastTo l1 l2, Lorentz.Coercions.CanCastTo r1 r2) => Lorentz.Coercions.CanCastTo (Data.Either.Either l1 r1) (Data.Either.Either l2 r2)
instance Lorentz.Coercions.CanCastTo k1 k2 => Lorentz.Coercions.CanCastTo (Data.Set.Internal.Set k1) (Data.Set.Internal.Set k2)
instance (Lorentz.Coercions.CanCastTo k1 k2, Lorentz.Coercions.CanCastTo v1 v2) => Lorentz.Coercions.CanCastTo (Data.Map.Internal.Map k1 v1) (Data.Map.Internal.Map k2 v2)
instance (Lorentz.Coercions.CanCastTo k1 k2, Lorentz.Coercions.CanCastTo v1 v2) => Lorentz.Coercions.CanCastTo (Michelson.Typed.Haskell.Value.BigMap k1 v1) (Michelson.Typed.Haskell.Value.BigMap k2 v2)
instance (Lorentz.Coercions.CanCastTo (Lorentz.Zip.ZippedStack i1) (Lorentz.Zip.ZippedStack i2), Lorentz.Coercions.CanCastTo (Lorentz.Zip.ZippedStack o1) (Lorentz.Zip.ZippedStack o2)) => Lorentz.Coercions.CanCastTo (i1 Lorentz.Base.:-> o1) (i2 Lorentz.Base.:-> o2)
instance Lorentz.Coercions.CanCastTo a1 a2 => Lorentz.Coercions.CanCastTo (Michelson.Typed.Haskell.Value.ContractRef a1) (Michelson.Typed.Haskell.Value.ContractRef a2)
instance (Lorentz.Coercions.CanCastTo a b, f Data.Type.Equality.~ g) => Lorentz.Coercions.CanCastTo (Named.Internal.NamedF f a n) (Named.Internal.NamedF g b m)
instance (Lorentz.Coercions.CanCastTo a1 a2, Lorentz.Coercions.CanCastTo b1 b2) => Lorentz.Coercions.CanCastTo (a1, b1) (a2, b2)
instance (Lorentz.Coercions.CanCastTo a1 a2, Lorentz.Coercions.CanCastTo b1 b2, Lorentz.Coercions.CanCastTo c1 c2) => Lorentz.Coercions.CanCastTo (a1, b1, c1) (a2, b2, c2)
instance (Lorentz.Coercions.CanCastTo a1 a2, Lorentz.Coercions.CanCastTo b1 b2, Lorentz.Coercions.CanCastTo c1 c2, Lorentz.Coercions.CanCastTo d1 d2) => Lorentz.Coercions.CanCastTo (a1, b1, c1, d1) (a2, b2, c2, d2)
instance (Lorentz.Coercions.CanCastTo a1 a2, Lorentz.Coercions.CanCastTo b1 b2, Lorentz.Coercions.CanCastTo c1 c2, Lorentz.Coercions.CanCastTo d1 d2, Lorentz.Coercions.CanCastTo e1 e2) => Lorentz.Coercions.CanCastTo (a1, b1, c1, d1, e1) (a2, b2, c2, d2, e2)
instance (Lorentz.Coercions.CanCastTo a1 a2, Lorentz.Coercions.CanCastTo b1 b2, Lorentz.Coercions.CanCastTo c1 c2, Lorentz.Coercions.CanCastTo d1 d2, Lorentz.Coercions.CanCastTo e1 e2, Lorentz.Coercions.CanCastTo f1 f2) => Lorentz.Coercions.CanCastTo (a1, b1, c1, d1, e1, f1) (a2, b2, c2, d2, e2, f2)
instance forall k (p :: k). Lorentz.Coercions.CanCastTo (Lorentz.Address.TAddress p) Tezos.Address.Address
instance forall k (p :: k). Lorentz.Coercions.CanCastTo Tezos.Address.Address (Lorentz.Address.TAddress p)
instance Lorentz.Coercions.CanCastTo (Lorentz.Address.FutureContract p) Michelson.Typed.EntryPoints.EpAddress


-- | Basic migration primitives.
--   
--   All primitives in one scheme:
--   
--   MigrationBlocks (batched migrations writing) /| || muBlock // ||
--   mkUStoreBatchedMigration // || // || MUStore || UStore template value
--   (simple migration writing) || (storage initialization) \ || // \ || //
--   mkUStoreMigration \ || // fillUStore | / |/ UStoreMigration (whole
--   migration) || \ || \ migrationToScript || \ compileMigration || \
--   MigrationBatching || \ (way to slice migration) || \ // || \ // || |
--   |/ || UStoreMigrationCompiled || (sliced migration) || // \ ||
--   migrationToScripts \ buildMigrationPlan || // \ migrationStagesNum ||
--   // \ ... / |/ | MigrationScript Information about migration (part of
--   migration which (migration plan, stages number...) fits into Tezos
--   transaction)
module Lorentz.UStore.Migration.Base

-- | Dummy template for <a>UStore</a>, use this when you want to forget
--   exact template and make type of store homomorphic.
data SomeUTemplate

-- | UStore with hidden template.
type UStore_ = UStore SomeUTemplate

-- | Code of migration for <a>UStore</a>.
--   
--   Invariant: preferably should fit into op size / gas limits (quite
--   obvious). Often this stands for exactly one stage of migration (one
--   Tezos transaction).
newtype MigrationScript (oldStore :: Type) (newStore :: Type)
MigrationScript :: Lambda UStore_ UStore_ -> MigrationScript
[unMigrationScript] :: MigrationScript -> Lambda UStore_ UStore_
maNameL :: Lens' MigrationAtom Text
maScriptL :: Lens' MigrationAtom MigrationScript_
maActionsDescL :: Lens' MigrationAtom [DMigrationActionDesc]

-- | Corner case of <a>MigrationScript</a> with some type argument unknown.
--   
--   You can turn this into <a>MigrationScript</a> using
--   <a>checkedCoerce</a>.
type MigrationScriptFrom oldStore = MigrationScript oldStore SomeUTemplate
type MigrationScriptTo newStore = MigrationScript SomeUTemplate newStore
type MigrationScript_ = MigrationScript SomeUTemplate SomeUTemplate

-- | Minimal possible piece of migration script.
--   
--   Different atoms can be arbitrarily reordered and separated across
--   migration stages, but each single atom is treated as a whole.
--   
--   Splitting migration into atoms is responsibility of migration writer.
data MigrationAtom
MigrationAtom :: Text -> MigrationScript_ -> [DMigrationActionDesc] -> MigrationAtom
[maName] :: MigrationAtom -> Text
[maScript] :: MigrationAtom -> MigrationScript_
[maActionsDesc] :: MigrationAtom -> [DMigrationActionDesc]

-- | Keeps information about migration between <a>UStore</a>s with two
--   given templates.
data UStoreMigration (oldTempl :: Type) (newTempl :: Type)
[UStoreMigration] :: [MigrationAtom] -> UStoreMigration oldTempl newTempl

-- | A bunch of migration atoms produced by migration writer.
newtype MigrationBlocks (oldTemplate :: Type) (newTemplate :: Type) (preRemDiff :: [DiffItem]) (preTouched :: [Symbol]) (postRemDiff :: [DiffItem]) (postTouched :: [Symbol])
MigrationBlocks :: [MigrationAtom] -> MigrationBlocks

-- | Wrapper over <a>UStore</a> which is currently being migrated.
--   
--   In type-level arguments it keeps
--   
--   <ul>
--   <li>Old and new <a>UStore</a> templates - mostly for convenience of
--   the implementation.</li>
--   <li>Remaining diff which yet should be covered. Here we track
--   migration progress. Once remaining diff is empty, migration is
--   finished.</li>
--   <li>Names of fields which have already been touched by migration.
--   Required to make getters safe.</li>
--   </ul>
newtype MUStore (oldTemplate :: Type) (newTemplate :: Type) (remDiff :: [DiffItem]) (touched :: [Symbol])
MUStoreUnsafe :: UStore oldTemplate -> MUStore

-- | Turn <tt>Migration</tt> into a whole piece of code for transforming
--   storage.
--   
--   This is not want you'd want to use for contract deployment because of
--   gas and operation size limits that Tezos applies to transactions.
migrationToLambda :: UStoreMigration oldTemplate newTemplate -> Lambda (UStore oldTemplate) (UStore newTemplate)

-- | Modify all code in migration.
mapMigrationCode :: (forall i o. (i :-> o) -> i :-> o) -> UStoreMigration os ns -> UStoreMigration os ns

-- | Safe way to create migration scripts for <a>UStore</a>.
--   
--   You have to supply a code which would transform <a>MUStore</a>,
--   coverring required diff step-by-step. All basic instructions work,
--   also use <tt>migrate*</tt> functions from this module to operate with
--   <a>MUStore</a>.
--   
--   This method produces a whole migration, it cannot be splitted in
--   batches. In case if your migration is too big to be applied within a
--   single transaction, use <a>mkUStoreBatchedMigration</a>.
mkUStoreMigration :: Lambda (MUStore oldTempl newTempl (BuildDiff oldTempl newTempl) '[]) (MUStore oldTempl newTempl '[] _1) -> UStoreMigration oldTempl newTempl

-- | Get migration script in case of simple (non-batched) migration.
migrationToScript :: UStoreMigration os ns -> MigrationScript os ns

-- | Get migration script in case of simple (non-batched) migration.
migrationToScriptI :: UStoreMigration os ns -> Identity (MigrationScript os ns)

-- | Way of distributing migration atoms among batches.
--   
--   This also participates in describing migration plan and should contain
--   information which would clarify to a user why migration is splitted
--   such a way. Objects of type <tt>batchInfo</tt> stand for information
--   corresponding to a batch and may include e.g. names of taken actions
--   and gas consumption.
--   
--   Type argument <tt>structure</tt> stands for container where batches
--   will be put to and is usually a list ('[]').
--   
--   When writing an instance of this datatype, you should tend to produce
--   as few batches as possible because Tezos transaction execution
--   overhead is quite high; though these batches should still preferably
--   fit into gas limit.
--   
--   Note that we never fail here because reaching perfect consistency with
--   Tezos gas model is beyond dreams for now, even if our model predicts
--   that some migration atom cannot be fit into gas limit, Tezos node can
--   think differently and accept the migration. If your batching function
--   can make predictions about fitting into gas limit, consider including
--   this information in <tt>batchInfo</tt> type.
--   
--   See batching implementations in
--   <a>Lorentz.UStore.Migration.Batching</a> module.
data MigrationBatching (structure :: Type -> Type) (batchInfo :: Type)
MigrationBatching :: ([MigrationAtom] -> structure (batchInfo, MigrationScript_)) -> MigrationBatching

-- | Put each migration atom to a separate batch.
--   
--   In most cases this is not what you want, but may be useful if e.g. you
--   write your migration manually.
mbBatchesAsIs :: MigrationBatching [] Text

-- | Put the whole migration into one batch.
mbNoBatching :: MigrationBatching Identity Text

-- | Compile migration for use in production.
compileMigration :: Functor t => MigrationBatching t batchInfo -> UStoreMigration ot nt -> UStoreMigrationCompiled ot nt t batchInfo

-- | Migration script splitted in batches.
--   
--   This is an intermediate form of migration content and needed because
--   compiling <a>UStoreMigration</a> is a potentially heavyweight
--   operation, and after compilation is performed you may need to get
--   various information like number of migration steps, migration script,
--   migration plan and other.
newtype UStoreMigrationCompiled (oldStore :: Type) (newStore :: Type) (structure :: Type -> Type) (batchInfo :: Type)
UStoreMigrationCompiled :: structure (batchInfo, MigrationScript oldStore newStore) -> UStoreMigrationCompiled
[compiledMigrationContent] :: UStoreMigrationCompiled -> structure (batchInfo, MigrationScript oldStore newStore)

-- | Version of <a>mkUStoreMigration</a> which allows splitting migration
--   in batches.
--   
--   Here you supply a sequence of migration blocks which then are
--   automatically distributed among migration stages.
mkUStoreBatchedMigration :: MigrationBlocks oldTempl newTempl (BuildDiff oldTempl newTempl) '[] '[] _1 -> UStoreMigration oldTempl newTempl

-- | Get migration scripts, each to be executed in separate Tezos
--   transaction.
migrationToScripts :: Traversable t => UStoreMigrationCompiled os ns t batchInfo -> t (MigrationScript os ns)

-- | Get migration scripts as list.
migrationToScriptsList :: Traversable t => UStoreMigrationCompiled os ns t batchInfo -> [MigrationScript os ns]

-- | Get information about each batch.
migrationToInfo :: Traversable t => UStoreMigrationCompiled ot nt t batchInfo -> t batchInfo

-- | Number of stages in migration.
migrationStagesNum :: Traversable t => UStoreMigrationCompiled ot nt t batchInfo -> Int

-- | Render migration plan.
buildMigrationPlan :: (Traversable t, Buildable batchInfo) => UStoreMigrationCompiled ot nt t batchInfo -> Builder
manualWithOldUStore :: ('[UStore oldStore] :-> '[UStore oldStore]) -> MigrationScript oldStore newStore
manualWithNewUStore :: ('[UStore newStore] :-> '[UStore newStore]) -> MigrationScript oldStore newStore

-- | Merge several migration scripts. Used in manual migrations.
--   
--   This function is generally unsafe because resulting migration script
--   can fail to fit into operation size limit.
manualConcatMigrationScripts :: [MigrationScript os ns] -> MigrationScript os ns
manualMapMigrationScript :: (('[UStore_] :-> '[UStore_]) -> '[UStore_] :-> '[UStore_]) -> MigrationScript oldStore newStore -> MigrationScript oldStore newStore

-- | An action on storage entry.
data DMigrationActionType

-- | Some sort of addition: "init", "set", "overwrite", e.t.c.
DAddAction :: Text -> DMigrationActionType

-- | Removal.
DDelAction :: DMigrationActionType

-- | Describes single migration action.
--   
--   In most cases it is possible to derive reasonable description for
--   migration atom automatically, this datatype exactly carries this
--   information.
data DMigrationActionDesc
DMigrationActionDesc :: DMigrationActionType -> Text -> T -> DMigrationActionDesc

-- | Action on field, e.g. "set", "remove", "overwrite".
[manAction] :: DMigrationActionDesc -> DMigrationActionType

-- | Name of affected field of <a>UStore</a>.
[manField] :: DMigrationActionDesc -> Text

-- | Type of affected field of <a>UStore</a> in new storage version.
[manFieldType] :: DMigrationActionDesc -> T

-- | Add description of action, it will be used in rendering migration plan
--   and some batching implementations.
attachMigrationActionName :: SingI (ToT fieldTy) => DMigrationActionType -> Label fieldName -> Proxy fieldTy -> s :-> s

-- | Create migration atom from code.
--   
--   This is an internal function, should not be used for writing
--   migrations.
formMigrationAtom :: Maybe Text -> Lambda UStore_ UStore_ -> MigrationAtom
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.UStore.Migration.Base.MUStore oldTemplate newTemplate remDiff touched)
instance GHC.Generics.Generic (Lorentz.UStore.Migration.Base.MUStore oldTemplate newTemplate remDiff touched)
instance GHC.Show.Show Lorentz.UStore.Migration.Base.MigrationAtom
instance GHC.Show.Show Lorentz.UStore.Migration.Base.DMigrationActionDesc
instance GHC.Show.Show Lorentz.UStore.Migration.Base.DMigrationActionType
instance Lorentz.TypeAnns.HasTypeAnn (Lorentz.UStore.Migration.Base.MigrationScript oldStore newStore)
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.UStore.Migration.Base.MigrationScript oldStore newStore)
instance GHC.Generics.Generic (Lorentz.UStore.Migration.Base.MigrationScript oldStore newStore)
instance GHC.Show.Show (Lorentz.UStore.Migration.Base.MigrationScript oldStore newStore)
instance Michelson.Doc.DocItem Lorentz.UStore.Migration.Base.DMigrationActionDesc
instance Formatting.Buildable.Buildable Lorentz.UStore.Migration.Base.DMigrationActionType
instance Control.Lens.Wrapped.Wrapped (Lorentz.UStore.Migration.Base.MigrationScript oldStore newStore)
instance (Data.Typeable.Internal.Typeable oldStore, Data.Typeable.Internal.Typeable newStore) => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.UStore.Migration.Base.MigrationScript oldStore newStore)
instance Lorentz.Coercions.CanCastTo (Lorentz.Base.Lambda (Lorentz.UStore.Types.UStore ot1) (Lorentz.UStore.Types.UStore nt1)) (Lorentz.Base.Lambda (Lorentz.UStore.Types.UStore ot2) (Lorentz.UStore.Types.UStore nt2)) => Lorentz.Coercions.CanCastTo (Lorentz.UStore.Migration.Base.MigrationScript ot1 nt1) (Lorentz.UStore.Migration.Base.MigrationScript ot2 nt2)
instance Lorentz.UStore.Migration.Base.SameUStoreTemplate template1 template2 => Lorentz.Coercions.CanCastTo (Lorentz.UStore.Types.UStore template1) (Lorentz.UStore.Types.UStore template2)


-- | Different approaches to batching.
--   
--   For now we do not support perfect batching because operation size
--   evaluation (as well as gas consumption evaluation) is not implemented
--   yet. The only non-trivial batching implementation we provide is
--   <a>mbSeparateLambdas</a>.
module Lorentz.UStore.Migration.Batching

-- | Type of batch.
data SlBatchType

-- | Addition of any type of data.
SlbtData :: SlBatchType

-- | Addition of code.
SlbtLambda :: SlBatchType

-- | Several joined actions of different types.
SlbtCustom :: SlBatchType

-- | No information to chooseType about batching. This means that the given
--   action does not contain <a>DMigrationActionDesc</a>.
SlbtUnknown :: SlBatchType
data SlBatchInfo
SlBatchInfo :: SlBatchType -> [Text] -> SlBatchInfo
[slbiType] :: SlBatchInfo -> SlBatchType
[slbiActions] :: SlBatchInfo -> [Text]

-- | Puts all data updates in one batch, and all lambdas in separate
--   batches, one per batch.
--   
--   The reason for such behaviour is that in production contracts amount
--   of changed data (be it in contract initialization or contract upgrade)
--   is small, while stored entrypoints are huge and addition of even one
--   entrypoint often barely fits into gas limit.
mbSeparateLambdas :: MigrationBatching [] SlBatchInfo
instance GHC.Classes.Eq Lorentz.UStore.Migration.Batching.SlBatchType
instance GHC.Show.Show Lorentz.UStore.Migration.Batching.SlBatchType
instance Formatting.Buildable.Buildable Lorentz.UStore.Migration.Batching.SlBatchInfo


-- | Composability helper for <a>UStore</a>.
module Lorentz.UStore.Lift

-- | Lift an <a>UStore</a> to another <a>UStore</a> which contains all the
--   entries of the former under given field.
--   
--   This function is not intended for use in migrations, only in normal
--   entry points.
--   
--   Note that this function ensures that template of resulting store does
--   not contain inner nested templates with duplicated fields, otherwise
--   <a>UStore</a> invariants could get broken.
liftUStore :: (Generic template, RequireAllUniqueFields template) => Label name -> (UStore (GetFieldType template name) : s) :-> (UStore template : s)

-- | Unlift an <a>UStore</a> to a smaller <a>UStore</a> which is part of
--   the former.
--   
--   This function is not intended for use in migrations, only in normal
--   entry points.
--   
--   Surprisingly, despite smaller <a>UStore</a> may have extra entries,
--   this function is safe when used in contract code. Truly, all getters
--   and setters are still safe to use. Also, there is no way for the
--   resulting small <tt>UStore</tt> to leak outside of the contract since
--   the only place where <tt>big_map</tt> can appear is contract storage,
--   so this small <tt>UStore</tt> can be either dropped or lifted back via
--   <a>liftUStore</a> to appear as part of the new contract's state.
--   
--   When this function is run as part of standalone instructions sequence,
--   not as part of contract code (e.g. in tests), you may get an
--   <tt>UStore</tt> with entries not inherent to it.
unliftUStore :: Generic template => Label name -> (UStore template : s) :-> (UStore (GetFieldType template name) : s)
type UStoreFieldsAreUnique template = AllUnique (UStoreFields template)
instance GHC.Generics.Generic Lorentz.UStore.Lift.MyStoreTemplateBig
instance GHC.Generics.Generic Lorentz.UStore.Lift.MyStoreTemplate


-- | Common Michelson macros defined using Lorentz syntax.
module Lorentz.Macro
type NiceComparable a = (KnownValue a, ProperComparabilityBetterErrors (ToT a))
eq :: NiceComparable n => (n & (n & s)) :-> (Bool & s)
neq :: NiceComparable n => (n & (n & s)) :-> (Bool & s)
lt :: NiceComparable n => (n & (n & s)) :-> (Bool & s)
gt :: NiceComparable n => (n & (n & s)) :-> (Bool & s)
le :: NiceComparable n => (n & (n & s)) :-> (Bool & s)
ge :: NiceComparable n => (n & (n & s)) :-> (Bool & s)
ifEq0 :: IfCmp0Constraints a Eq' => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifGe0 :: IfCmp0Constraints a Ge => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifGt0 :: IfCmp0Constraints a Gt => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifLe0 :: IfCmp0Constraints a Le => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifLt0 :: IfCmp0Constraints a Lt => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifNeq0 :: IfCmp0Constraints a Neq => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifEq :: NiceComparable a => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifGe :: NiceComparable a => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifGt :: NiceComparable a => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifLe :: NiceComparable a => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifLt :: NiceComparable a => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifNeq :: NiceComparable a => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'

-- | Analog of the FAIL macro in Michelson. Its usage is discouraged
--   because it doesn't carry any information about failure.

-- | <i>Warning: <a>fail_</a> remains in code</i>
fail_ :: a :-> c
assert :: IsError err => err -> (Bool & s) :-> s
assertEq0 :: (IfCmp0Constraints a Eq', IsError err) => err -> (a & s) :-> s
assertNeq0 :: (IfCmp0Constraints a Neq, IsError err) => err -> (a & s) :-> s
assertLt0 :: (IfCmp0Constraints a Lt, IsError err) => err -> (a & s) :-> s
assertGt0 :: (IfCmp0Constraints a Gt, IsError err) => err -> (a & s) :-> s
assertLe0 :: (IfCmp0Constraints a Le, IsError err) => err -> (a & s) :-> s
assertGe0 :: (IfCmp0Constraints a Ge, IsError err) => err -> (a & s) :-> s
assertEq :: (NiceComparable a, IsError err) => err -> (a & (a & s)) :-> s
assertNeq :: (NiceComparable a, IsError err) => err -> (a & (a & s)) :-> s
assertLt :: (NiceComparable a, IsError err) => err -> (a & (a & s)) :-> s
assertGt :: (NiceComparable a, IsError err) => err -> (a & (a & s)) :-> s
assertLe :: (NiceComparable a, IsError err) => err -> (a & (a & s)) :-> s
assertGe :: (NiceComparable a, IsError err) => err -> (a & (a & s)) :-> s
assertNone :: IsError err => err -> (Maybe a & s) :-> s
assertSome :: IsError err => err -> (Maybe a & s) :-> (a & s)
assertLeft :: IsError err => err -> (Either a b & s) :-> (a & s)
assertRight :: IsError err => err -> (Either a b & s) :-> (b & s)
assertUsing :: IsError a => a -> (Bool & s) :-> s

-- | Constraint for duupX that combines kind-agnostic constraint for
--   Lorentz (Haskell) types and for our typed Michelson.
type ConstraintDuupXLorentz (n :: Peano) (s :: [Type]) (a :: Type) (s1 :: [Type]) (tail :: [Type]) = (DuupXConstraint' T n (ToTs s) (ToT a) (ToTs s1) (ToTs tail), DuupXConstraint' Type n s a s1 tail)

-- | Constraint for replaceN that combines kind-agnostic constraint for
--   Lorentz (Haskell) types and for our typed Michelson.
type ConstraintReplaceNLorentz (n :: Peano) (s :: [Type]) (a :: Type) (mid :: [Type]) (tail :: [Type]) = (ReplaceNConstraint' T n (ToTs s) (ToT a) (ToTs mid) (ToTs tail), ReplaceNConstraint' Type n s a mid tail)

-- | Constraint for updateN that combines kind-agnostic constraint for
--   Lorentz (Haskell) types and for our typed Michelson.
type ConstraintUpdateNLorentz (n :: Peano) (s :: [Type]) (a :: Type) (b :: Type) (mid :: [Type]) (tail :: [Type]) = (UpdateNConstraint' T n (ToTs s) (ToT a) (ToT b) (ToTs mid) (ToTs tail), UpdateNConstraint' Type n s a b mid tail)
class DuupX (n :: Peano) (s :: [Type]) (a :: Type) s1 tail
duupXImpl :: DuupX n s a s1 tail => s :-> (a : s)
class ReplaceN (n :: Peano) (s :: [Type]) (a :: Type) mid tail
replaceNImpl :: ReplaceN n s a mid tail => (a : s) :-> s
class UpdateN (n :: Peano) (s :: [Type]) (a :: Type) (b :: Type) mid tail
updateNImpl :: UpdateN n s a b mid tail => ('[a, b] :-> '[b]) -> (a : s) :-> s

-- | Custom Lorentz macro that drops element with given index (starting
--   from 0) from the stack.
dropX :: forall (n :: Nat) a inp out s s'. (ConstraintDIPNLorentz (ToPeano n) inp out s s', s ~ (a : s')) => inp :-> out

-- | Duplicate the top of the stack <tt>n</tt> times.
--   
--   For example, `cloneX @3` has type `a &amp; s :-&gt; a &amp; a &amp; a
--   &amp; a &amp; s`.
cloneX :: forall (n :: Nat) a s. CloneX (ToPeano n) a s => (a & s) :-> CloneXT (ToPeano n) a s

-- | <tt>DUU+P</tt> macro. For example, `duupX @3` is <tt>DUUUP</tt>, it
--   puts the 3-rd (starting from 1) element to the top of the stack. Note
--   that it is implemented differently for `n ≤ 2` and for `n &gt; 2`. In
--   the latter case it is implemented using <a>dipN</a>, <a>dig</a> and
--   <a>dup</a>. In the former case it uses specialized versions. There is
--   also a minor difference with the implementation of `DUU*P` in
--   Michelson. They implement <tt>DUUUUP</tt> as `DIP 3 { DUP }; DIG 4`.
--   We implement it as `DIP 3 { DUP }; DIG 3`. These are equivalent. Our
--   version is supposedly cheaper, at least it should be packed more
--   efficiently due to the way numbers are packed.
duupX :: forall (n :: Nat) a (s :: [Type]) (s1 :: [Type]) (tail :: [Type]). (ConstraintDuupXLorentz (ToPeano (n - 1)) s a s1 tail, DuupX (ToPeano n) s a s1 tail) => s :-> (a : s)

-- | Version of <a>framed</a> which accepts number of elements on input
--   stack which should be preserved.
--   
--   You can treat this macro as calling a Michelson function with given
--   number of arguments.
framedN :: forall n nNat s i i' o o'. (nNat ~ ToPeano n, i' ~ Take nNat i, s ~ Drop nNat i, i ~ (i' ++ s), o ~ (o' ++ s), KnownList i', KnownList o') => (i' :-> o') -> i :-> o
caar :: (((a, b1), b2) & s) :-> (a & s)
cadr :: (((a, b1), b2) & s) :-> (b1 & s)
cdar :: ((a1, (a2, b)) & s) :-> (a2 & s)
cddr :: ((a1, (a2, b)) & s) :-> (b & s)
ifRight :: ((b & s) :-> s') -> ((a & s) :-> s') -> (Either a b & s) :-> s'
ifSome :: ((a & s) :-> s') -> (s :-> s') -> (Maybe a & s) :-> s'
when_ :: (s :-> s) -> (Bool : s) :-> s
unless_ :: (s :-> s) -> (Bool : s) :-> s
whenSome :: ((a : s) :-> s) -> (Maybe a : s) :-> s
mapCar :: ((a & s) :-> (a1 & s)) -> ((a, b) & s) :-> ((a1, b) & s)
mapCdr :: ((b & ((a, b) & s)) :-> (b1 & ((a, b) & s))) -> ((a, b) & s) :-> ((a, b1) & s)
papair :: (a & (b & (c & s))) :-> (((a, b), c) & s)
ppaiir :: (a & (b & (c & s))) :-> ((a, (b, c)) & s)
unpair :: ((a, b) & s) :-> (a & (b & s))
setCar :: ((a, b1) & (b2 & s)) :-> ((b2, b1) & s)
setCdr :: ((a, b1) & (b2 & s)) :-> ((a, b2) & s)

-- | Insert given element into set.
--   
--   This is a separate function from <tt>updateMap</tt> because stacks
--   they operate with differ in length.
setInsert :: IsComparable e => (e & (Set e & s)) :-> (Set e & s)

-- | Insert given element into map.
mapInsert :: (MapInstrs map, IsComparable k) => (k : (v : (map k v : s))) :-> (map k v : s)

-- | Insert given element into set, ensuring that it does not overwrite any
--   existing entry.
--   
--   As first argument accepts container name.
setInsertNew :: (IsComparable e, KnownValue err) => (forall s0. (e : s0) :-> (err : s0)) -> (e & (Set e & s)) :-> (Set e & s)

-- | Insert given element into map, ensuring that it does not overwrite any
--   existing entry.
--   
--   As first argument accepts container name (for error message).
mapInsertNew :: (MapInstrs map, IsComparable k, KnownValue e) => (forall s0. (k : s0) :-> (e : s0)) -> (k : (v : (map k v : s))) :-> (map k v : s)

-- | Delete element from the map.
deleteMap :: forall k v s. (MapInstrs map, IsComparable k, KnownValue k, KnownValue v) => (k : (map k v : s)) :-> (map k v : s)

-- | Delete given element from the set.
setDelete :: IsComparable e => (e & (Set e & s)) :-> (Set e & s)

-- | Replace nth element (0-indexed) with the one on the top of the stack.
--   For example, `replaceN <tt>3` replaces the 3rd element with the 0th
--   one. `replaceN </tt>0` is not a valid operation (and it is not
--   implemented). `replaceN <tt>1` is equivalent to `swap # drop` (and is
--   the only one implemented like this). In all other cases `replaceN
--   </tt>n` will drop the nth element (`dipN <tt>n drop`) and then put the
--   0th one in its place (`dug </tt>(n-1)`).
replaceN :: forall (n :: Nat) a (s :: [Type]) (s1 :: [Type]) (tail :: [Type]). (ConstraintReplaceNLorentz (ToPeano (n - 1)) s a s1 tail, ReplaceN (ToPeano n) s a s1 tail) => (a : s) :-> s

-- | Replaces the nth element (0-indexed) with the result of the given
--   "updating" instruction (binary with the return type equal to the
--   second argument) applied to the 0th element and the nth element
--   itself. For example, `updateN <tt>3 cons` replaces the 3rd element
--   with the result of <a>cons</a> applied to the topmost element and the
--   3rd one. `updateN </tt>0 instr` is not a valid operation (and it is
--   not implemented). `updateN <tt>1 instr` is equivalent to
--   <tt>instr</tt> (and so is implemented). `updateN </tt>2 instr` is
--   equivalent to `swap # dip instr` (and so is implemented). In all other
--   cases `updateN <tt>n instr` will put the topmost element right above
--   the nth one (`dug </tt>(n-1)`) and then apply the function to them in
--   place (`dipN @(n-1) instr`).
updateN :: forall (n :: Nat) a b (s :: [Type]) (mid :: [Type]) (tail :: [Type]). (ConstraintUpdateNLorentz (ToPeano (n - 1)) s a b mid tail, UpdateN (ToPeano n) s a b mid tail) => ('[a, b] :-> '[b]) -> (a : s) :-> s

-- | <tt>view</tt> type synonym as described in A1.
data View (a :: Type) (r :: Type)
View :: a -> ContractRef r -> View
[viewParam] :: View -> a
[viewCallbackTo] :: View -> ContractRef r

-- | <tt>void</tt> type synonym as described in A1.
data Void_ (a :: Type) (b :: Type)
Void_ :: a -> Lambda b b -> Void_

-- | Entry point argument.
[voidParam] :: Void_ -> a

-- | Type of result reported via <a>failWith</a>.
[voidResProxy] :: Void_ -> Lambda b b

-- | Newtype over void result type used in tests to distinguish successful
--   void result from other errors.
--   
--   Usage example: lExpectFailWith (== VoidResult roleMaster)`
--   
--   This error is special - it can contain arguments of different types
--   depending on entrypoint which raises it.
newtype VoidResult r
VoidResult :: r -> VoidResult r
[unVoidResult] :: VoidResult r -> r
view_ :: NiceParameter r => (forall s0. ((a, storage) & s0) :-> (r : s0)) -> (View a r & (storage & s)) :-> ((List Operation, storage) & s)

-- | Polymorphic version of <a>View</a> constructor.
mkView :: ToContractRef r contract => a -> contract -> View a r

-- | Wrap internal representation of view into <a>View</a> itself.
--   
--   <a>View</a> is part of public standard and should not change often.
wrapView :: ((a, ContractRef r) : s) :-> (View a r : s)

-- | Unwrap <a>View</a> into its internal representation.
--   
--   <a>View</a> is part of public standard and should not change often.
unwrapView :: (View a r : s) :-> ((a, ContractRef r) : s)
void_ :: forall a b s s' anything. (IsError (VoidResult b), KnownValue b) => ((a & s) :-> (b & s')) -> (Void_ a b & s) :-> anything
mkVoid :: forall b a. a -> Void_ a b
voidResultTag :: MText
buildView :: (a -> Builder) -> View a r -> Builder
buildViewTuple :: TupleF a => View a r -> Builder
addressToEpAddress :: (Address : s) :-> (EpAddress : s)

-- | Push a value of <tt>contract</tt> type.
--   
--   Doing this via <a>push</a> instruction is not possible, so we need to
--   perform extra actions here.
--   
--   Aside from <tt>contract</tt> value itself you will need to specify
--   which error to throw in case this value is not valid.
pushContractRef :: NiceParameter arg => (forall s0. (FutureContract arg : s) :-> s0) -> ContractRef arg -> s :-> (ContractRef arg : s)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Lorentz.Macro.VoidResult r)
instance GHC.Generics.Generic (Lorentz.Macro.VoidResult r)
instance (Lorentz.TypeAnns.HasTypeAnn a, Lorentz.TypeAnns.HasTypeAnn b) => Lorentz.TypeAnns.HasTypeAnn (Lorentz.Macro.Void_ a b)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Macro.Void_ a b)
instance GHC.Show.Show a => GHC.Show.Show (Lorentz.Macro.Void_ a b)
instance GHC.Generics.Generic (Lorentz.Macro.Void_ a b)
instance (Lorentz.TypeAnns.HasTypeAnn a, Lorentz.TypeAnns.HasTypeAnn r) => Lorentz.TypeAnns.HasTypeAnn (Lorentz.Macro.View a r)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Macro.View a r)
instance GHC.Generics.Generic (Lorentz.Macro.View a r)
instance GHC.Show.Show a => GHC.Show.Show (Lorentz.Macro.View a r)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Lorentz.Macro.View a r)
instance (Michelson.Typed.Haskell.Doc.TypeHasDoc r, Lorentz.Errors.IsError (Lorentz.Macro.VoidResult r)) => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Macro.VoidResult r)
instance (Data.Typeable.Internal.Typeable r, Lorentz.Constraints.Scopes.NiceConstant r, Lorentz.Errors.ErrorHasDoc (Lorentz.Macro.VoidResult r)) => Lorentz.Errors.IsError (Lorentz.Macro.VoidResult r)
instance Michelson.Typed.Haskell.Doc.TypeHasDoc r => Lorentz.Errors.ErrorHasDoc (Lorentz.Macro.VoidResult r)
instance Lorentz.Errors.CustomErrorNoIsoValue (Lorentz.Macro.VoidResult r) => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Macro.VoidResult r)
instance (Lorentz.Coercions.CanCastTo a1 a2, Lorentz.Coercions.CanCastTo r1 r2) => Lorentz.Coercions.CanCastTo (Lorentz.Macro.Void_ a1 r1) (Lorentz.Macro.Void_ a2 r2)
instance Universum.TypeOps.Each '[Data.Typeable.Internal.Typeable, Michelson.Typed.Haskell.Doc.TypeHasDoc] '[a, r] => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Macro.Void_ a r)
instance Formatting.Buildable.Buildable a => Formatting.Buildable.Buildable (Lorentz.Macro.Void_ a b)
instance (Lorentz.Coercions.CanCastTo a1 a2, Lorentz.Coercions.CanCastTo r1 r2) => Lorentz.Coercions.CanCastTo (Lorentz.Macro.View a1 r1) (Lorentz.Macro.View a2 r2)
instance Universum.TypeOps.Each '[Data.Typeable.Internal.Typeable, Michelson.Typed.Haskell.Doc.TypeHasDoc] '[a, r] => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Macro.View a r)
instance Formatting.Buildable.Buildable a => Formatting.Buildable.Buildable (Lorentz.Macro.View a r)
instance Formatting.Buildable.Buildable (Lorentz.Macro.View () r)
instance forall k (s :: [*]) b (tail :: [*]) a (mid :: k). (s Data.Type.Equality.~ (b : tail)) => Lorentz.Macro.UpdateN ('Data.Vinyl.TypeLevel.S 'Data.Vinyl.TypeLevel.Z) s a b mid tail
instance forall k (s :: [*]) x b (tail :: [*]) a (mid :: k). (s Data.Type.Equality.~ (x : b : tail)) => Lorentz.Macro.UpdateN ('Data.Vinyl.TypeLevel.S ('Data.Vinyl.TypeLevel.S 'Data.Vinyl.TypeLevel.Z)) s a b mid tail
instance Lorentz.Macro.ConstraintUpdateNLorentz ('Data.Vinyl.TypeLevel.S ('Data.Vinyl.TypeLevel.S n)) s a b mid tail => Lorentz.Macro.UpdateN ('Data.Vinyl.TypeLevel.S ('Data.Vinyl.TypeLevel.S ('Data.Vinyl.TypeLevel.S n))) s a b mid tail
instance forall k1 k2 (s :: [*]) a (xs :: [*]) (mid :: k2) (tail :: k1). (s Data.Type.Equality.~ (a : xs)) => Lorentz.Macro.ReplaceN ('Data.Vinyl.TypeLevel.S 'Data.Vinyl.TypeLevel.Z) s a mid tail
instance Lorentz.Macro.ConstraintReplaceNLorentz ('Data.Vinyl.TypeLevel.S n) s a mid tail => Lorentz.Macro.ReplaceN ('Data.Vinyl.TypeLevel.S ('Data.Vinyl.TypeLevel.S n)) s a mid tail
instance Lorentz.Macro.MapInstrs Data.Map.Internal.Map
instance Lorentz.Macro.MapInstrs Michelson.Typed.Haskell.Value.BigMap
instance forall k1 k2 (s :: [*]) a (xs :: [*]) (s1 :: k2) (tail :: k1). (s Data.Type.Equality.~ (a : xs)) => Lorentz.Macro.DuupX ('Data.Vinyl.TypeLevel.S 'Data.Vinyl.TypeLevel.Z) s a s1 tail
instance forall k1 k2 b a (xs :: [*]) (s1 :: k2) (tail :: k1). Lorentz.Macro.DuupX ('Data.Vinyl.TypeLevel.S ('Data.Vinyl.TypeLevel.S 'Data.Vinyl.TypeLevel.Z)) (b : a : xs) a s1 tail
instance Lorentz.Macro.ConstraintDuupXLorentz ('Data.Vinyl.TypeLevel.S ('Data.Vinyl.TypeLevel.S n)) s a s1 tail => Lorentz.Macro.DuupX ('Data.Vinyl.TypeLevel.S ('Data.Vinyl.TypeLevel.S ('Data.Vinyl.TypeLevel.S n))) s a s1 tail
instance Lorentz.Macro.CloneX 'Data.Vinyl.TypeLevel.Z a s
instance Lorentz.Macro.CloneX n a s => Lorentz.Macro.CloneX ('Data.Vinyl.TypeLevel.S n) a s


-- | Instructions to work with <a>UStore</a>.
module Lorentz.UStore.Instr

-- | Put an empty <a>UStore</a> onto the stack. This function is generally
--   unsafe: if store template contains a <a>UStoreFieldExt</a>, the
--   resulting <a>UStore</a> is not immediately usable. If you are sure
--   that <a>UStore</a> contains only submaps, feel free to just use the
--   result of this function. Otherwise you must set all fields.
unsafeEmptyUStore :: forall store s. s :-> (UStore store : s)
ustoreMem :: forall store name s. KeyAccessC store name => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (Bool : s)
ustoreGet :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (Maybe (GetUStoreValue store name) : s)
ustoreUpdate :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (Maybe (GetUStoreValue store name) : (UStore store : s))) :-> (UStore store : s)
ustoreInsert :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (GetUStoreValue store name : (UStore store : s))) :-> (UStore store : s)

-- | Insert a key-value pair, but fail if it will overwrite some existing
--   entry.
ustoreInsertNew :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (forall s0 any. (GetUStoreKey store name : s0) :-> any) -> (GetUStoreKey store name : (GetUStoreValue store name : (UStore store : s))) :-> (UStore store : s)
ustoreDelete :: forall store name s. KeyAccessC store name => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (UStore store : s)

-- | Like <tt>toField</tt>, but for <a>UStore</a>.
--   
--   This may fail only if <a>UStore</a> was made up incorrectly during
--   contract initialization.
ustoreToField :: forall store name s. FieldAccessC store name => Label name -> (UStore store : s) :-> (GetUStoreField store name : s)

-- | Like <tt>getField</tt>, but for <a>UStore</a>.
--   
--   This may fail only if <a>UStore</a> was made up incorrectly during
--   contract initialization.
ustoreGetField :: forall store name s. FieldAccessC store name => Label name -> (UStore store : s) :-> (GetUStoreField store name : (UStore store : s))

-- | Like <tt>setField</tt>, but for <a>UStore</a>.
ustoreSetField :: forall store name s. FieldAccessC store name => Label name -> (GetUStoreField store name : (UStore store : s)) :-> (UStore store : s)

-- | Remove a field from <a>UStore</a>, for internal purposes only.
ustoreRemoveFieldUnsafe :: forall store name s. FieldAccessC store name => Label name -> (UStore store : s) :-> (UStore store : s)

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some submap(s) of it.
--   
--   It can use all UStore operations for a particular name, key and value
--   without knowing whole template.
type HasUStore name key value store = (KeyAccessC store name, ValueAccessC store name, GetUStoreKey store name ~ key, GetUStoreValue store name ~ value)

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some field of it.
type HasUField name ty store = (FieldAccessC store name, GetUStoreField store name ~ ty)

-- | Write down all sensisble constraints which given <tt>store</tt>
--   satisfies and apply them to <tt>constrained</tt>.
--   
--   This store should have <a>|~&gt;</a> and <a>UStoreFieldExt</a> fields
--   in its immediate fields, no deep inspection is performed.
type HasUStoreForAllIn store constrained = (Generic store, GHasStoreForAllIn constrained (Rep store))
packSubMapUKey :: forall (field :: Symbol) k s. (KnownSymbol field, NicePackedValue k) => (k : s) :-> (ByteString : s)
instance GHC.Generics.Generic Lorentz.UStore.Instr.MyStoreTemplateBig
instance GHC.Generics.Generic Lorentz.UStore.Instr.MyStoreTemplate3
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.UStore.Instr.MyNatural
instance Michelson.Typed.Haskell.Value.IsoCValue Lorentz.UStore.Instr.MyNatural
instance GHC.Generics.Generic Lorentz.UStore.Instr.MyStoreTemplate2
instance GHC.Generics.Generic Lorentz.UStore.Instr.MyStoreTemplate
instance Lorentz.UStore.Types.KnownUStoreMarker Lorentz.UStore.Instr.Marker1


-- | Elemental building blocks for migrations.
module Lorentz.UStore.Migration.Blocks

-- | Get the old version of storage.
--   
--   This can be applied only in the beginning of migration.
--   
--   In fact this function is not very useful, all required operations
--   should be available for <a>MUStore</a>, but leaving it here just in
--   case.
mustoreToOld :: RequireBeInitial touched => (MUStore oldTemplate newTemplate remDiff touched : s) :-> (UStore oldTemplate : s)
class MigrationFinishCheckPosition a

-- | Put this in the end of migration script to get a human-readable
--   message about remaining diff which yet should be covered. Use of this
--   function in migration is fully optional.
--   
--   This function is not part of <a>mkUStoreMigration</a> for the sake of
--   proper error messages ordering, during development you probably want
--   errors in migration script to be located earlier in code than errors
--   about not fully covered diff (if you used to fix errors in the same
--   order in which they appear).
migrationFinish :: MigrationFinishCheckPosition a => a

-- | Cast field or submap pretending that its value fits to the new type.
--   
--   Useful when type of field, e.g. lambda or set of lambdas, is
--   polymorphic over storage type.
migrateCoerceUnsafe :: forall field oldTempl newTempl diff touched newDiff newDiff0 _1 _2 s. ('(_1, newDiff0) ~ CoverDiff  'DcRemove field diff, '(_2, newDiff) ~ CoverDiff  'DcAdd field newDiff0) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (MUStore oldTempl newTempl newDiff touched : s)

-- | Get a field present in old version of <a>UStore</a>.
migrateGetField :: forall field oldTempl newTempl diff touched fieldTy s. (HasUField field fieldTy oldTempl, RequireUntouched field (field `IsElem` touched)) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (fieldTy : (MUStore oldTempl newTempl diff touched : s))

-- | Add a field which was not present before. This covers one addition
--   from the diff and any removals of field with given name.
--   
--   This function cannot overwrite existing field with the same name, if
--   this is necessary use <a>migrateOverwriteField</a> which would declare
--   removal explicitly.
migrateAddField :: forall field oldTempl newTempl diff touched fieldTy newDiff marker s. ('(UStoreFieldExt marker fieldTy, newDiff) ~ CoverDiff  'DcAdd field diff, HasUField field fieldTy newTempl) => Label field -> (fieldTy : (MUStore oldTempl newTempl diff touched : s)) :-> (MUStore oldTempl newTempl newDiff (field : touched) : s)

-- | Remove a field which should not be present in new version of storage.
--   This covers one removal from the diff.
--   
--   In fact, this action could be performed automatically, but since
--   removal is a destructive operation, being explicit about it seems like
--   a good thing.
migrateRemoveField :: forall field oldTempl newTempl diff touched fieldTy newDiff marker s. ('(UStoreFieldExt marker fieldTy, newDiff) ~ CoverDiff  'DcRemove field diff, HasUField field fieldTy oldTempl) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (MUStore oldTempl newTempl newDiff (field : touched) : s)

-- | Get and remove a field from old version of <a>UStore</a>.
--   
--   You probably want to use this more often than plain
--   <a>migrateRemoveField</a>.
migrateExtractField :: forall field oldTempl newTempl diff touched fieldTy newDiff marker s. ('(UStoreFieldExt marker fieldTy, newDiff) ~ CoverDiff  'DcRemove field diff, HasUField field fieldTy oldTempl, RequireUntouched field (field `IsElem` touched)) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (fieldTy : (MUStore oldTempl newTempl newDiff (field : touched) : s))

-- | Remove field and write new one in place of it.
--   
--   This is semantically equivalent to <tt>dip (migrateRemoveField label)
--   &gt;&gt; migrateAddField label</tt>, but is cheaper.
migrateOverwriteField :: forall field oldTempl newTempl diff touched fieldTy oldFieldTy marker oldMarker newDiff newDiff0 s. ('(UStoreFieldExt oldMarker oldFieldTy, newDiff0) ~ CoverDiff  'DcRemove field diff, '(UStoreFieldExt marker fieldTy, newDiff) ~ CoverDiff  'DcAdd field newDiff0, HasUField field fieldTy newTempl) => Label field -> (fieldTy : (MUStore oldTempl newTempl diff touched : s)) :-> (MUStore oldTempl newTempl newDiff (field : touched) : s)

-- | Modify field which should stay in new version of storage. This does
--   not affect remaining diff.
migrateModifyField :: forall field oldTempl newTempl diff touched fieldTy s. (HasUField field fieldTy oldTempl, HasUField field fieldTy newTempl) => Label field -> (fieldTy : (MUStore oldTempl newTempl diff touched : s)) :-> (MUStore oldTempl newTempl diff touched : s)

-- | Define a migration atom.
--   
--   It will be named automatically according to the set of actions it
--   performs (via <a>DMigrationActionDesc</a>s). This may be want you want
--   for small sequences of actions, but for complex ones consider using
--   <a>muBlockNamed</a>. Names are used in rendering migration plan.
muBlock :: ('[MUStore o n d1 t1] :-> '[MUStore o n d2 t2]) -> MigrationBlocks o n d1 t1 d2 t2

-- | Define a migration atom with given name.
--   
--   Name will be used when rendering migration plan.
muBlockNamed :: Text -> ('[MUStore o n d1 t1] :-> '[MUStore o n d2 t2]) -> MigrationBlocks o n d1 t1 d2 t2

-- | Composition of migration blocks.
(<-->) :: MigrationBlocks o n d1 t1 d2 t2 -> MigrationBlocks o n d2 t2 d3 t3 -> MigrationBlocks o n d1 t1 d3 t3
infixl 2 <-->

-- | This is <a>$</a> operator with priority higher than <a>&lt;--&gt;</a>.
--   
--   It allows you writing
--   
--   <pre>
--   mkUStoreBatchedMigration =
--     muBlock $: do
--       migrateAddField ...
--     <a>--</a>
--     muBlock $: do
--       migrateRemoveField ...
--   </pre>
--   
--   Alternatively, <tt>BlockArguments</tt> extension can be used.
($:) :: (a -> b) -> a -> b
infixr 7 $:
instance (i Data.Type.Equality.~ (Lorentz.UStore.Migration.Base.MUStore oldTempl newTempl diff touched : s), o Data.Type.Equality.~ (Lorentz.UStore.Migration.Base.MUStore oldTempl newTempl '[] touched : s), Lorentz.UStore.Migration.Diff.RequireEmptyDiff diff) => Lorentz.UStore.Migration.Blocks.MigrationFinishCheckPosition (i Lorentz.Base.:-> o)
instance (Lorentz.UStore.Migration.Diff.RequireEmptyDiff d1, t1 Data.Type.Equality.~ t2) => Lorentz.UStore.Migration.Blocks.MigrationFinishCheckPosition (Lorentz.UStore.Migration.Base.MigrationBlocks o n d1 t1 '[] t2)


-- | Type-safe migrations of UStore.
--   
--   This implements imperative approach to migration when we make user
--   write a code of migration and track whether all new fields were indeed
--   added and all unnecessary fields were removed.
--   
--   You can find migration examples in tests.
--   
--   <h2>How to write your simple migration</h2>
--   
--   <ol>
--   <li>Start with migration template:<pre>migration ::
--   <a>UStoreMigration</a> V1.Storage V2.Storage migration =
--   <a>mkUStoreMigration</a> $ do -- migration code to be put here
--   <a>migrationFinish</a> </pre>You will be prompted with a list of
--   fields which should be added or removed.</li>
--   </ol>
--   
--   <ol>
--   <li>Add/remove necessary fields using <a>migrateAddField</a>,
--   <a>migrateExtractField</a> and other instructions. They allow you to
--   operate with <a>MUStore</a> — it is similar to <tt>UStore</tt> but
--   used within <a>mkUStoreMigration</a> to track migration progress.</li>
--   <li>Use <a>migrationToScript</a> or <tt>migrationToTestScript</tt> to
--   turn <a>UStoreMigration</a> into something useful.</li>
--   </ol>
--   
--   Note that here you will get a solid <a>MigrationScript</a>, thus
--   migration has to fit into single Tezos transaction. If that's an
--   issue, see the next section.
--   
--   <h2>How to write batched migration</h2>
--   
--   <ol>
--   <li>Insert migration template.It looks like:<pre>migration ::
--   <a>UStoreMigration</a> V1.Storage V2.Storage migration =
--   <a>mkUStoreBatchedMigration</a> $ -- place for migration blocks
--   <a>migrationFinish</a> </pre></li>
--   </ol>
--   
--   <ol>
--   <li>Fill migration code with blocks
--   like<pre><a>mkUStoreBatchedMigration</a> $ <a>muBlock</a> <a>$:</a> do
--   -- code for block 1 <a>&lt;--&gt;</a> <a>muBlock</a> <a>$:</a> do --
--   code for block 2 <a>&lt;--&gt;</a> <a>migrationFinish</a>
--   </pre>Migration blocks have to be the smallest actions which can
--   safely be mixed and splitted accross migration stages.</li>
--   <li>Compile migration with <tt>compileBatchedMigration</tt>.Here you
--   have to supply batching implementation. Alternatives
--   include<ul><li><a>mbNoBatching</a>;</li><li><a>mbBatchesAsIs</a>;</li><li>Functions
--   from <a>Batching</a> module.</li></ul></li>
--   <li>Get the required information about
--   migration.<ul><li><a>migrationToScripts</a> picks the migration
--   scripts, each has to be put in a separate Tezos
--   transaction.</li><li><a>buildMigrationPlan</a> - dump description of
--   each migration stage.</li></ul></li>
--   </ol>
--   
--   <h2>Manual migrations</h2>
--   
--   If for some reasons you need to define migration manually, you can use
--   functions from <tt>Manual migrations</tt> section of
--   <a>Lorentz.UStore.Migration.Base</a>.
module Lorentz.UStore.Migration


-- | Conversion between <a>UStore</a> in Haskell and Michelson
--   representation.
module Lorentz.UStore.Haskell

-- | <a>UStore</a> content represented as key-value pairs.
type UStoreContent = [(ByteString, ByteString)]

-- | Given template can be converted to <a>UStore</a> value.
class (Generic template, GUStoreConversible (Rep template)) => UStoreConversible template

-- | Make <a>UStore</a> from separate <tt>big_map</tt>s and fields.
mkUStore :: UStoreConversible template => template -> UStore template

-- | Decompose <a>UStore</a> into separate <tt>big_map</tt>s and fields.
--   
--   Since this function needs to <tt>UNPACK</tt> content of
--   <tt>UStore</tt> to actual keys and values, you have to provide
--   <tt>UnpackEnv</tt>.
--   
--   Along with resulting value, you get a list of <tt>UStore</tt> entries
--   which were not recognized as belonging to any submap or field
--   according to <tt>UStore</tt>'s template - this should be empty unless
--   <tt>UStore</tt> invariants were violated.
ustoreDecompose :: forall template. UStoreConversible template => UStore template -> Either Text (UStoreContent, template)

-- | Like <a>ustoreDecompose</a>, but requires all entries from
--   <tt>UStore</tt> to be recognized.
ustoreDecomposeFull :: forall template. UStoreConversible template => UStore template -> Either Text template

-- | Make migration script which initializes <a>UStore</a> from scratch.
fillUStore :: UStoreConversible template => template -> UStoreMigration () template

-- | Fill <a>UStore</a> with entries from the given template as part of
--   simple migration.
--   
--   Sometimes you already have some fields initialized and
--   <a>fillUStore</a> does not suit, then in case if your UStore template
--   is a nested structure you can use sub-templates to initialize the
--   corresponding parts of UStore.
--   
--   For batched migrations see <a>fillUStoreMigrationBlock</a>.
migrateFillUStore :: (UStoreConversible template, allFieldsExp ~ AllUStoreFieldsF template, newDiff ~ FillingNewDiff template diff, newTouched ~ FillingNewTouched template touched, PatternMatchL newDiff, PatternMatchL newTouched) => template -> Lambda (MUStore oldTempl newTempl diff touched) (MUStore oldTempl newTempl newDiff newTouched)

-- | Version of <a>migrateFillUStore</a> for batched migrations.
--   
--   Each field write will be placed to a separate batch.
fillUStoreMigrationBlock :: (UStoreConversible template, allFieldsExp ~ AllUStoreFieldsF template, newDiff ~ FillingNewDiff template diff, newTouched ~ FillingNewTouched template touched, PatternMatchL newDiff, PatternMatchL newTouched) => template -> MigrationBlocks oldTempl newTempl diff touched newDiff newTouched
instance GHC.Generics.Generic Lorentz.UStore.Haskell.MyStoreTemplateBig
instance GHC.Generics.Generic Lorentz.UStore.Haskell.MyStoreTemplate
instance (GHC.Generics.Generic template, Lorentz.UStore.Haskell.GUStoreConversible (GHC.Generics.Rep template)) => Lorentz.UStore.Haskell.UStoreConversible template
instance Lorentz.UStore.Haskell.UStoreConversible template => Lorentz.UStore.Haskell.GUStoreConversible (GHC.Generics.S1 i (GHC.Generics.Rec0 template))
instance Lorentz.UStore.Haskell.GUStoreConversible x => Lorentz.UStore.Haskell.GUStoreConversible (GHC.Generics.D1 i x)
instance Lorentz.UStore.Haskell.GUStoreConversible x => Lorentz.UStore.Haskell.GUStoreConversible (GHC.Generics.C1 i x)
instance (TypeError ...) => Lorentz.UStore.Haskell.GUStoreConversible (x GHC.Generics.:+: y)
instance (TypeError ...) => Lorentz.UStore.Haskell.GUStoreConversible GHC.Generics.V1
instance (Lorentz.UStore.Haskell.GUStoreConversible x, Lorentz.UStore.Haskell.GUStoreConversible y) => Lorentz.UStore.Haskell.GUStoreConversible (x GHC.Generics.:*: y)
instance Lorentz.UStore.Haskell.GUStoreConversible GHC.Generics.U1
instance (Lorentz.Constraints.Scopes.NiceFullPackedValue k, Lorentz.Constraints.Scopes.NiceFullPackedValue v, GHC.TypeLits.KnownSymbol fieldName, GHC.Classes.Ord k) => Lorentz.UStore.Haskell.GUStoreConversible (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just fieldName) _1 _2 _3) (GHC.Generics.Rec0 (k Lorentz.UStore.Types.|~> v)))
instance (Lorentz.Constraints.Scopes.NiceFullPackedValue v, Lorentz.UStore.Types.KnownUStoreMarker m, GHC.TypeLits.KnownSymbol fieldName) => Lorentz.UStore.Haskell.GUStoreConversible (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just fieldName) _1 _2 _3) (GHC.Generics.Rec0 (Lorentz.UStore.Types.UStoreFieldExt m v)))


-- | Contract which remembers all parameters it has been called with.
--   
--   Useful to save return values of <tt>View</tt> entry points.
module Lorentz.Test.Consumer

-- | Remembers parameters it was called with, last goes first.
contractConsumer :: ContractCode cp [cp]


-- | Reimplementation of some syntax sugar.
--   
--   You need the following module pragmas to make it work smoothly:
module Lorentz.Rebinded

-- | Aliases for '(#)' used by do-blocks.
(>>) :: (a :-> b) -> (b :-> c) -> a :-> c

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Defines semantics of <tt>if ... then ... else ...</tt> construction.
ifThenElse :: Condition arg argl argr outb out -> (argl :-> outb) -> (argr :-> outb) -> arg :-> out

-- | Predicate for <tt>if ... then .. else ...</tt> construction, defines a
--   kind of operation applied to the top elements of the current stack.
--   
--   Type arguments mean: 1. Input of <tt>if</tt> 2. Left branch input 3.
--   Right branch input 4. Output of branches 5. Output of <tt>if</tt>
data Condition arg argl argr outb out
[Holds] :: Condition (Bool : s) s s o o
[IsSome] :: Condition (Maybe a : s) (a : s) s o o
[IsNone] :: Condition (Maybe a : s) s (a : s) o o
[IsLeft] :: Condition (Either l r : s) (l : s) (r : s) o o
[IsRight] :: Condition (Either l r : s) (r : s) (l : s) o o
[IsCons] :: Condition ([a] : s) (a : ([a] : s)) s o o
[IsNil] :: Condition ([a] : s) s (a : ([a] : s)) o o
[IsZero] :: (UnaryArithOpHs Eq' a, UnaryArithResHs Eq' a ~ Bool) => Condition (a : s) s s o o
[IsNotZero] :: (UnaryArithOpHs Eq' a, UnaryArithResHs Eq' a ~ Bool) => Condition (a : s) s s o o
[IsEq] :: NiceComparable a => Condition (a : (a : s)) s s o o
[IsNeq] :: NiceComparable a => Condition (a : (a : s)) s s o o
[IsLt] :: NiceComparable a => Condition (a : (a : s)) s s o o
[IsGt] :: NiceComparable a => Condition (a : (a : s)) s s o o
[IsLe] :: NiceComparable a => Condition (a : (a : s)) s s o o
[IsGe] :: NiceComparable a => Condition (a : (a : s)) s s o o

-- | Explicitly named binary condition, to ensure proper order of stack
--   arguments.
[NamedBinCondition] :: Condition (a : (a : s)) s s o o -> Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o

-- | Provide the compared arguments to <tt>if</tt> branches.
[PreserveArgsBinCondition] :: (forall st o. Condition (a : (b : st)) st st o o) -> Condition (a : (b : s)) (a : (b : s)) (a : (b : s)) (a : (b : s)) s

-- | Named version of <a>IsLt</a>.
--   
--   In this and similar operators you provide names of accepted stack
--   operands as a safety measure of that they go in the expected order.
(<.) :: NiceComparable a => Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o
infix 4 <.

-- | Named version of <a>IsGt</a>.
(>.) :: NiceComparable a => Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o
infix 4 >.

-- | Named version of <a>IsLe</a>.
(<=.) :: NiceComparable a => Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o
infix 4 <=.

-- | Named version of <a>IsGe</a>.
(>=.) :: NiceComparable a => Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o
infix 4 >=.

-- | Named version of <a>IsEq</a>.
(==.) :: NiceComparable a => Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o
infix 4 ==.

-- | Named version of <a>IsNeq</a>.
(/=.) :: NiceComparable a => Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o
infix 4 /=.

-- | Condition modifier, makes stack operands of binary comparison to be
--   available within <tt>if</tt> branches.
keepIfArgs :: (forall st o. Condition (a : (b : st)) st st o o) -> Condition (a : (b : s)) (a : (b : s)) (a : (b : s)) (a : (b : s)) s

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
fromString :: IsString a => String -> a
fromLabel :: IsLabel x a => a


-- | Autodoc for numeric errors.
module Lorentz.Errors.Numeric.Doc

-- | Adds a section which explains error tag mapping.
data DDescribeErrorTagMap
DDescribeErrorTagMap :: Text -> DDescribeErrorTagMap

-- | Describes where the error tag map is defined in Haskell code.
[detmSrcLoc] :: DDescribeErrorTagMap -> Text

-- | Modify documentation generated for given code so that all
--   <a>CustomError</a> mention not their textual error tag rather
--   respective numeric one from the given map.
--   
--   If some documented error is not present in the map, it remains
--   unmodified. This function may fail with <a>error</a> if contract uses
--   some uncommon errors, see <a>applyErrorTagToErrorsDocWith</a> for
--   details.
applyErrorTagToErrorsDoc :: HasCallStack => ErrorTagMap -> (inp :-> out) -> inp :-> out

-- | Extended version of <a>applyErrorTagToErrorsDoc</a> which accepts
--   error handlers.
--   
--   In most cases that function should be enough for your purposes, but it
--   uses a fixed set of base handlers which may be not enough in case when
--   you define your own errors. In this case define and pass all the
--   necessary handlers to this function.
--   
--   It fails with <a>error</a> if some of the errors used in the contract
--   cannot be handled with given handlers.
applyErrorTagToErrorsDocWith :: HasCallStack => [NumericErrorDocHandler] -> ErrorTagMap -> (inp :-> out) -> inp :-> out

-- | Handler which changes documentation for one particular error type.
data NumericErrorDocHandler

-- | Errors for <a>NumericErrorDocHandler</a>
data NumericErrorDocHandlerError

-- | Handler for all <a>CustomError</a>s.
customErrorDocHandler :: NumericErrorDocHandler

-- | Handler for <a>VoidResult</a>.
voidResultDocHandler :: NumericErrorDocHandler

-- | Handlers for most common errors defined in Lorentz.
baseErrorDocHandlers :: [NumericErrorDocHandler]

-- | Some error with a numeric tag attached.
data NumericErrorWrapper (numTag :: Nat) (err :: Type)
instance GHC.Classes.Ord Lorentz.Errors.Numeric.Doc.DDescribeErrorTagMap
instance GHC.Classes.Eq Lorentz.Errors.Numeric.Doc.DDescribeErrorTagMap
instance (Lorentz.Errors.ErrorHasDoc err, GHC.TypeNats.KnownNat numTag, Lorentz.Errors.Numeric.Doc.ErrorHasNumericDoc err) => Lorentz.Errors.ErrorHasDoc (Lorentz.Errors.Numeric.Doc.NumericErrorWrapper numTag err)
instance Lorentz.Errors.Numeric.Doc.ErrorHasNumericDoc (Lorentz.Errors.CustomError tag)
instance Lorentz.Errors.ErrorHasDoc (Lorentz.Macro.VoidResult res) => Lorentz.Errors.Numeric.Doc.ErrorHasNumericDoc (Lorentz.Macro.VoidResult res)
instance Lorentz.Errors.ErrorHasDoc Lorentz.Errors.Numeric.Doc.NumericTextError
instance Michelson.Doc.DocItem Lorentz.Errors.Numeric.Doc.DDescribeErrorTagMap

module Lorentz.Errors.Numeric


-- | Mirrors <a>Integrational</a> module in a Lorentz way.
module Lorentz.Test.Integrational

-- | Data associated with a particular transaction.
data TxData
TxData :: Address -> Value -> EpName -> Mutez -> TxData
[tdSenderAddress] :: TxData -> Address
[tdParameter] :: TxData -> Value
[tdEntrypoint] :: TxData -> EpName
[tdAmount] :: TxData -> Mutez

-- | Initially these addresses have a lot of money.
genesisAddresses :: NonEmpty Address

-- | One of genesis addresses.
genesisAddress :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress1 :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress2 :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress3 :: Address
genesisAddress4 :: Address
genesisAddress5 :: Address
genesisAddress6 :: Address

-- | Like <a>originate</a>, but for typed contract and value.
tOriginate :: (ParameterScope cp, StorageScope st) => FullContract cp st -> Text -> Value st -> Mutez -> IntegrationalScenarioM Address

-- | Similar to <a>transfer</a>, for typed values. Note that it works with
--   untyped <a>Address</a> and does not check that entrypoint with given
--   name is present and has the expected type. Passed value must
--   correspond to the entrypoint argument type, not the parameter type of
--   the contract (and must be unit for implicit accounts).
tTransfer :: ParameterScope arg => ("from" :! Address) -> ("to" :! Address) -> Mutez -> EpName -> Value arg -> IntegrationalScenarioM ()

-- | Similar to <a>expectStorageConst</a>, for typed stuff.
tExpectStorageConst :: StorageScope st => Address -> Value st -> SuccessValidator

-- | Validator for integrational testing. If an error is expected, it
--   should be <a>Left</a> with validator for errors. Otherwise it should
--   check final global state and its updates.
type IntegrationalValidator = Either ExecutorError -> Bool SuccessValidator

-- | Validator for integrational testing that expects successful execution.
type SuccessValidator = InternalState -> GState -> [GStateUpdate] -> Either ValidationError ()

-- | A monad inside which integrational tests can be described using
--   do-notation.
type IntegrationalScenarioM = StateT InternalState Except ScenarioError
type IntegrationalScenario = IntegrationalScenarioM Validated
data ValidationError
UnexpectedExecutorError :: IntegrationalExecutorError -> ValidationError
UnexpectedTypeCheckError :: TCError -> ValidationError
ExpectingInterpreterToFail :: ValidationError
IncorrectUpdates :: ValidationError -> [GStateUpdate] -> ValidationError
IncorrectStorageUpdate :: AddressName -> Text -> ValidationError
InvalidStorage :: AddressName -> ExpectedStorage -> Text -> ValidationError
StoragePredicateMismatch :: AddressName -> Text -> ValidationError
InvalidBalance :: AddressName -> ExpectedBalance -> Text -> ValidationError
UnexpectedUpdates :: NonEmpty GStateUpdate -> ValidationError
CustomValidationError :: Text -> ValidationError

-- | Integrational test that executes given operations and validates them
--   using given validator. It can fail using <a>Expectation</a>
--   capability. It starts with <a>initGState</a> and some reasonable dummy
--   values for gas limit and current timestamp. You can update blockchain
--   state by performing some operations.
integrationalTestExpectation :: HasCallStack -> IntegrationalScenario -> Expectation

-- | Integrational test similar to <a>integrationalTestExpectation</a>. It
--   can fail using <a>Property</a> capability. It can be used with
--   QuickCheck's <tt>forAll</tt> to make a property-based test with
--   arbitrary data.
integrationalTestProperty :: IntegrationalScenario -> Property

-- | Like <a>originate</a>, but for Lorentz contracts.
lOriginate :: forall cp st. (NiceParameterFull cp, NiceStorage st) => ContractCode cp st -> Text -> st -> Mutez -> IntegrationalScenarioM (TAddress cp)

-- | Originate a contract with empty balance and default storage.
lOriginateEmpty :: (NiceParameterFull cp, NiceStorage st, Default st) => ContractCode cp st -> Text -> IntegrationalScenarioM (TAddress cp)

-- | Similar to <a>transfer</a>, for Lorentz values.
lTransfer :: forall cp epRef epArg addr. (HasEntryPointArg cp epRef epArg, IsoValue epArg, ToTAddress cp addr) => ("from" :! Address) -> ("to" :! addr) -> Mutez -> epRef -> epArg -> IntegrationalScenarioM ()

-- | Legacy version of <a>lCallEP</a> function. Calls default entrypoint of
--   a contract assuming its argument is the same as contract parameter
--   (which is equivalent to absence of explicit default entrypoint).
--   
--   This function is DEPRECATED and exists only for backwards
--   compatibility.

-- | <i>Deprecated: <a>lCall</a> will likely be replaced with
--   <a>lCallEP</a> in future version</i>
lCall :: forall cp defEpName addr. (HasDefEntryPointArg cp defEpName cp, IsoValue cp, ToTAddress cp addr) => addr -> cp -> IntegrationalScenarioM ()

-- | Call an entrypoint of a contract without caring about the source
--   address. Transfers 0 mutez.
lCallEP :: forall cp epRef epArg addr. (HasEntryPointArg cp epRef epArg, IsoValue epArg, ToTAddress cp addr) => addr -> epRef -> epArg -> IntegrationalScenarioM ()

-- | Which entrypoint to call.
--   
--   We intentionally distinguish default and non-default cases because
--   this makes API more details-agnostic.
data EntryPointRef (mname :: Maybe Symbol)

-- | Call the default entrypoint, or root if no explicit default is
--   assigned.
[CallDefault] :: EntryPointRef  'Nothing

-- | Call the given entrypoint; calling default is not treated specially.
--   You have to provide entrypoint name via passing it as type argument.
--   
--   Unfortunatelly, here we cannot accept a label because in most cases
--   our entrypoints begin from capital letter (being derived from
--   constructor name), while labels must start from a lower-case letter,
--   and there is no way to make a conversion at type-level.
[Call] :: NiceEntryPointName name => EntryPointRef ( 'Just name)

-- | <a>lCallEP</a> for default entrypoint.
lCallDef :: forall cp defEpName defArg addr. (HasDefEntryPointArg cp defEpName defArg, IsoValue defArg, ToTAddress cp addr) => addr -> defArg -> IntegrationalScenarioM ()

-- | Validate the execution result.
validate :: IntegrationalValidator -> IntegrationalScenario

-- | Just fail with given error.
integrationalFail :: () => ValidationError -> IntegrationalScenarioM anything

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given gas limit.
setMaxSteps :: RemainingSteps -> IntegrationalScenarioM ()

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given timestamp as the current one.
setNow :: Timestamp -> IntegrationalScenarioM ()

-- | Increase current time by the given number of seconds.
rewindTime :: Integer -> IntegrationalScenarioM ()

-- | Pretend that given address initiates all the transfers within the code
--   block (i.e. <tt>SENDER</tt> instruction will return this address).
withSender :: () => Address -> IntegrationalScenarioM a -> IntegrationalScenarioM a

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given chain id.
setChainId :: ChainId -> IntegrationalScenarioM ()

-- | Execute multiple testing scenarios independently, basing them on
--   scenario built till this point.
--   
--   The following property holds for this function:
--   
--   <tt> pre &gt;&gt; branchout [a, b, c] = branchout [pre &gt;&gt; a, pre
--   &gt;&gt; b, pre &gt;&gt; c] </tt>.
--   
--   In case of property failure in one of the branches no following branch
--   is executed.
--   
--   Providing empty list of scenarios to this function causes error; we do
--   not require <a>NonEmpty</a> here though for convenience.
branchout :: HasCallStack -> [(Text, IntegrationalScenario)] -> IntegrationalScenario

-- | Make a tuple with name without extra syntactic noise.
(?-) :: () => Text -> a -> (Text, a)
infixr 0 ?-

-- | Test given scenario with the state gathered till this moment; if this
--   scenario passes, go on as if it never happened.
offshoot :: Text -> IntegrationalScenario -> IntegrationalScenarioM ()

-- | Compose two success validators.
--   
--   For example:
--   
--   expectBalance bal addr <a>composeValidators</a>
--   expectStorageUpdateConst addr2 ValueUnit
composeValidators :: SuccessValidator -> SuccessValidator -> SuccessValidator

-- | Compose a list of success validators.
composeValidatorsList :: [SuccessValidator] -> SuccessValidator

-- | <a>SuccessValidator</a> that always passes.
expectAnySuccess :: SuccessValidator

-- | Check that there were no updates.
expectNoUpdates :: SuccessValidator

-- | Check that there were no storage updates.
expectNoStorageUpdates :: SuccessValidator

-- | Similar to <a>expectStorageUpdate</a>, but for Lorentz values.
lExpectStorageUpdate :: forall st addr. (NiceStorage st, ToAddress addr, HasCallStack) => addr -> (st -> Either ValidationError ()) -> SuccessValidator

-- | Like <a>expectBalance</a>, for Lorentz values.
lExpectBalance :: ToAddress addr => addr -> Mutez -> SuccessValidator

-- | Similar to <a>expectStorage</a>, but for Lorentz values.
lExpectStorage :: forall st addr. (NiceStorage st, ToAddress addr, HasCallStack) => addr -> (st -> Either ValidationError ()) -> SuccessValidator

-- | Similar to <a>expectStorageConst</a>, for Lorentz values.
lExpectStorageConst :: forall st addr. (NiceStorage st, ToAddress addr) => addr -> st -> SuccessValidator

-- | Expect that interpretation of contract with given address ended with
--   [FAILED].
lExpectMichelsonFailed :: forall addr. ToAddress addr => (MichelsonFailed -> Bool) -> addr -> ExecutorError -> Bool

-- | Expect contract to fail with <a>FAILWITH</a> instruction and provided
--   value to match against the given predicate.
lExpectFailWith :: forall e. (Typeable (ToT e), IsoValue e) => (e -> Bool) -> ExecutorError -> Bool

-- | Expect contract to fail with given error.
lExpectError :: forall e. IsError e => (e -> Bool) -> ExecutorError -> Bool

-- | Version of <a>lExpectError</a> for the case when numeric
--   representation of errors is used.
lExpectErrorNumeric :: forall e. IsError e => ErrorTagMap -> (e -> Bool) -> ExecutorError -> Bool

-- | Expect contract to fail with given <tt>CustomError</tt>.
lExpectCustomError :: forall tag arg. (IsError (CustomError tag), arg ~ ErrorArg tag, Eq arg) => Label tag -> arg -> ExecutorError -> Bool

-- | Version of <a>lExpectCustomError</a> for the case when numeric
--   representation of errors is used.
lExpectCustomErrorNumeric :: forall tag arg. (IsError (CustomError tag), arg ~ ErrorArg tag, Eq arg) => ErrorTagMap -> Label tag -> arg -> ExecutorError -> Bool

-- | Specialization of <a>lExpectCustomError</a> for non-arg error case.
lExpectCustomError_ :: forall tag. (IsError (CustomError tag), ErrorArg tag ~ ()) => Label tag -> ExecutorError -> Bool

-- | Version of <a>lExpectCustomError_</a> for the case when numeric
--   representation of errors is used.
lExpectCustomErrorNumeric_ :: forall tag. (IsError (CustomError tag), ErrorArg tag ~ ()) => ErrorTagMap -> Label tag -> ExecutorError -> Bool

-- | Version of <a>lExpectStorageUpdate</a> specialized to "consumer"
--   contract (see <a>contractConsumer</a>).
lExpectConsumerStorage :: forall cp st addr. (st ~ [cp], NiceStorage st, ToTAddress cp addr) => addr -> (st -> Either ValidationError ()) -> SuccessValidator

-- | Assuming that "consumer" contract receives a value from <tt>View</tt>,
--   expect this view return value to be the given one.
--   
--   Despite consumer stores parameters it was called with in reversed
--   order, this function cares about it, so you should provide a list of
--   expected values in the same order in which the corresponding events
--   were happenning.
lExpectViewConsumerStorage :: (st ~ [cp], Eq cp, Buildable cp, NiceStorage st, ToTAddress cp addr) => addr -> [cp] -> SuccessValidator


-- | This module contains implementation of <a>Extensible</a> values.
--   
--   <tt>Extensible</tt> values are an alternative representation of
--   sum-types for Michelson. Instead of representing them as nested
--   options, we treat them as (Natural, ByteString) pair, where the first
--   element of the pair represents the constructor index, while the second
--   is a packed argument.
--   
--   With such a representation sum types can be easily upgraded: it is
--   possible to add new elements to the sum type, and the representation
--   would not change.
--   
--   However, such representation essentially limits the applicability of
--   the values. This module does not provide Michelson-level function to
--   unwrap the value because it would require traversing all the possible
--   options in the contract code. While this is possible, it is very
--   inefficient. Up to this moment, we have not come up with a decent
--   reason to allow such behavior, so Extensible types are write-only in
--   Michelson code. They can be unwrapped off-chain with
--   <tt>fromExtVal</tt>.
--   
--   In order to preserve previous values during migrations, users should
--   ONLY APPEND items to the underlying sum type. Changing, reordering and
--   deleting items is not allowed and would lead to compatibility
--   breakage. Currently, this restriction in not enforced. Only
--   no-argument and one-argument constructors are supported.
--   
--   GOOD: -- `Extensible GoodSumTypeV1` is backwards compatible -- with
--   `Extensible GoodSumTypeV2` data GoodSumTypeV1 = A Natural | B data
--   GoodSumTypeV2 = A Natural | B | C MText
--   
--   BAD: -- `Extensible BadSumTypeV1` is NOT backwards compatible -- with
--   `Extensible BadSumTypeV2` data BadSumTypeV1 = A | B data BadSumTypeV2
--   = A Natural | B | C MText
module Lorentz.Extensible
newtype Extensible x
Extensible :: (Natural, ByteString) -> Extensible x

-- | Errors related to fromExtVal conversion
data ExtConversionError
ConstructorIndexNotFound :: Natural -> ExtConversionError
ArgumentUnpackFailed :: ExtConversionError
type ExtVal x = (Generic x, GExtVal x (Rep x))

-- | Information to be provided for documenting some <tt><a>Extensible</a>
--   x</tt>.
class Typeable x => ExtensibleHasDoc x

-- | Implementation for <a>typeDocName</a> of the corresponding
--   <tt>Extensible</tt>.
extensibleDocName :: ExtensibleHasDoc x => Proxy x -> Text

-- | Implementation for <a>typeDocDependencies</a> of the corresponding
--   <tt>Extensible</tt>.
extensibleDocDependencies :: ExtensibleHasDoc x => Proxy x -> [SomeTypeWithDoc]

-- | Implementation for <a>typeDocDependencies</a> of the corresponding
--   <tt>Extensible</tt>.
extensibleDocDependencies :: (ExtensibleHasDoc x, Generic x, GTypeHasDoc (Rep x)) => Proxy x -> [SomeTypeWithDoc]

-- | Overall description of this type.
extensibleDocMdDescription :: ExtensibleHasDoc x => Markdown

-- | Converts a value from a Haskell representation to its extensible
--   Michelson representation (i.e. (Natural, Bytestring) pair).
toExtVal :: ExtVal a => a -> Extensible a

-- | Converts a value from an extensible Michelson representation to its
--   Haskell sum-type representation. Fails if the Michelson representation
--   points to a nun-existent constructor, or if we failed to unpack the
--   argument.
fromExtVal :: ExtVal a => Extensible a -> Either ExtConversionError a

-- | Wraps an argument on top of the stack into an Extensible
--   representation
wrapExt :: forall t (n :: Nat) name field s. WrapExtC t n name field s => Label ("c" `AppendSymbol` name) -> AppendCtorField field s :-> (Extensible t : s)
type WrapExtC t n name field s = ( 'Ctor n name field ~ LookupCtor name (EnumerateCtors (GetCtors t)), WrapExt field, KnownNat n)
instance GHC.Show.Show Lorentz.Extensible.ExtConversionError
instance GHC.Classes.Eq Lorentz.Extensible.ExtConversionError
instance forall k (x :: k). Lorentz.TypeAnns.HasTypeAnn (Lorentz.Extensible.Extensible x)
instance forall k (x :: k). Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Extensible.Extensible x)
instance forall k (x :: k). GHC.Show.Show (Lorentz.Extensible.Extensible x)
instance forall k (x :: k). GHC.Classes.Eq (Lorentz.Extensible.Extensible x)
instance forall k (x :: k). GHC.Generics.Generic (Lorentz.Extensible.Extensible x)
instance (GHC.TypeNats.KnownNat pos, GHC.TypeLits.KnownSymbol name, Michelson.Typed.Haskell.Doc.TypeHasDoc param, param Data.Type.Equality.~ Michelson.Typed.Haskell.Instr.Sum.ExtractCtorField field) => Lorentz.Extensible.DocumentCtor ('Lorentz.Extensible.Ctor pos name field)
instance (Lorentz.Extensible.ExtensibleHasDoc x, Util.Type.ReifyList Lorentz.Extensible.DocumentCtor (Lorentz.Extensible.EnumerateCtors (Lorentz.Extensible.GetCtors x))) => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Extensible.Extensible x)
instance forall k (t :: k) (x :: * -> *) (i :: GHC.Generics.Meta). Lorentz.Extensible.GExtVal t x => Lorentz.Extensible.GExtVal t (GHC.Generics.D1 i x)
instance ('Lorentz.Extensible.Ctor n name 'Michelson.Typed.Haskell.Instr.Sum.NoFields Data.Type.Equality.~ Lorentz.Extensible.LookupCtor name (Lorentz.Extensible.EnumerateCtors (Lorentz.Extensible.GetCtors t)), GHC.TypeNats.KnownNat n) => Lorentz.Extensible.GExtVal t (GHC.Generics.C1 ('GHC.Generics.MetaCons name _1 _2) GHC.Generics.U1)
instance (Lorentz.Constraints.Scopes.NiceFullPackedValue param, 'Lorentz.Extensible.Ctor n name ('Michelson.Typed.Haskell.Instr.Sum.OneField param) Data.Type.Equality.~ Lorentz.Extensible.LookupCtor name (Lorentz.Extensible.EnumerateCtors (Lorentz.Extensible.GetCtors t)), GHC.TypeNats.KnownNat n) => Lorentz.Extensible.GExtVal t (GHC.Generics.C1 ('GHC.Generics.MetaCons name _1 _2) (GHC.Generics.S1 _3 (GHC.Generics.Rec0 param)))
instance forall k (t :: k) (x :: * -> *) (y :: * -> *). (Lorentz.Extensible.GExtVal t x, Lorentz.Extensible.GExtVal t y) => Lorentz.Extensible.GExtVal t (x GHC.Generics.:+: y)
instance Formatting.Buildable.Buildable Lorentz.Extensible.ExtConversionError
instance Lorentz.Constraints.Scopes.NicePackedValue param => Lorentz.Extensible.WrapExt ('Michelson.Typed.Haskell.Instr.Sum.OneField param)
instance Lorentz.Extensible.WrapExt 'Michelson.Typed.Haskell.Instr.Sum.NoFields
instance forall k (x :: k). Control.Lens.Wrapped.Wrapped (Lorentz.Extensible.Extensible x)

module Lorentz.ADT

-- | Allows field access and modification.
type HasField dt fname = (InstrGetFieldC dt fname, InstrSetFieldC dt fname)

-- | Like <a>HasField</a>, but allows constrainting field type.
type HasFieldOfType dt fname fieldTy = (HasField dt fname, GetFieldType dt fname ~ fieldTy)

-- | Shortcut for multiple <a>HasFieldOfType</a> constraints.
type family HasFieldsOfType (dt :: Type) (fs :: [NamedField]) :: Constraint

-- | A pair of field name and type.
data NamedField
NamedField :: Symbol -> Type -> NamedField
type n := ty =  'NamedField n ty
infixr 0 :=

-- | Extract a field of a datatype replacing the value of this datatype
--   with the extracted field.
--   
--   For this and the following functions you have to specify field name
--   which is either record name or name attached with <tt>(:!)</tt>
--   operator.
toField :: forall dt name st. InstrGetFieldC dt name => Label name -> (dt & st) :-> (GetFieldType dt name & st)

-- | Like <a>toField</a>, but leaves field named.
toFieldNamed :: forall dt name st. InstrGetFieldC dt name => Label name -> (dt & st) :-> ((name :! GetFieldType dt name) & st)

-- | Extract a field of a datatype, leaving the original datatype on stack.
getField :: forall dt name st. InstrGetFieldC dt name => Label name -> (dt & st) :-> (GetFieldType dt name & (dt : st))

-- | Like <a>getField</a>, but leaves field named.
getFieldNamed :: forall dt name st. InstrGetFieldC dt name => Label name -> (dt & st) :-> ((name :! GetFieldType dt name) & (dt : st))

-- | Set a field of a datatype.
setField :: forall dt name st. InstrSetFieldC dt name => Label name -> (GetFieldType dt name : (dt : st)) :-> (dt : st)

-- | Apply given modifier to a datatype field.
modifyField :: forall dt name st. (InstrGetFieldC dt name, InstrSetFieldC dt name) => Label name -> (forall st0. (GetFieldType dt name : st0) :-> (GetFieldType dt name : st0)) -> (dt & st) :-> (dt & st)

-- | Make up a datatype. You provide a pack of individual fields
--   constructors.
--   
--   Each element of the accepted record should be an instruction wrapped
--   with <a>fieldCtor</a> function. This instruction will have access to
--   the stack at the moment of calling <tt>construct</tt>. Instructions
--   have to output fields of the built datatype, one per instruction;
--   instructions order is expected to correspond to the order of fields in
--   the datatype.
construct :: forall dt st. (InstrConstructC dt, RMap (ConstructorFieldTypes dt)) => Rec (FieldConstructor st) (ConstructorFieldTypes dt) -> st :-> (dt & st)

-- | Version of <a>construct</a> which accepts tuple of field constructors.
constructT :: forall dt fctors st. (InstrConstructC dt, RMap (ConstructorFieldTypes dt), fctors ~ Rec (FieldConstructor st) (ConstructorFieldTypes dt), RecFromTuple fctors) => IsoRecTuple fctors -> st :-> (dt & st)

-- | Lift an instruction to field constructor.
fieldCtor :: HasCallStack => (st :-> (f & st)) -> FieldConstructor st f

-- | Wrap entry in constructor. Useful for sum types.
wrap_ :: forall dt name st. InstrWrapC dt name => Label name -> AppendCtorField (GetCtorField dt name) st :-> (dt & st)

-- | Pattern match on the given sum type.
--   
--   You have to provide a <a>Rec</a> containing case branches. To
--   construct a case branch use <a>/-&gt;</a> operator.
case_ :: forall dt out inp. (InstrCaseC dt inp out, RMap (CaseClauses dt)) => Rec (CaseClauseL inp out) (CaseClauses dt) -> (dt & inp) :-> out

-- | Like <a>case_</a>, accepts a tuple of clauses, which may be more
--   convenient.
--   
--   If user is experiencing problems with wierd errors about tuples while
--   using this function, he should take look at <a>Instances</a> and
--   ensure that his tuple isn't bigger than generated instances, if so, he
--   should probably extend number of generated instances.
caseT :: forall dt out inp clauses. CaseTC dt out inp clauses => IsoRecTuple clauses -> (dt & inp) :-> out

-- | Wrap entry in constructor. Useful for sum types.
unwrapUnsafe_ :: forall dt name st. InstrUnwrapC dt name => Label name -> (dt & st) :-> (CtorOnlyField name dt : st)
type CaseTC dt out inp clauses = (InstrCaseC dt inp out, RMap (CaseClauses dt), RecFromTuple clauses, clauses ~ Rec (CaseClauseL inp out) (CaseClauses dt))

-- | Provides "case" arrow which works on different wrappers for clauses.
class CaseArrow name body clause | clause -> name, clause -> body

-- | Lift an instruction to case clause.
--   
--   You should write out constructor name corresponding to the clause
--   explicitly. Prefix constructor name with "c" letter, otherwise your
--   label will not be recognized by Haskell parser. Passing constructor
--   name can be circumvented but doing so is not recomended as mentioning
--   contructor name improves readability and allows avoiding some
--   mistakes.
(/->) :: CaseArrow name body clause => Label name -> body -> clause
infixr 0 /->

-- | Lorentz analogy of <a>CaseClause</a>, it works on plain <a>Type</a>
--   types.
data CaseClauseL (inp :: [Type]) (out :: [Type]) (param :: CaseClauseParam)
[CaseClauseL] :: (AppendCtorField x inp :-> out) -> CaseClauseL inp out ( 'CaseClauseParam ctor x)

-- | Constraint for <a>instrConstruct</a>.
type InstrConstructC dt = (GenericIsoValue dt, GInstrConstruct Rep dt)

-- | Types of all fields in a datatype.
type ConstructorFieldTypes dt = GFieldTypes Rep dt

-- | A record is parameterized by a universe <tt>u</tt>, an interpretation
--   <tt>f</tt> and a list of rows <tt>rs</tt>. The labels or indices of
--   the record are given by inhabitants of the kind <tt>u</tt>; the type
--   of values at any label <tt>r :: u</tt> is given by its interpretation
--   <tt>f r :: *</tt>.
data Rec (a :: u -> Type) (b :: [u]) :: forall u. () => u -> Type -> [u] -> Type
[RNil] :: forall u (a :: u -> Type) (b :: [u]). () => Rec a ([] :: [u])
[:&] :: forall u (a :: u -> Type) (b :: [u]) (r :: u) (rs :: [u]). () => !a r -> !Rec a rs -> Rec a (r : rs)
infixr 7 :&

-- | Infix notation for the type of a named parameter.
type (:!) (name :: Symbol) a = NamedF Identity a name

-- | Infix notation for the type of an optional named parameter.
type (:?) (name :: Symbol) a = NamedF Maybe a name

-- | <a>arg</a> unwraps a named parameter with the specified name. One way
--   to use it is to match on arguments with <tt>-XViewPatterns</tt>:
--   
--   <pre>
--   fn (arg #t -&gt; t) (arg #f -&gt; f) = ...
--   </pre>
--   
--   This way, the names of parameters can be inferred from the patterns:
--   no type signature for <tt>fn</tt> is required. In case a type
--   signature for <tt>fn</tt> is provided, the parameters must come in the
--   same order:
--   
--   <pre>
--   fn :: "t" :! Integer -&gt; "f" :! Integer -&gt; ...
--   fn (arg #t -&gt; t) (arg #f -&gt; f) = ... -- ok
--   fn (arg #f -&gt; f) (arg #t -&gt; t) = ... -- does not typecheck
--   </pre>
arg :: () => Name name -> (name :! a) -> a

-- | A variation of <a>arg</a> for optional arguments. Requires a default
--   value to handle the case when the optional argument was omitted:
--   
--   <pre>
--   fn (argDef #answer 42 -&gt; ans) = ...
--   </pre>
--   
--   In case you want to get a value wrapped in <a>Maybe</a> instead, use
--   <a>argF</a> or <a>ArgF</a>.
argDef :: () => Name name -> a -> (name :? a) -> a

-- | <a>argF</a> is similar to <a>arg</a>: it unwraps a named parameter
--   with the specified name. The difference is that the result of
--   <a>argF</a> is inside an arity wrapper, which is <a>Identity</a> for
--   normal parameters and <a>Maybe</a> for optional parameters.
argF :: () => Name name -> NamedF f a name -> f a
instance (name Data.Type.Equality.~ GHC.TypeLits.AppendSymbol "c" ctor, body Data.Type.Equality.~ (Michelson.Typed.Haskell.Instr.Sum.AppendCtorField x inp Lorentz.Base.:-> out)) => Lorentz.ADT.CaseArrow name body (Lorentz.ADT.CaseClauseL inp out ('Michelson.Typed.Haskell.Instr.Sum.CaseClauseParam ctor x))


-- | This module provides storage interfaces.
module Lorentz.StoreClass

-- | Provides operations on fields for storage.
class StoreHasField store fname ftype | store fname -> ftype
storeFieldOps :: StoreHasField store fname ftype => StoreFieldOps store fname ftype

-- | Datatype containing the full implementation of <a>StoreHasField</a>
--   typeclass.
--   
--   We use this grouping because in most cases implementation will be
--   chosen among the default ones, and initializing all methods at once is
--   simpler and more consistent. (One can say that we are trying to
--   emulate benefits of <tt>DerivingVia</tt> extension.)
data StoreFieldOps store fname ftype
StoreFieldOps :: (forall s. Label fname -> (store : s) :-> (ftype : s)) -> (forall s. Label fname -> (ftype : (store : s)) :-> (store : s)) -> StoreFieldOps store fname ftype
[sopToField] :: StoreFieldOps store fname ftype -> forall s. Label fname -> (store : s) :-> (ftype : s)
[sopSetField] :: StoreFieldOps store fname ftype -> forall s. Label fname -> (ftype : (store : s)) :-> (store : s)

-- | Provides operations on fields for storage.
class StoreHasSubmap store mname key value | store mname -> key value
storeSubmapOps :: StoreHasSubmap store mname key value => StoreSubmapOps store mname key value

-- | Datatype containing the full implementation of <a>StoreHasField</a>
--   typeclass.
--   
--   We use this grouping because in most cases implementation will be
--   chosen among the default ones, and initializing all methods at once is
--   simpler and more consistent. (One can say that we are trying to
--   emulate <tt>DerivingVia</tt> extension.)
data StoreSubmapOps store mname key value
StoreSubmapOps :: (forall s. Label mname -> (key : (store : s)) :-> (Bool : s)) -> (forall s. Label mname -> (key : (store : s)) :-> (Maybe value : s)) -> (forall s. Label mname -> (key : (Maybe value : (store : s))) :-> (store : s)) -> (forall s. Maybe (Label mname -> (key : (store : s)) :-> (store : s))) -> (forall s. Maybe (Label mname -> (key : (value : (store : s))) :-> (store : s))) -> StoreSubmapOps store mname key value
[sopMem] :: StoreSubmapOps store mname key value -> forall s. Label mname -> (key : (store : s)) :-> (Bool : s)
[sopGet] :: StoreSubmapOps store mname key value -> forall s. Label mname -> (key : (store : s)) :-> (Maybe value : s)
[sopUpdate] :: StoreSubmapOps store mname key value -> forall s. Label mname -> (key : (Maybe value : (store : s))) :-> (store : s)
[sopDelete] :: StoreSubmapOps store mname key value -> forall s. Maybe (Label mname -> (key : (store : s)) :-> (store : s))
[sopInsert] :: StoreSubmapOps store mname key value -> forall s. Maybe (Label mname -> (key : (value : (store : s))) :-> (store : s))

-- | Indicates a submap with given key and value types.
data k ~> v
infix 9 ~>

-- | Concise way to write down constraints with expected content of a
--   storage.
--   
--   Use it like follows:
--   
--   <pre>
--   type StorageConstraint = StorageContains
--     [ "fieldInt" := Int
--     , "fieldNat" := Nat
--     , "balances" := Address ~&gt; Int
--     ]
--   </pre>
type family StorageContains store (content :: [NamedField]) :: Constraint

-- | Pick storage field.
stToField :: StoreHasField store fname ftype => Label fname -> (store : s) :-> (ftype : s)

-- | Get storage field, preserving the storage itself on stack.
stGetField :: StoreHasField store fname ftype => Label fname -> (store : s) :-> (ftype : (store : s))

-- | Update storage field.
stSetField :: StoreHasField store fname ftype => Label fname -> (ftype : (store : s)) :-> (store : s)

-- | Check value presence in storage.
stMem :: StoreHasSubmap store mname key value => Label mname -> (key : (store : s)) :-> (Bool : s)

-- | Get value in storage.
stGet :: StoreHasSubmap store mname key value => Label mname -> (key : (store : s)) :-> (Maybe value : s)

-- | Update a value in storage.
stUpdate :: StoreHasSubmap store mname key value => Label mname -> (key : (Maybe value : (store : s))) :-> (store : s)

-- | Delete a value in storage.
stDelete :: forall store mname key value s. (StoreHasSubmap store mname key value, KnownValue value) => Label mname -> (key : (store : s)) :-> (store : s)

-- | Add a value in storage.
stInsert :: StoreHasSubmap store mname key value => Label mname -> (key : (value : (store : s))) :-> (store : s)

-- | Add a value in storage, but fail if it will overwrite some existing
--   entry.
stInsertNew :: StoreHasSubmap store mname key value => Label mname -> (forall s0 any. (key : s0) :-> any) -> (key : (value : (store : s))) :-> (store : s)

-- | Implementation of <a>StoreHasField</a> for case of datatype keeping a
--   pack of fields.
storeFieldOpsADT :: HasFieldOfType dt fname ftype => StoreFieldOps dt fname ftype

-- | Implementation of <a>StoreHasField</a> for a data type which has an
--   instance of <a>StoreHasField</a> inside. For instance, it can be used
--   for top-level storage.
storeFieldOpsDeeper :: (HasFieldOfType storage fieldsPartName fields, StoreHasField fields fname ftype) => Label fieldsPartName -> StoreFieldOps storage fname ftype

-- | Implementation of <a>StoreHasSubmap</a> for a data type which has an
--   instance of <a>StoreHasSubmap</a> inside. For instance, it can be used
--   for top-level storage.
storeSubmapOpsDeeper :: (HasFieldOfType storage bigMapPartName fields, StoreHasSubmap fields mname key value) => Label bigMapPartName -> StoreSubmapOps storage mname key value

-- | Pretend that given <a>StoreSubmapOps</a> implementation is made up for
--   submap with name <tt>desiredName</tt>, not its actual name. Logic of
--   the implementation remains the same.
--   
--   See also <a>storeSubmapOpsReferTo</a>.
storeFieldOpsReferTo :: Label name -> StoreFieldOps storage name field -> StoreFieldOps storage desiredName field

-- | Pretend that given <a>StoreSubmapOps</a> implementation is made up for
--   submap with name <tt>desiredName</tt>, not its actual name. Logic of
--   the implementation remains the same.
--   
--   Use case: imagine that your code requires access to submap named
--   <tt>X</tt>, but in your storage that submap is called <tt>Y</tt>. Then
--   you implement the instance which makes <tt>X</tt> refer to <tt>Y</tt>:
--   
--   <pre>
--   instance StoreHasSubmap Store X Key Value where
--     storeSubmapOps = storeSubmapOpsReferTo #Y storeSubmapOpsForY
--   </pre>
storeSubmapOpsReferTo :: Label name -> StoreSubmapOps storage name key value -> StoreSubmapOps storage desiredName key value

-- | Chain two implementations of field operations.
--   
--   Suits for a case when your store does not contain its fields directly
--   rather has a nested structure.
composeStoreFieldOps :: Label nameInStore -> StoreFieldOps store nameInStore substore -> StoreFieldOps substore nameInSubstore field -> StoreFieldOps store nameInSubstore field

-- | Chain implementations of field and submap operations.
composeStoreSubmapOps :: Label nameInStore -> StoreFieldOps store nameInStore substore -> StoreSubmapOps substore mname key value -> StoreSubmapOps store mname key value
instance (key Data.Type.Equality.~ key', value Data.Type.Equality.~ value', Michelson.Typed.Haskell.Value.IsComparable key) => Lorentz.StoreClass.StoreHasSubmap (Michelson.Typed.Haskell.Value.BigMap key' value') name key value
instance (key Data.Type.Equality.~ key', value Data.Type.Equality.~ value', Michelson.Typed.Haskell.Value.IsComparable key) => Lorentz.StoreClass.StoreHasSubmap (Data.Map.Internal.Map key' value') name key value

module Lorentz.UStore.Instances
instance Lorentz.UStore.Instr.HasUField fname ftype templ => Lorentz.StoreClass.StoreHasField (Lorentz.UStore.Types.UStore templ) fname ftype
instance Lorentz.UStore.Instr.HasUStore mname key value templ => Lorentz.StoreClass.StoreHasSubmap (Lorentz.UStore.Types.UStore templ) mname key value


-- | This module contains implementation of <a>UStore</a>.
--   
--   <tt>UStore</tt> is essentially <a>Store</a> modified for the sake of
--   upgradeability.
--   
--   In API it differs from <tt>Store</tt> in the following ways: 1. It
--   keeps both virtual <tt>big_map</tt>s and plain fields; 2. Neat
--   conversion between Michelson and Haskell values is implemented; 3.
--   Regarding composabililty, one can operate with one <tt>UStore</tt> and
--   then lift it to a bigger one which includes the former. This allows
--   for simpler management of stores and clearer error messages. In spite
--   of this, operations with <a>UStore</a>s over deeply nested templates
--   will still work as before.
--   
--   We represent <a>UStore</a> as <tt>big_map bytes bytes</tt>.
--   
--   <ul>
--   <li>Plain fields are stored as <tt>key = pack fieldName; value = pack
--   originalValue</tt>.</li>
--   <li>Virtual <tt>big_map</tt>s are kept as <tt>key = pack (bigMapName,
--   originalKey); value = pack originalValue</tt>.</li>
--   </ul>
module Lorentz.UStore

-- | Gathers multple fields and <a>BigMap</a>s under one object.
--   
--   Type argument of this datatype stands for a "store template" - a
--   datatype with one constructor and multiple fields, each containing an
--   object of type <a>UStoreFieldExt</a> or <a>|~&gt;</a> and
--   corresponding to single virtual field or <a>BigMap</a> respectively.
--   It's also possible to parameterize it with a larger type which is a
--   product of types satisfying the above property.
data UStore (a :: Type)

-- | Describes one virtual big map in the storage.
newtype k |~> v
UStoreSubMap :: Map k v -> (|~>) k v
[unUStoreSubMap] :: (|~>) k v -> Map k v

-- | Describes plain field in the storage.
newtype UStoreFieldExt (m :: UStoreMarkerType) (v :: Type)
UStoreField :: v -> UStoreFieldExt
[unUStoreField] :: UStoreFieldExt -> v

-- | Just a plain field used as data.
type UStoreField = UStoreFieldExt UMarkerPlainField

-- | Specific kind used to designate markers for <a>UStoreFieldExt</a>.
--   
--   We suggest that fields may serve different purposes and so annotated
--   with special markers accordingly. See example below.
--   
--   This kind is implemented like that because we want markers to differ
--   from all other types in kind; herewith <a>UStoreMarkerType</a> is
--   still an open kind (has potentially infinite number of inhabitants).
type UStoreMarkerType = UStoreMarker -> Type

-- | Allows to specify format of key under which fields of this type are
--   stored. Useful to avoid collisions.
class KnownUStoreMarker (marker :: UStoreMarkerType) where {
    
    -- | Display type-level information about UStore field with given marker
    --   and field value type. Used for error messages.
    type family ShowUStoreField marker v :: ErrorMessage;
    type ShowUStoreField marker v =  'Text "field of type " :<>:  'ShowType v;
}

-- | By field name derive key under which field should be stored.
mkFieldMarkerUKey :: KnownUStoreMarker marker => MText -> ByteString

-- | By field name derive key under which field should be stored.
mkFieldMarkerUKey :: KnownUStoreMarker marker => MText -> ByteString

-- | Get type of submap key.
type GetUStoreKey store name = MSKey (GetUStore name store)

-- | Get type of submap value.
type GetUStoreValue store name = MSValue (GetUStore name store)

-- | Get type of plain field. This ignores marker with field type.
type GetUStoreField store name = FSValue (GetUStore name store)

-- | Get kind of field.
type GetUStoreFieldMarker store name = FSMarker (GetUStore name store)
ustoreMem :: forall store name s. KeyAccessC store name => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (Bool : s)
ustoreGet :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (Maybe (GetUStoreValue store name) : s)
ustoreUpdate :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (Maybe (GetUStoreValue store name) : (UStore store : s))) :-> (UStore store : s)
ustoreInsert :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (GetUStoreValue store name : (UStore store : s))) :-> (UStore store : s)

-- | Insert a key-value pair, but fail if it will overwrite some existing
--   entry.
ustoreInsertNew :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (forall s0 any. (GetUStoreKey store name : s0) :-> any) -> (GetUStoreKey store name : (GetUStoreValue store name : (UStore store : s))) :-> (UStore store : s)
ustoreDelete :: forall store name s. KeyAccessC store name => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (UStore store : s)

-- | Like <tt>toField</tt>, but for <a>UStore</a>.
--   
--   This may fail only if <a>UStore</a> was made up incorrectly during
--   contract initialization.
ustoreToField :: forall store name s. FieldAccessC store name => Label name -> (UStore store : s) :-> (GetUStoreField store name : s)

-- | Like <tt>getField</tt>, but for <a>UStore</a>.
--   
--   This may fail only if <a>UStore</a> was made up incorrectly during
--   contract initialization.
ustoreGetField :: forall store name s. FieldAccessC store name => Label name -> (UStore store : s) :-> (GetUStoreField store name : (UStore store : s))

-- | Like <tt>setField</tt>, but for <a>UStore</a>.
ustoreSetField :: forall store name s. FieldAccessC store name => Label name -> (GetUStoreField store name : (UStore store : s)) :-> (UStore store : s)

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some submap(s) of it.
--   
--   It can use all UStore operations for a particular name, key and value
--   without knowing whole template.
type HasUStore name key value store = (KeyAccessC store name, ValueAccessC store name, GetUStoreKey store name ~ key, GetUStoreValue store name ~ value)

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some field of it.
type HasUField name ty store = (FieldAccessC store name, GetUStoreField store name ~ ty)

-- | Write down all sensisble constraints which given <tt>store</tt>
--   satisfies and apply them to <tt>constrained</tt>.
--   
--   This store should have <a>|~&gt;</a> and <a>UStoreFieldExt</a> fields
--   in its immediate fields, no deep inspection is performed.
type HasUStoreForAllIn store constrained = (Generic store, GHasStoreForAllIn constrained (Rep store))

-- | Lift an <a>UStore</a> to another <a>UStore</a> which contains all the
--   entries of the former under given field.
--   
--   This function is not intended for use in migrations, only in normal
--   entry points.
--   
--   Note that this function ensures that template of resulting store does
--   not contain inner nested templates with duplicated fields, otherwise
--   <a>UStore</a> invariants could get broken.
liftUStore :: (Generic template, RequireAllUniqueFields template) => Label name -> (UStore (GetFieldType template name) : s) :-> (UStore template : s)

-- | Unlift an <a>UStore</a> to a smaller <a>UStore</a> which is part of
--   the former.
--   
--   This function is not intended for use in migrations, only in normal
--   entry points.
--   
--   Surprisingly, despite smaller <a>UStore</a> may have extra entries,
--   this function is safe when used in contract code. Truly, all getters
--   and setters are still safe to use. Also, there is no way for the
--   resulting small <tt>UStore</tt> to leak outside of the contract since
--   the only place where <tt>big_map</tt> can appear is contract storage,
--   so this small <tt>UStore</tt> can be either dropped or lifted back via
--   <a>liftUStore</a> to appear as part of the new contract's state.
--   
--   When this function is run as part of standalone instructions sequence,
--   not as part of contract code (e.g. in tests), you may get an
--   <tt>UStore</tt> with entries not inherent to it.
unliftUStore :: Generic template => Label name -> (UStore template : s) :-> (UStore (GetFieldType template name) : s)

-- | Given template can be converted to <a>UStore</a> value.
class (Generic template, GUStoreConversible (Rep template)) => UStoreConversible template

-- | Make <a>UStore</a> from separate <tt>big_map</tt>s and fields.
mkUStore :: UStoreConversible template => template -> UStore template

-- | Decompose <a>UStore</a> into separate <tt>big_map</tt>s and fields.
--   
--   Since this function needs to <tt>UNPACK</tt> content of
--   <tt>UStore</tt> to actual keys and values, you have to provide
--   <tt>UnpackEnv</tt>.
--   
--   Along with resulting value, you get a list of <tt>UStore</tt> entries
--   which were not recognized as belonging to any submap or field
--   according to <tt>UStore</tt>'s template - this should be empty unless
--   <tt>UStore</tt> invariants were violated.
ustoreDecompose :: forall template. UStoreConversible template => UStore template -> Either Text (UStoreContent, template)

-- | Like <a>ustoreDecompose</a>, but requires all entries from
--   <tt>UStore</tt> to be recognized.
ustoreDecomposeFull :: forall template. UStoreConversible template => UStore template -> Either Text template

-- | Make migration script which initializes <a>UStore</a> from scratch.
fillUStore :: UStoreConversible template => template -> UStoreMigration () template

-- | Code of migration for <a>UStore</a>.
--   
--   Invariant: preferably should fit into op size / gas limits (quite
--   obvious). Often this stands for exactly one stage of migration (one
--   Tezos transaction).
newtype MigrationScript (oldStore :: Type) (newStore :: Type)
MigrationScript :: Lambda UStore_ UStore_ -> MigrationScript
[unMigrationScript] :: MigrationScript -> Lambda UStore_ UStore_
type MigrationScript_ = MigrationScript SomeUTemplate SomeUTemplate

-- | Keeps information about migration between <a>UStore</a>s with two
--   given templates.
data UStoreMigration (oldTempl :: Type) (newTempl :: Type)

-- | Get migration script in case of simple (non-batched) migration.
migrationToScript :: UStoreMigration os ns -> MigrationScript os ns

-- | Get migration script in case of simple (non-batched) migration.
migrationToScriptI :: UStoreMigration os ns -> Identity (MigrationScript os ns)

-- | Turn <tt>Migration</tt> into a whole piece of code for transforming
--   storage.
--   
--   This is not want you'd want to use for contract deployment because of
--   gas and operation size limits that Tezos applies to transactions.
migrationToLambda :: UStoreMigration oldTemplate newTemplate -> Lambda (UStore oldTemplate) (UStore newTemplate)

-- | Safe way to create migration scripts for <a>UStore</a>.
--   
--   You have to supply a code which would transform <a>MUStore</a>,
--   coverring required diff step-by-step. All basic instructions work,
--   also use <tt>migrate*</tt> functions from this module to operate with
--   <a>MUStore</a>.
--   
--   This method produces a whole migration, it cannot be splitted in
--   batches. In case if your migration is too big to be applied within a
--   single transaction, use <a>mkUStoreBatchedMigration</a>.
mkUStoreMigration :: Lambda (MUStore oldTempl newTempl (BuildDiff oldTempl newTempl) '[]) (MUStore oldTempl newTempl '[] _1) -> UStoreMigration oldTempl newTempl

-- | Get the old version of storage.
--   
--   This can be applied only in the beginning of migration.
--   
--   In fact this function is not very useful, all required operations
--   should be available for <a>MUStore</a>, but leaving it here just in
--   case.
mustoreToOld :: RequireBeInitial touched => (MUStore oldTemplate newTemplate remDiff touched : s) :-> (UStore oldTemplate : s)

-- | Get a field present in old version of <a>UStore</a>.
migrateGetField :: forall field oldTempl newTempl diff touched fieldTy s. (HasUField field fieldTy oldTempl, RequireUntouched field (field `IsElem` touched)) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (fieldTy : (MUStore oldTempl newTempl diff touched : s))

-- | Add a field which was not present before. This covers one addition
--   from the diff and any removals of field with given name.
--   
--   This function cannot overwrite existing field with the same name, if
--   this is necessary use <a>migrateOverwriteField</a> which would declare
--   removal explicitly.
migrateAddField :: forall field oldTempl newTempl diff touched fieldTy newDiff marker s. ('(UStoreFieldExt marker fieldTy, newDiff) ~ CoverDiff  'DcAdd field diff, HasUField field fieldTy newTempl) => Label field -> (fieldTy : (MUStore oldTempl newTempl diff touched : s)) :-> (MUStore oldTempl newTempl newDiff (field : touched) : s)

-- | Remove a field which should not be present in new version of storage.
--   This covers one removal from the diff.
--   
--   In fact, this action could be performed automatically, but since
--   removal is a destructive operation, being explicit about it seems like
--   a good thing.
migrateRemoveField :: forall field oldTempl newTempl diff touched fieldTy newDiff marker s. ('(UStoreFieldExt marker fieldTy, newDiff) ~ CoverDiff  'DcRemove field diff, HasUField field fieldTy oldTempl) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (MUStore oldTempl newTempl newDiff (field : touched) : s)

-- | Get and remove a field from old version of <a>UStore</a>.
--   
--   You probably want to use this more often than plain
--   <a>migrateRemoveField</a>.
migrateExtractField :: forall field oldTempl newTempl diff touched fieldTy newDiff marker s. ('(UStoreFieldExt marker fieldTy, newDiff) ~ CoverDiff  'DcRemove field diff, HasUField field fieldTy oldTempl, RequireUntouched field (field `IsElem` touched)) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (fieldTy : (MUStore oldTempl newTempl newDiff (field : touched) : s))

-- | Remove field and write new one in place of it.
--   
--   This is semantically equivalent to <tt>dip (migrateRemoveField label)
--   &gt;&gt; migrateAddField label</tt>, but is cheaper.
migrateOverwriteField :: forall field oldTempl newTempl diff touched fieldTy oldFieldTy marker oldMarker newDiff newDiff0 s. ('(UStoreFieldExt oldMarker oldFieldTy, newDiff0) ~ CoverDiff  'DcRemove field diff, '(UStoreFieldExt marker fieldTy, newDiff) ~ CoverDiff  'DcAdd field newDiff0, HasUField field fieldTy newTempl) => Label field -> (fieldTy : (MUStore oldTempl newTempl diff touched : s)) :-> (MUStore oldTempl newTempl newDiff (field : touched) : s)

-- | Modify field which should stay in new version of storage. This does
--   not affect remaining diff.
migrateModifyField :: forall field oldTempl newTempl diff touched fieldTy s. (HasUField field fieldTy oldTempl, HasUField field fieldTy newTempl) => Label field -> (fieldTy : (MUStore oldTempl newTempl diff touched : s)) :-> (MUStore oldTempl newTempl diff touched : s)

-- | Collect all fields with the given marker.
type PickMarkedFields marker template = GPickMarkedFields marker (Rep template)


-- | Impementation of <tt>Store</tt> - object incapsulating multiple
--   <a>BigMap</a>s.
--   
--   This module also provides template for the contract storage -
--   <a>StorageSkeleton</a>.
--   
--   We represent <a>Store</a> as <tt>big_map bytes (a | b | ...)</tt>.
--   
--   Key of this map is formed as <tt>(index, orig_key)</tt>, where
--   <tt>index</tt> is zero-based index of emulated map, <tt>orig_key</tt>
--   is key of this emulated map.
--   
--   Value of this map is just a union of emulated map's values.

-- | <i>Deprecated: Contract storage can contain multiple big_maps starting
--   from Michelson 005</i>
module Lorentz.Store

-- | Gathers multple <a>BigMap</a>s under one object.
--   
--   Type argument of this datatype stands for a "map template" - a
--   datatype with multiple constructors, each containing an object of type
--   <a>|-&gt;</a> and corresponding to single virtual <a>BigMap</a>. It's
--   also possible to parameterize it with a larger type which is a sum of
--   types satisfying the above property.
--   
--   Inside it keeps only one <a>BigMap</a> thus not violating Michelson
--   limitations.
--   
--   See examples below.
newtype Store a
Store :: BigMap ByteString a -> Store a
[unStore] :: Store a -> BigMap ByteString a

-- | Describes one virtual big map.
data k |-> v
type GetStoreKey store name = MSKey (GetStore name store)
type GetStoreValue store name = MSValue (GetStore name store)
storeMem :: forall store name s. StoreMemC store name => Label name -> (GetStoreKey store name : (Store store : s)) :-> (Bool : s)
storeGet :: forall store name s. StoreGetC store name => Label name -> (GetStoreKey store name : (Store store : s)) :-> (Maybe (GetStoreValue store name) : s)
storeUpdate :: forall store name s. StoreUpdateC store name => Label name -> (GetStoreKey store name : (Maybe (GetStoreValue store name) : (Store store : s))) :-> (Store store : s)
storeInsert :: forall store name s. StoreInsertC store name => Label name -> (GetStoreKey store name : (GetStoreValue store name : (Store store : s))) :-> (Store store : s)

-- | Insert a key-value pair, but fail if it will overwrite some existing
--   entry.
storeInsertNew :: forall store name s. StoreInsertC store name => Label name -> (forall s0 any. (GetStoreKey store name : s0) :-> any) -> (GetStoreKey store name : (GetStoreValue store name : (Store store : s))) :-> (Store store : s)
storeDelete :: forall store name s. StoreDeleteC store name => Label name -> (GetStoreKey store name : (Store store : s)) :-> (Store store : s)
type StoreMemC store name = StoreOpC store name
type StoreGetC store name = (StoreOpC store name, InstrUnwrapC store name, KnownValue (GetStoreValue store name), CtorHasOnlyField name store (GetStoreKey store name |-> GetStoreValue store name))
type StoreUpdateC store name = (KnownValue store, StoreOpC store name, InstrWrapC store name, CtorHasOnlyField name store (GetStoreKey store name |-> GetStoreValue store name))
type StoreInsertC store name = (StoreOpC store name, InstrWrapC store name, CtorHasOnlyField name store (GetStoreKey store name |-> GetStoreValue store name))
type StoreDeleteC store name = (StoreOpC store name, KnownValue store)

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some part(s) of it.
--   
--   It can use all Store operations for a particular name, key and value
--   without knowing whole template.
type HasStore name key value store = (StoreGetC store name, StoreInsertC store name, StoreDeleteC store name, GetStoreKey store name ~ key, GetStoreValue store name ~ value, StorePieceC store name key value)

-- | Write down all sensisble constraints which given <tt>store</tt>
--   satisfies and apply them to <tt>constrained</tt>.
--   
--   This store should have <a>|-&gt;</a> datatype in its immediate fields,
--   no deep inspection is performed.
type HasStoreForAllIn store constrained = GForAllHasStore constrained (Rep store)

-- | Contract storage with <tt>big_map</tt>.
--   
--   Due to Michelson constraints it is the only possible layout containing
--   <tt>big_map</tt>.
data StorageSkeleton storeTemplate other
StorageSkeleton :: Store storeTemplate -> other -> StorageSkeleton storeTemplate other
[sMap] :: StorageSkeleton storeTemplate other -> Store storeTemplate
[sFields] :: StorageSkeleton storeTemplate other -> other

-- | Unpack <a>StorageSkeleton</a> into a pair.
storageUnpack :: (StorageSkeleton store fields : s) :-> ((Store store, fields) : s)

-- | Pack a pair into <a>StorageSkeleton</a>.
storagePack :: ((Store store, fields) : s) :-> (StorageSkeleton store fields : s)
storageMem :: forall store name fields s. StoreMemC store name => Label name -> (GetStoreKey store name : (StorageSkeleton store fields : s)) :-> (Bool : s)
storageGet :: forall store name fields s. StoreGetC store name => Label name -> (GetStoreKey store name : (StorageSkeleton store fields : s)) :-> (Maybe (GetStoreValue store name) : s)
storageInsert :: forall store name fields s. StoreInsertC store name => Label name -> (GetStoreKey store name : (GetStoreValue store name : (StorageSkeleton store fields : s))) :-> (StorageSkeleton store fields : s)

-- | Insert a key-value pair, but fail if it will overwrite some existing
--   entry.
storageInsertNew :: forall store name fields s. StoreInsertC store name => Label name -> (forall s0 any. (GetStoreKey store name : s0) :-> any) -> (GetStoreKey store name : (GetStoreValue store name : (StorageSkeleton store fields : s))) :-> (StorageSkeleton store fields : s)
storageDelete :: forall store name fields s. StoreDeleteC store name => Label name -> (GetStoreKey store name : (StorageSkeleton store fields : s)) :-> (StorageSkeleton store fields : s)

-- | Lift a key-value pair to <a>Store</a>.
--   
--   Further you can use <a>Monoid</a> instance of <tt>Store</tt> to make
--   up large stores.
storePiece :: forall name store key value. StorePieceC store name key value => Label name -> key -> value -> Store store
storeKeyValueList :: forall name store key value. StorePieceC store name key value => Label name -> [(key, value)] -> Store store

-- | Get a value from store by key.
--   
--   It expects map to be consistent, otherwise call to this function fails
--   with error.
storeLookup :: forall name store key value ctorIdx. (key ~ GetStoreKey store name, value ~ GetStoreValue store name, ctorIdx ~ MSCtorIdx (GetStore name store), NicePackedValue key, KnownNat ctorIdx, InstrUnwrapC store name, Generic store, CtorOnlyField name store ~ (key |-> value)) => Label name -> key -> Store store -> Maybe value
type StorePieceC store name key value = (key ~ GetStoreKey store name, value ~ GetStoreValue store name, NicePackedValue key, KnownNat (MSCtorIdx (GetStore name store)), InstrWrapC store name, Generic store, ExtractCtorField (GetCtorField store name) ~ (key |-> value))
instance (Michelson.Typed.Haskell.Value.IsoValue storeTemplate, Michelson.Typed.Haskell.Value.IsoValue other) => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Store.StorageSkeleton storeTemplate other)
instance Data.Default.Class.Default other => Data.Default.Class.Default (Lorentz.Store.StorageSkeleton storeTemplate other)
instance GHC.Generics.Generic (Lorentz.Store.StorageSkeleton storeTemplate other)
instance (GHC.Show.Show storeTemplate, GHC.Show.Show other) => GHC.Show.Show (Lorentz.Store.StorageSkeleton storeTemplate other)
instance (GHC.Classes.Eq storeTemplate, GHC.Classes.Eq other) => GHC.Classes.Eq (Lorentz.Store.StorageSkeleton storeTemplate other)
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Store.MyStoreTemplateBig
instance GHC.Generics.Generic Lorentz.Store.MyStoreTemplateBig
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Store.MyStoreTemplate3
instance GHC.Generics.Generic Lorentz.Store.MyStoreTemplate3
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Store.MyNatural
instance Michelson.Typed.Haskell.Value.IsoCValue Lorentz.Store.MyNatural
instance GHC.Generics.Generic Lorentz.Store.MyNatural
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Store.MyStoreTemplate2
instance GHC.Generics.Generic Lorentz.Store.MyStoreTemplate2
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Store.MyStoreTemplate
instance GHC.Generics.Generic Lorentz.Store.MyStoreTemplate
instance forall k1 (k2 :: k1) v. Michelson.Typed.Haskell.Value.IsoValue v => Michelson.Typed.Haskell.Value.IsoValue (k2 Lorentz.Store.|-> v)
instance forall k1 (k2 :: k1) v. GHC.Generics.Generic (k2 Lorentz.Store.|-> v)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Store.Store a)
instance GHC.Base.Monoid (Lorentz.Store.Store a)
instance GHC.Base.Semigroup (Lorentz.Store.Store a)
instance Data.Default.Class.Default (Lorentz.Store.Store a)
instance GHC.Show.Show a => GHC.Show.Show (Lorentz.Store.Store a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Lorentz.Store.Store a)
instance (Lorentz.StoreClass.StoreHasField other fname ftype, Michelson.Typed.Haskell.Value.IsoValue store, Michelson.Typed.Haskell.Value.IsoValue other) => Lorentz.StoreClass.StoreHasField (Lorentz.Store.StorageSkeleton store other) fname ftype
instance (Lorentz.Store.StoreMemC store name, Lorentz.Store.StoreGetC store name, Lorentz.Store.StoreUpdateC store name, key Data.Type.Equality.~ Lorentz.Store.GetStoreKey store name, value Data.Type.Equality.~ Lorentz.Store.GetStoreValue store name, Michelson.Typed.Haskell.Value.IsoValue other) => Lorentz.StoreClass.StoreHasSubmap (Lorentz.Store.StorageSkeleton store other) name key value
instance (Lorentz.Store.StoreMemC store name, Lorentz.Store.StoreGetC store name, Lorentz.Store.StoreUpdateC store name, key Data.Type.Equality.~ Lorentz.Store.GetStoreKey store name, value Data.Type.Equality.~ Lorentz.Store.GetStoreValue store name) => Lorentz.StoreClass.StoreHasSubmap (Lorentz.Store.Store store) name key value


-- | Utilities for declaring and documenting entry points.
module Lorentz.EntryPoints.Doc

-- | Gathers information about single entrypoint.
--   
--   We assume that entry points might be of different kinds, which is
--   designated by phantom type parameter. For instance, you may want to
--   have several groups of entry points corresponding to various parts of
--   a contract - specifying different <tt>kind</tt> type argument for each
--   of those groups will allow you defining different <a>DocItem</a>
--   instances with appropriate custom descriptions for them.
data DEntryPoint (kind :: Type)
DEntryPoint :: Text -> SubDoc -> DEntryPoint
[depName] :: DEntryPoint -> Text
[depSub] :: DEntryPoint -> SubDoc
data DEntryPointReference
DEntryPointReference :: Text -> Anchor -> DEntryPointReference

-- | Provides arror for convenient entrypoint documentation
class EntryArrow kind name body

-- | Lift entrypoint implementation.
--   
--   Entrypoint names should go with "e" prefix.
(#->) :: EntryArrow kind name body => (Label name, Proxy kind) -> body -> body

-- | Default value for <a>DEntryPoint</a> type argument.
data PlainEntryPointsKind

-- | Default implementation of <a>docItemToMarkdown</a> for entry points.
diEntryPointToMarkdown :: HeaderLevel -> DEntryPoint level -> Markdown

-- | Describes argument of an entrypoint.
data DEntryPointArg
DEntryPointArg :: Maybe DType -> [ParamBuildingStep] -> Type -> DEntryPointArg

-- | Argument of the entrypoint. Pass <a>Nothing</a> if no argument is
--   required.
[epaArg] :: DEntryPointArg -> Maybe DType

-- | Describes a way to lift an entrypoint argument into full parameter
--   which can be passed to the contract.
--   
--   Steps are supposed to be applied in the order opposite to one in which
--   they are given. E.g. suppose that an entrypoint is called as <tt>Run
--   (Service1 arg)</tt>; then the first step (actual last) should describe
--   wrapping into <tt>Run</tt> constructor, and the second step (actual
--   first) should be about wrapping into <tt>Service1</tt> constructor.
[epaBuilding] :: DEntryPointArg -> [ParamBuildingStep]

-- | Untyped representation of entrypoint, used for printing its michelson
--   type representation.
[epaType] :: DEntryPointArg -> Type

-- | Doc element with description of a type.
data DType
[DType] :: forall a. TypeHasDoc a => Proxy a -> DType

-- | Pick a type documentation from <a>CtorField</a>.
class (KnownSymbol con) => DeriveCtorFieldDoc con (cf :: CtorField)
deriveCtorFieldDoc :: DeriveCtorFieldDoc con cf => DEntryPointArg

-- | When describing the way of parameter construction - piece of
--   incremental builder for this description.
newtype ParamBuilder
ParamBuilder :: (Markdown -> Markdown) -> ParamBuilder

-- | Argument stands for previously constructed parameter piece, and
--   returned value - a piece constructed after our step.
[unParamBuilder] :: ParamBuilder -> Markdown -> Markdown
data ParamBuildingDesc
ParamBuildingDesc :: Markdown -> ParamBuilder -> ParamBuilder -> ParamBuildingDesc

-- | Plain english description of this step.
[pbdEnglish] :: ParamBuildingDesc -> Markdown

-- | How to construct parameter in Haskell code.
[pbdHaskell] :: ParamBuildingDesc -> ParamBuilder

-- | How to construct parameter working on raw Michelson.
[pbdMichelson] :: ParamBuildingDesc -> ParamBuilder

-- | Describes a parameter building step.
--   
--   This can be wrapping into (Haskell) constructor, or a more complex
--   transformation.
data ParamBuildingStep

-- | Wraps something into constructor with given name. Constructor should
--   be the one which corresponds to an entrypoint defined via field
--   annotation, for more complex cases use <a>PbsCustom</a>.
PbsWrapIn :: Text -> ParamBuildingDesc -> ParamBuildingStep

-- | Directly call an entrypoint marked with a field annotation.
PbsCallEntrypoint :: EpName -> ParamBuildingStep

-- | Other action.
PbsCustom :: ParamBuildingDesc -> ParamBuildingStep

-- | This entrypoint cannot be called, which is possible when an explicit
--   default entrypoint is present. This is not a true entrypoint but just
--   some intermediate node in <tt>or</tt> tree and neither it nor any of
--   its parents are marked with a field annotation.
--   
--   It contains dummy <a>ParamBuildingStep</a>s which were assigned before
--   entrypoints were taken into account.
PbsUncallable :: [ParamBuildingStep] -> ParamBuildingStep

-- | Make a <a>ParamBuildingStep</a> that tells about wrapping an argument
--   into a constructor with given name and uses given <a>ParamBuilder</a>
--   as description of Michelson part.
mkPbsWrapIn :: Text -> ParamBuilder -> ParamBuildingStep

-- | Go over contract code and update every occurrence of
--   <a>DEntryPointArg</a> documentation item, adding the given step to its
--   "how to build parameter" description.
clarifyParamBuildingSteps :: ParamBuildingStep -> (inp :-> out) -> inp :-> out
constructDEpArg :: forall arg. (TypeHasDoc arg, HasTypeAnn arg, KnownValue arg) => DEntryPointArg
emptyDEpArg :: DEntryPointArg
mkUType :: SingI x => Notes x -> Type
mkDEpUType :: forall t. (KnownValue t, HasTypeAnn t) => Type
mkDEntryPointArgSimple :: forall t. (KnownValue t, HasTypeAnn t, TypeHasDoc t) => DEntryPointArg

-- | Constraint for <a>documentEntryPoints</a>.
type DocumentEntryPoints kind a = (Generic a, GDocumentEntryPoints kind (Rep a))

-- | Wrapper for documenting single entrypoint which parameter isn't going
--   to be unwrapped from some datatype.
--   
--   <tt>entryCase</tt> unwraps a datatype, however, sometimes we want to
--   have entrypoint parameter to be not wrapped into some datatype.
documentEntryPoint :: forall kind epName param s out. (KnownSymbol epName, DocItem (DEntryPoint kind), TypeHasDoc param, HasTypeAnn param, KnownValue param) => ((param & s) :-> out) -> (param & s) :-> out

-- | Version of <a>entryCase_</a> for tuples.
entryCase :: forall dt entryPointKind out inp clauses. (CaseTC dt out inp clauses, DocumentEntryPoints entryPointKind dt) => Proxy entryPointKind -> IsoRecTuple clauses -> (dt & inp) :-> out

-- | Like <a>case_</a>, to be used for pattern-matching on a parameter or
--   its part.
--   
--   Modifies documentation accordingly. Including description of
--   entrypoints' arguments, thus for them you will need to supply
--   <a>TypeHasDoc</a> instance.
entryCase_ :: forall dt entryPointKind out inp. (InstrCaseC dt inp out, RMap (CaseClauses dt), DocumentEntryPoints entryPointKind dt) => Proxy entryPointKind -> Rec (CaseClauseL inp out) (CaseClauses dt) -> (dt & inp) :-> out

-- | Modify param building steps with respect to entrypoints that given
--   parameter declares.
--   
--   Each contract with entrypoints should eventually call this function,
--   otherwise, in case if contract uses built-in entrypoints feature, the
--   resulting parameter building steps in the generated documentation will
--   not consider entrypoints and thus may be incorrect.
--   
--   Calling this twice over the same code is also prohibited.
finalizeParamCallingDoc :: forall cp inp out. (NiceParameterFull cp, RequireSumType cp, HasCallStack) => ((cp : inp) :-> out) -> (cp : inp) :-> out

-- | Whether <a>finalizeParamCallingDoc</a> has already been applied to
--   these steps.
areFinalizedParamBuildingSteps :: [ParamBuildingStep] -> Bool
entryCaseSimple_ :: forall cp out inp. (InstrCaseC cp inp out, RMap (CaseClauses cp), DocumentEntryPoints PlainEntryPointsKind cp, NiceParameterFull cp, RequireFlatParamEps cp) => Rec (CaseClauseL inp out) (CaseClauses cp) -> (cp & inp) :-> out

-- | Version of <a>entryCase</a> for contracts with flat parameter, use it
--   when you need only one <a>entryCase</a> all over the contract
--   implementation.
--   
--   This method calls <a>finalizeParamCallingDoc</a> inside.
entryCaseSimple :: forall cp out inp clauses. (CaseTC cp out inp clauses, DocumentEntryPoints PlainEntryPointsKind cp, NiceParameterFull cp, RequireFlatParamEps cp) => IsoRecTuple clauses -> (cp & inp) :-> out
type family RequireFlatParamEps cp :: Constraint
type family RequireFlatEpDerivation cp deriv :: Constraint
instance GHC.Classes.Eq Lorentz.EntryPoints.Doc.ParamBuildingStep
instance GHC.Show.Show Lorentz.EntryPoints.Doc.ParamBuildingStep
instance GHC.Classes.Eq Lorentz.EntryPoints.Doc.ParamBuildingDesc
instance GHC.Show.Show Lorentz.EntryPoints.Doc.ParamBuildingDesc
instance (name Data.Type.Equality.~ GHC.TypeLits.AppendSymbol "e" epName, body Data.Type.Equality.~ ((param Lorentz.Base.& s) Lorentz.Base.:-> out), GHC.TypeLits.KnownSymbol epName, Michelson.Doc.DocItem (Lorentz.EntryPoints.Doc.DEntryPoint kind), Michelson.Typed.Haskell.Doc.TypeHasDoc param, Lorentz.TypeAnns.HasTypeAnn param, Lorentz.Constraints.Scopes.KnownValue param) => Lorentz.EntryPoints.Doc.EntryArrow kind name body
instance Lorentz.EntryPoints.Doc.GDocumentEntryPoints kind x => Lorentz.EntryPoints.Doc.GDocumentEntryPoints kind (GHC.Generics.D1 i x)
instance (Lorentz.EntryPoints.Doc.GDocumentEntryPoints kind x, Lorentz.EntryPoints.Doc.GDocumentEntryPoints kind y, Util.Type.RSplit (Michelson.Typed.Haskell.Instr.Sum.GCaseClauses x) (Michelson.Typed.Haskell.Instr.Sum.GCaseClauses y)) => Lorentz.EntryPoints.Doc.GDocumentEntryPoints kind (x GHC.Generics.:+: y)
instance ('Michelson.Typed.Haskell.Instr.Sum.CaseClauseParam ctor cf Data.Type.Equality.~ Michelson.Typed.Haskell.Instr.Sum.GCaseBranchInput ctor x, GHC.TypeLits.KnownSymbol ctor, Michelson.Doc.DocItem (Lorentz.EntryPoints.Doc.DEntryPoint kind), Lorentz.EntryPoints.Doc.DeriveCtorFieldDoc ctor cf) => Lorentz.EntryPoints.Doc.GDocumentEntryPoints kind (GHC.Generics.C1 ('GHC.Generics.MetaCons ctor _1 _2) x)
instance GHC.TypeLits.KnownSymbol con => Lorentz.EntryPoints.Doc.DeriveCtorFieldDoc con 'Michelson.Typed.Haskell.Instr.Sum.NoFields
instance (Michelson.Typed.Haskell.Doc.TypeHasDoc ty, Lorentz.TypeAnns.HasTypeAnn ty, Lorentz.Constraints.Scopes.KnownValue ty, GHC.TypeLits.KnownSymbol con) => Lorentz.EntryPoints.Doc.DeriveCtorFieldDoc con ('Michelson.Typed.Haskell.Instr.Sum.OneField ty)
instance Michelson.Doc.DocItem Lorentz.EntryPoints.Doc.DEntryPointArg
instance Formatting.Buildable.Buildable Lorentz.EntryPoints.Doc.ParamBuildingStep
instance Formatting.Buildable.Buildable Lorentz.EntryPoints.Doc.ParamBuilder
instance GHC.Show.Show Lorentz.EntryPoints.Doc.ParamBuilder
instance GHC.Classes.Eq Lorentz.EntryPoints.Doc.ParamBuilder
instance Michelson.Doc.DocItem Lorentz.EntryPoints.Doc.DEntryPointReference
instance Michelson.Doc.DocItem (Lorentz.EntryPoints.Doc.DEntryPoint Lorentz.EntryPoints.Doc.PlainEntryPointsKind)

module Lorentz.UParam

-- | Encapsulates parameter for one of entry points. It keeps entrypoint
--   name and corresponding argument serialized.
--   
--   In Haskell world, we keep an invariant of that contained value relates
--   to one of entry points from <tt>entries</tt> list.
newtype UParam (entries :: [EntryPointKind])
UParamUnsafe :: (MText, ByteString) -> UParam

-- | An entrypoint is described by two types: its name and type of
--   argument.
type EntryPointKind = (Symbol, Type)

-- | A convenient alias for type-level name-something pair.
type (n :: Symbol) ?: (a :: k) = '(n, a)

-- | Construct a <a>UParam</a> safely.
mkUParam :: (NicePackedValue a, LookupEntryPoint name entries ~ a, RequireUniqueEntryPoints entries) => Label name -> a -> UParam entries

-- | This type can store any value that satisfies a certain constraint.
data ConstrainedSome (c :: Type -> Constraint)
[ConstrainedSome] :: c a => a -> ConstrainedSome c

-- | This class is needed to implement <a>unpackUParam</a>.
class UnpackUParam (c :: Type -> Constraint) entries

-- | Turn <a>UParam</a> into a Haskell value. Since we don't know its type
--   in compile time, we have to erase it using <a>ConstrainedSome</a>. The
--   user of this function can require arbitrary constraint to hold
--   (depending on how they want to use the result).
unpackUParam :: UnpackUParam c entries => UParam entries -> Either EntryPointLookupError (MText, ConstrainedSome c)

-- | Pseudo value for <a>UParam</a> type variable.
type SomeInterface = '['("SomeEntrypoints", Void)]

-- | Homomorphic version of <a>UParam</a>, forgets the exact interface.
type UParam_ = UParam SomeInterface

-- | Implementations of some entry points.
--   
--   Note that this thing inherits properties of <a>Rec</a>, e.g. you can
--   <tt>Data.Vinyl.Core.rappend</tt> implementations for two entrypoint
--   sets when assembling scattered parts of a contract.
type EntryPointsImpl inp out entries = Rec (CaseClauseU inp out) entries

-- | An action invoked when user-provided entrypoint is not found.
type UParamFallback inp out = ((MText, ByteString) : inp) :-> out
data EntryPointLookupError
NoSuchEntryPoint :: MText -> EntryPointLookupError
ArgumentUnpackFailed :: EntryPointLookupError

-- | Make up a "case" over entry points.
class CaseUParam (entries :: [EntryPointKind])

-- | Pattern-match on given <tt>UParam entries</tt>.
--   
--   You have to provide all case branches and a fallback action on case
--   when entrypoint is not found.
caseUParam :: (CaseUParam entries, RequireUniqueEntryPoints entries) => Rec (CaseClauseU inp out) entries -> UParamFallback inp out -> (UParam entries : inp) :-> out

-- | Like <a>caseUParam</a>, but accepts a tuple of clauses, not a
--   <a>Rec</a>.
caseUParamT :: forall entries inp out clauses. (clauses ~ Rec (CaseClauseU inp out) entries, RecFromTuple clauses, CaseUParam entries) => IsoRecTuple clauses -> UParamFallback inp out -> (UParam entries : inp) :-> out

-- | Default implementation for <a>UParamFallback</a>, simply reports an
--   error.
uparamFallbackFail :: UParamFallback inp out

-- | Get type of entrypoint argument by its name.
type family LookupEntryPoint (name :: Symbol) (entries :: [EntryPointKind]) :: Type

-- | Ensure that given entry points do no contain duplicated names.
type family RequireUniqueEntryPoints (entries :: [EntryPointKind]) :: Constraint

-- | Make up <a>UParam</a> from ADT sum.
--   
--   Entry points template will consist of <tt>(constructorName,
--   constructorFieldType)</tt> pairs. Each constructor is expected to have
--   exactly one field.
uparamFromAdt :: UParamLinearize up => up -> UParam (UParamLinearized up)

-- | Constraint required by <a>uparamFromAdt</a>.
type UParamLinearize p = (Generic p, GUParamLinearize (Rep p))

-- | Entry points template derived from given ADT sum.
type UParamLinearized p = GUParamLinearized (Rep p)

-- | Note that calling given entrypoints involves constructing
--   <a>UParam</a>.
pbsUParam :: forall ctorName. KnownSymbol ctorName => ParamBuildingStep

-- | Helper instruction which extracts content of <a>UParam</a>.
unwrapUParam :: (UParam entries : s) :-> ((MText, ByteString) : s)
instance GHC.Show.Show Lorentz.UParam.EntryPointLookupError
instance GHC.Classes.Eq Lorentz.UParam.EntryPointLookupError
instance GHC.Generics.Generic Lorentz.UParam.EntryPointLookupError
instance Lorentz.TypeAnns.HasTypeAnn (Lorentz.UParam.UParam entries)
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.UParam.UParam entries)
instance GHC.Show.Show (Lorentz.UParam.UParam entries)
instance GHC.Classes.Eq (Lorentz.UParam.UParam entries)
instance GHC.Generics.Generic (Lorentz.UParam.UParam entries)
instance Lorentz.UParam.GUParamLinearize x => Lorentz.UParam.GUParamLinearize (GHC.Generics.D1 i x)
instance (Lorentz.UParam.GUParamLinearize x, Lorentz.UParam.GUParamLinearize y) => Lorentz.UParam.GUParamLinearize (x GHC.Generics.:+: y)
instance (GHC.TypeLits.KnownSymbol name, Lorentz.Constraints.Scopes.NicePackedValue a) => Lorentz.UParam.GUParamLinearize (GHC.Generics.C1 ('GHC.Generics.MetaCons name _1 _2) (GHC.Generics.S1 si (GHC.Generics.Rec0 a)))
instance (TypeError ...) => Lorentz.UParam.GUParamLinearize (GHC.Generics.C1 i GHC.Generics.U1)
instance (TypeError ...) => Lorentz.UParam.GUParamLinearize (GHC.Generics.C1 i (x GHC.Generics.:*: y))
instance Lorentz.UParam.CaseUParam '[]
instance (GHC.TypeLits.KnownSymbol name, Lorentz.UParam.CaseUParam entries, Lorentz.Constraints.Scopes.NiceUnpackedValue arg) => Lorentz.UParam.CaseUParam ((name Lorentz.UParam.?: arg) : entries)
instance Lorentz.UParam.UnpackUParam c '[]
instance (GHC.TypeLits.KnownSymbol name, Lorentz.UParam.UnpackUParam c entries, Lorentz.Constraints.Scopes.NiceUnpackedValue arg, c arg) => Lorentz.UParam.UnpackUParam c ((name Lorentz.UParam.?: arg) : entries)
instance Formatting.Buildable.Buildable Lorentz.UParam.EntryPointLookupError
instance (name Data.Type.Equality.~ name', body Data.Type.Equality.~ ((arg : inp) Lorentz.Base.:-> out)) => Lorentz.ADT.CaseArrow name' body (Lorentz.UParam.CaseClauseU inp out '(name, arg))
instance GHC.Show.Show (Lorentz.UParam.ConstrainedSome GHC.Show.Show)
instance Formatting.Buildable.Buildable (Lorentz.UParam.ConstrainedSome Formatting.Buildable.Buildable)
instance Lorentz.UParam.SameEntries entries1 entries2 => Lorentz.Coercions.CanCastTo (Lorentz.UParam.UParam entries1) (Lorentz.UParam.UParam entries2)
instance Control.Lens.Wrapped.Wrapped (Lorentz.UParam.UParam entries)
instance Data.Typeable.Internal.Typeable interface => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.UParam.UParam interface)
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "uparamNoSuchEntryPoint")
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "uparamArgumentUnpackFailed")
instance Lorentz.Errors.CustomErrorHasDoc "uparamNoSuchEntryPoint"
instance Lorentz.Errors.CustomErrorHasDoc "uparamArgumentUnpackFailed"


-- | Testing predicates for documentation of Lorentz contracts.
module Lorentz.Test.Doc

-- | Tests all properties.
testLorentzDoc :: [DocTest]

-- | Check that contract documents its parameter.
testDeclaresParameter :: DocTest

-- | It's a common issue to forget to describe an entrypoint.
testEachEntrypointIsDescribed :: DocTest

-- | Check that <a>finalizeParamCallingDoc</a> is applied to the contract
--   as it always should.
testParamBuildingStepsAreFinalized :: DocTest

-- | Check that all documented entrypoints are callable.
--   
--   Sometimes having such an entrypoint is fine, e.g. when you have an
--   explicit default entrypoint deep in one arm then other arms (entire
--   arms, not individual entrypoints within them) are uncallable unless
--   also assigned a field annotation; for example see [doc for uncallable
--   entrypoints] note. If this is your case, exclude this test suite with
--   <a>excludeDocTest</a>. But such situations are rare.
--   
--   More often, this test failure indicates that entrypoints are
--   documented incorrectly, e.g. <tt>caseT</tt> is used in some place
--   instead of <a>entryCase</a>. Check whether printed building steps are
--   correct.
--   
--   NB: another, simplified example of case when disabling this test is
--   justified:
--   
--   <pre>
--   data SubParam1 = Do1 | Default
--   data SubParam2 = Do2 | Do3
--   data Param = Arm1 SubParam1 | Arm2 SubParam2
--     -- ^ with entrypoints derived via <tt>EpdRecursive</tt>
--   </pre>
--   
--   In this case entire <tt>Arm1</tt> and <tt>Arm2</tt> are not true
--   entrypoints, only <tt>Default</tt> and <tt>Do{1,2,3}</tt> are, but
--   <tt>Arm1</tt> and <tt>Arm2</tt> will still appear in documentation as
--   entrypoints.
testAllEntrypointsAreCallable :: DocTest
instance Formatting.Buildable.Buildable Lorentz.Test.Doc.DocEpDescription

module Lorentz

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>($)</tt> is levity-polymorphic in its result type, so
--   that foo $ True where foo :: Bool -&gt; Int# is well-typed
($) :: () => (a -> b) -> a -> b
infixr 0 $

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
fromString :: IsString a => String -> a

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <tt>id</tt>
--   <a>to</a> . <a>from</a> ≡ <tt>id</tt>
--   </pre>
class Generic a
fromLabel :: IsLabel x a => a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the associativity law:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</pre></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <tt>&lt;&gt;</tt>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in <i>O(1)</i> by picking
--   <tt>stimes = <tt>stimesIdempotent</tt></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> <a>mempty</a> = x</pre></li>
--   <li><pre><a>mempty</a> <a>&lt;&gt;</a> x = x</pre></li>
--   <li><tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a> law)</li>
--   <li><pre><a>mconcat</a> = <a>foldr</a> '(&lt;&gt;)'
--   <a>mempty</a></pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = '(&lt;&gt;)'</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><tt>throw</tt>
--   (<tt>Underflow</tt> :: <tt>ArithException</tt>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | A space efficient, packed, unboxed Unicode text type.
data Text

-- | Function composition.
(.) :: () => (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt>'undefined :: a'</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k) :: forall k. () => k -> Type
Proxy :: Proxy

-- | From a <a>Dict</a>, takes a value in an environment where the instance
--   witnessed by the <a>Dict</a> is in scope, and evaluates it.
--   
--   Essentially a deconstruction of a <a>Dict</a> into its
--   continuation-style form.
--   
--   Can also be used to deconstruct an entailment, <tt>a <a>:-</a> b</tt>,
--   using a context <tt>a</tt>.
--   
--   <pre>
--   withDict :: <a>Dict</a> c -&gt; (c =&gt; r) -&gt; r
--   withDict :: a =&gt; (a <a>:-</a> c) -&gt; (c =&gt; r) -&gt; r
--   </pre>
withDict :: HasDict c e => e -> (c -> r) -> r

-- | A set of values <tt>a</tt>.
data Set a

-- | A class for types with a default value.
class Default a

-- | The default value for this type.
def :: Default a => a

-- | <a>Wrapped</a> provides isomorphisms to wrap and unwrap newtypes or
--   data types with one constructor.
class Wrapped s where {
    type family Unwrapped s :: Type;
}

-- | An isomorphism between <tt>s</tt> and <tt>a</tt>.
--   
--   If your type has a <a>Generic</a> instance, <a>_Wrapped'</a> will
--   default to <a>_GWrapped'</a>, and you can choose to not override it
--   with your own definition.
_Wrapped' :: Wrapped s => Iso' s (Unwrapped s)

-- | Version of <a>concreteTypeDocHaskellRepUnsafe</a> which does not
--   ensure whether the type for which representation is built is any
--   similar to the original type which you implement a <a>TypeHasDoc</a>
--   instance for.
concreteTypeDocMichelsonRepUnsafe :: (Typeable a, SingI (ToT a)) => TypeDocMichelsonRep b

-- | Implement <a>typeDocMichelsonRep</a> on example of given concrete
--   type.
--   
--   This function exists for the same reason as
--   <a>concreteTypeDocHaskellRep</a>.
concreteTypeDocMichelsonRep :: (Typeable a, SingI (ToT a), HaveCommonTypeCtor b a) => TypeDocMichelsonRep b

-- | Implement <a>typeDocMichelsonRep</a> for homomorphic type.
homomorphicTypeDocMichelsonRep :: SingI (ToT a) => TypeDocMichelsonRep a

-- | Cut fields prefixes which we use according to the style guide.
--   
--   E.g. <tt>cmMyField</tt> field will be transformed to <tt>myField</tt>.
haskellRepStripFieldPrefix :: HasCallStack => TypeDocHaskellRep a -> TypeDocHaskellRep a

-- | Erase fields from Haskell datatype representation.
--   
--   Use this when rendering fields names is undesired.
haskellRepNoFields :: () => TypeDocHaskellRep a -> TypeDocHaskellRep a

-- | Version of <a>concreteTypeDocHaskellRep</a> which does not ensure
--   whether the type for which representation is built is any similar to
--   the original type which you implement a <a>TypeHasDoc</a> instance
--   for.
concreteTypeDocHaskellRepUnsafe :: (Typeable a, GenericIsoValue a, GTypeHasDoc (Rep a)) => TypeDocHaskellRep b

-- | Implement <a>typeDocHaskellRep</a> on example of given concrete type.
--   
--   This is a best effort attempt to implement <a>typeDocHaskellRep</a>
--   for polymorhpic types, as soon as there is no simple way to preserve
--   type variables when automatically deriving Haskell representation of a
--   type.
concreteTypeDocHaskellRep :: (Typeable a, GenericIsoValue a, GTypeHasDoc (Rep a), HaveCommonTypeCtor b a) => TypeDocHaskellRep b

-- | Implement <a>typeDocHaskellRep</a> for a homomorphic type.
--   
--   Note that it does not require your type to be of <a>IsHomomorphic</a>
--   instance, which can be useful for some polymorhpic types which, for
--   documentation purposes, we want to consider homomorphic. Example:
--   <a>Operation</a> is in fact polymorhpic, but we don't want this fact
--   to be reflected in the documentation.
homomorphicTypeDocHaskellRep :: (Generic a, GTypeHasDoc (Rep a)) => TypeDocHaskellRep a

-- | Implement <a>typeDocDependencies</a> via getting all immediate fields
--   of a datatype.
--   
--   Note: this will not include phantom types, I'm not sure yet how this
--   scenario should be handled (@martoon).
genericTypeDocDependencies :: (Generic a, GTypeHasDoc (Rep a)) => Proxy a -> [SomeTypeWithDoc]

-- | Derive <a>typeDocMdReference</a>, for polymorphic type with two type
--   arguments, like <tt>Lambda Integer Natural</tt>.
poly2TypeDocMdReference :: (r ~ t a b, Typeable t, Each (TypeHasDoc : ([] :: [Type -> Constraint])) (r : (a : (b : ([] :: [Type])))), IsHomomorphic t) => Proxy r -> WithinParens -> Markdown

-- | Derive <a>typeDocMdReference</a>, for polymorphic type with one type
--   argument, like <tt>Maybe Integer</tt>.
poly1TypeDocMdReference :: (r ~ t a, Typeable t, Each (TypeHasDoc : ([] :: [Type -> Constraint])) (r : (a : ([] :: [Type]))), IsHomomorphic t) => Proxy r -> WithinParens -> Markdown

-- | Derive <a>typeDocMdReference</a>, for homomorphic types only.
homomorphicTypeDocMdReference :: (Typeable t, TypeHasDoc t, IsHomomorphic t) => Proxy t -> WithinParens -> Markdown

-- | Render a reference to a type which consists of type constructor (you
--   have to provide name of this type constructor and documentation for
--   the whole type) and zero or more type arguments.
customTypeDocMdReference :: (Text, DType) -> [DType] -> WithinParens -> Markdown

-- | Description for a Haskell type appearing in documentation.
class Typeable a => TypeHasDoc a

-- | Name of type as it appears in definitions section.
--   
--   Each type must have its own unique name because it will be used in
--   identifier for references.
--   
--   Default definition derives name from Generics. If it does not fit,
--   consider defining this function manually. (We tried using <a>Data</a>
--   for this, but it produces names including module names which is not do
--   we want).
typeDocName :: TypeHasDoc a => Proxy a -> Text

-- | Explanation of a type. Markdown formatting is allowed.
typeDocMdDescription :: TypeHasDoc a => Markdown

-- | How reference to this type is rendered, in Markdown.
--   
--   Examples: * <tt><a>Integer</a></tt>, * <tt><a>Maybe</a>
--   <a>()</a></tt>.
--   
--   Consider using one of the following functions as default
--   implementation; which one to use depends on number of type arguments
--   in your type: * <a>homomorphicTypeDocMdReference</a> *
--   <a>poly1TypeDocMdReference</a> * <a>poly2TypeDocMdReference</a>
--   
--   If none of them fits your purposes precisely, consider using
--   <a>customTypeDocMdReference</a>.
typeDocMdReference :: TypeHasDoc a => Proxy a -> WithinParens -> Markdown

-- | All types which this type directly contains.
--   
--   Used in automatic types discovery.
typeDocDependencies :: TypeHasDoc a => Proxy a -> [SomeTypeWithDoc]

-- | For complex types - their immediate Haskell representation.
--   
--   For primitive types set this to <a>Nothing</a>.
--   
--   For homomorphic types use <a>homomorphicTypeDocHaskellRep</a>
--   implementation.
--   
--   For polymorhpic types consider using <a>concreteTypeDocHaskellRep</a>
--   as implementation.
--   
--   Modifier <a>haskellRepNoFields</a> can be used to hide names of
--   fields, beneficial for newtypes.
--   
--   Another modifier called <a>haskellRepStripFieldPrefix</a> can be used
--   for datatypes to leave only meaningful part of name in every field.
typeDocHaskellRep :: TypeHasDoc a => TypeDocHaskellRep a

-- | Final michelson representation of a type.
--   
--   For homomorphic types use <a>homomorphicTypeDocMichelsonRep</a>
--   implementation.
--   
--   For polymorhpic types consider using
--   <a>concreteTypeDocMichelsonRep</a> as implementation.
typeDocMichelsonRep :: TypeHasDoc a => TypeDocMichelsonRep a

-- | Data hides some type implementing <a>TypeHasDoc</a>.
data SomeTypeWithDoc
[SomeTypeWithDoc] :: forall td. TypeHasDoc td => Proxy td -> SomeTypeWithDoc

-- | Doc element with description of a type.
data DType
[DType] :: forall a. TypeHasDoc a => Proxy a -> DType

-- | Require two types to be built from the same type constructor.
--   
--   E.g. <tt>HaveCommonTypeCtor (Maybe Integer) (Maybe Natural)</tt> is
--   defined, while <tt>HaveCmmonTypeCtor (Maybe Integer) [Integer]</tt> is
--   not.
class HaveCommonTypeCtor (a :: k) (b :: k1)

-- | Require this type to be homomorphic.
class IsHomomorphic (a :: k)

-- | Types of all fields in a datatype.
type ConstructorFieldTypes dt = GFieldTypes Rep dt

-- | Constraint for <a>instrConstruct</a>.
type InstrConstructC dt = (GenericIsoValue dt, GInstrConstruct Rep dt)

-- | Replace type argument of <tt>ContractAddr</tt> with isomorphic one.
coerceContractRef :: ToT a ~ ToT b => ContractRef a -> ContractRef b

-- | Isomorphism between Michelson primitive values and plain Haskell
--   types.
class IsoCValue a where {
    
    -- | Type function that converts a regular Haskell type into a comparable
    --   type (which has kind <tt>CT</tt>).
    type family ToCT a :: CT;
}

-- | Converts a single Haskell value into <tt>CVal</tt> representation.
toCVal :: IsoCValue a => a -> CValue (ToCT a)

-- | Converts a <tt>CVal</tt> value into a single Haskell value.
fromCVal :: IsoCValue a => CValue (ToCT a) -> a

-- | Isomorphism between Michelson values and plain Haskell types.
--   
--   Default implementation of this typeclass converts ADTs to Michelson
--   "pair"s and "or"s.
class IsoValue a where {
    
    -- | Type function that converts a regular Haskell type into a <tt>T</tt>
    --   type.
    type family ToT a :: T;
}

-- | Converts a Haskell structure into <tt>Value</tt> representation.
toVal :: IsoValue a => a -> Value (ToT a)

-- | Converts a <tt>Value</tt> into Haskell type.
fromVal :: IsoValue a => Value (ToT a) -> a
type EntryPointCall param arg = EntryPointCallT ToT param ToT arg
type SomeEntryPointCall arg = SomeEntryPointCallT ToT arg

-- | Since <tt>Contract</tt> name is used to designate contract code, lets
--   call analogy of <a>TContract</a> type as follows.
--   
--   Note that type argument always designates an argument of entrypoint.
--   If a contract has explicit default entrypoint (and no root
--   entrypoint), <tt>ContractRef</tt> referring to it can never have the
--   entire parameter as its type argument.
data ContractRef arg
ContractRef :: Address -> SomeEntryPointCall arg -> ContractRef arg
[crAddress] :: ContractRef arg -> Address
[crEntryPoint] :: ContractRef arg -> SomeEntryPointCall arg
newtype BigMap k v
BigMap :: Map k v -> BigMap k v
[unBigMap] :: BigMap k v -> Map k v
type Value = Value' Instr
type Operation = Operation' Instr

-- | Make <a>DGitRevision</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :t $mkDGitRevision
--   GitRepoSettings -&gt; DGitRevision
--   </pre>
mkDGitRevision :: ExpQ
morleyRepoSettings :: GitRepoSettings

-- | Render given contract documentation to markdown document.
contractDocToMarkdown :: ContractDoc -> LText

-- | A function which groups a piece of doc under one doc item.
type DocGrouping = SubDoc -> SomeDocItem

-- | Description of something.
data DDescription
DDescription :: Markdown -> DDescription
data DGitRevision
DGitRevisionKnown :: DGitRevisionInfo -> DGitRevision
DGitRevisionUnknown :: DGitRevision

-- | Repository settings for <a>DGitRevision</a>.
newtype GitRepoSettings
GitRepoSettings :: (Text -> Text) -> GitRepoSettings

-- | By commit sha make up a url to that commit in remote repository.
[grsMkGitRevision] :: GitRepoSettings -> Text -> Text

-- | Comment in the doc (mostly used for licenses)
data DComment
DComment :: Text -> DComment

-- | A hand-made anchor.
data DAnchor
DAnchor :: Anchor -> DAnchor

-- | Render documentation for <a>SubDoc</a>.
subDocToMarkdown :: HeaderLevel -> SubDoc -> Markdown

-- | Make a reference to doc item in definitions.
docDefinitionRef :: (DocItem d, DocItemPlacement d ~ DocItemInDefinitions) => Markdown -> d -> Markdown

-- | Get doc item position at term-level.
docItemPosition :: DocItem d => DocItemPos

-- | A piece of documentation describing one property of a thing, be it a
--   name or description of a contract, or an error throwable by given
--   endpoint.
--   
--   Items of the same type appear close to each other in a rendered
--   documentation and form a <i>section</i>.
--   
--   Doc items are later injected into a contract code via a dedicated
--   nop-like instruction. Normally doc items which belong to one section
--   appear in resulting doc in the same order in which they appeared in
--   the contract.
--   
--   While documentation framework grows, this typeclass acquires more and
--   more methods for fine tuning of existing rendering logic because we
--   don't want to break backward compatibility, hope one day we will make
--   everything concise :( E.g. all rendering and reording stuff could be
--   merged in one method, and we could have several template
--   implementations for it which would allow user to specify only stuff
--   relevant to his case.
class (Typeable d, DOrd d, KnownNat DocItemPosition d) => DocItem d where {
    
    -- | Position of this item in the resulting documentation; the smaller the
    --   value, the higher the section with this element will be placed.
    --   
    --   Documentation structure is not necessarily flat. If some doc item
    --   consolidates a whole documentation block within it, this block will
    --   have its own placement of items independent from outer parts of the
    --   doc.
    type family DocItemPosition d = (pos :: Nat) | pos -> d;
    
    -- | Defines where given doc item should be put. There are two options: 1.
    --   Inline right here (default behaviour); 2. Put into definitions
    --   section.
    --   
    --   Note that we require all doc items with "in definitions" placement to
    --   have <a>Eq</a> and <a>Ord</a> instances which comply the following
    --   law: if two documentation items describe the same entity or property,
    --   they should be considered equal.
    type family DocItemPlacement d :: DocItemPlacementKind;
}

-- | When multiple items of the same type belong to one section, how this
--   section will be called.
--   
--   If not provided, section will contain just untitled content.
docItemSectionName :: DocItem d => Maybe Text

-- | Description of a section.
--   
--   Can be used to mention some common things about all elements of this
--   section. Markdown syntax is permitted here.
docItemSectionDescription :: DocItem d => Maybe Markdown

-- | How to render section name.
--   
--   Takes effect only if section name is set.
docItemSectionNameStyle :: DocItem d => DocSectionNameStyle

-- | Defines a function which constructs an unique identifier of given doc
--   item, if it has been decided to put the doc item into definitions
--   section.
--   
--   Identifier should be unique both among doc items of the same type and
--   items of other types. Thus, consider using "typeId-contentId" pattern.
docItemRef :: DocItem d => d -> DocItemRef (DocItemPlacement d)

-- | Render given doc item to Markdown, preferably one line, optionally
--   with header.
--   
--   Accepts the smallest allowed level of header. (Using smaller value
--   than provided one will interfere with existing headers thus delivering
--   mess).
docItemToMarkdown :: DocItem d => HeaderLevel -> d -> Markdown

-- | All doc items which this doc item refers to.
--   
--   They will automatically be put to definitions as soon as given doc
--   item is detected.
docItemDependencies :: DocItem d => d -> [SomeDocDefinitionItem]

-- | This function accepts doc items put under the same section in the
--   order in which they appeared in the contract and returns their new
--   desired order. It's also fine to use this function for filtering or
--   merging doc items.
--   
--   Default implementation * leaves inlined items as is; * for items put
--   to definitions, lexicographically sorts them by their id.
docItemsOrder :: DocItem d => [d] -> [d]

-- | Some unique identifier of a doc item.
--   
--   All doc items which should be refer-able need to have this identifier.
newtype DocItemId
DocItemId :: Text -> DocItemId

-- | Where do we place given doc item.
data DocItemPlacementKind

-- | Placed in the document content itself.
DocItemInlined :: DocItemPlacementKind

-- | Placed in dedicated definitions section; can later be referenced.
DocItemInDefinitions :: DocItemPlacementKind

-- | Defines an identifier which given doc item can be referenced with.
data DocItemRef (p :: DocItemPlacementKind)
[DocItemRef] :: forall (p :: DocItemPlacementKind). () => DocItemId -> DocItemRef DocItemInDefinitions
[DocItemNoRef] :: forall (p :: DocItemPlacementKind). () => DocItemRef DocItemInlined

-- | How to render section name.
data DocSectionNameStyle

-- | Suitable for block name.
DocSectionNameBig :: DocSectionNameStyle

-- | Suitable for subsection title within block.
DocSectionNameSmall :: DocSectionNameStyle

-- | Hides some documentation item.
data SomeDocItem
[SomeDocItem] :: forall d. DocItem d => d -> SomeDocItem

-- | Hides some documentation item which is put to "definitions" section.
data SomeDocDefinitionItem
[SomeDocDefinitionItem] :: forall d. (DocItem d, DocItemPlacement d ~ DocItemInDefinitions) => d -> SomeDocDefinitionItem

-- | A part of documentation to be grouped. Essentially incapsulates
--   <a>DocBlock</a>.
newtype SubDoc
SubDoc :: DocBlock -> SubDoc

-- | Keeps documentation gathered for some piece of contract code.
--   
--   Used for building documentation of a contract.
data ContractDoc
ContractDoc :: DocBlock -> DocBlock -> Set SomeDocDefinitionItem -> Set DocItemId -> ContractDoc

-- | All inlined doc items.
[cdContents] :: ContractDoc -> DocBlock

-- | Definitions used in document.
--   
--   Usually you put some large and repetitive descriptions here. This
--   differs from the document content in that it contains sections which
--   are always at top-level, disregard the nesting.
--   
--   All doc items which define <tt>docItemId</tt> method go here, and only
--   they.
[cdDefinitions] :: ContractDoc -> DocBlock

-- | We remember all already declared entries to avoid cyclic dependencies
--   in documentation items discovery.
[cdDefinitionsSet] :: ContractDoc -> Set SomeDocDefinitionItem

-- | We remember all already used identifiers. (Documentation naturally
--   should not declare multiple items with the same identifier because
--   that would make references to the respective anchors ambiguous).
[cdDefinitionIds] :: ContractDoc -> Set DocItemId

-- | Representation of comparable value in Michelson language.
--   
--   By specification, we're allowed to compare only following types: int,
--   nat, string, bytes, mutez, bool, key_hash, timestamp, address.
--   
--   Only these values can be used as map keys or set elements.
data CValue (t :: CT)
[CvInt] :: forall (t :: CT). () => Integer -> CValue CInt
[CvNat] :: forall (t :: CT). () => Natural -> CValue CNat
[CvString] :: forall (t :: CT). () => MText -> CValue CString
[CvBytes] :: forall (t :: CT). () => ByteString -> CValue CBytes
[CvMutez] :: forall (t :: CT). () => Mutez -> CValue CMutez
[CvBool] :: forall (t :: CT). () => Bool -> CValue CBool
[CvKeyHash] :: forall (t :: CT). () => KeyHash -> CValue CKeyHash
[CvTimestamp] :: forall (t :: CT). () => Timestamp -> CValue CTimestamp
[CvAddress] :: forall (t :: CT). () => EpAddress -> CValue CAddress

-- | Address with optional entrypoint name attached to it. TODO: come up
--   with better name?
data EpAddress
EpAddress :: Address -> EpName -> EpAddress

-- | Address itself
[eaAddress] :: EpAddress -> Address

-- | Entrypoint name (might be empty)
[eaEntryPoint] :: EpAddress -> EpName
mkUType :: SingI x => Notes x -> Type

-- | Data type corresponding to address structure in Tezos.
data Address

-- | Quote a value of type <a>Timestamp</a> in
--   <tt>yyyy-mm-ddThh:mm:ss[.sss]Z</tt> format.
--   
--   <pre>
--   &gt;&gt;&gt; formatTimestamp [timestampQuote| 2019-02-21T16:54:12.2344523Z |]
--   "2019-02-21T16:54:12Z"
--   </pre>
--   
--   Inspired by 'time-quote' library.
timestampQuote :: QuasiQuoter
timestampFromUTCTime :: UTCTime -> Timestamp
timestampFromSeconds :: Integer -> Timestamp

-- | Safely create <a>Mutez</a>.
--   
--   This is recommended way to create <tt>Mutez</tt> from a numeric
--   literal; you can't construct all valid <tt>Mutez</tt> values using
--   this function but for small values it works neat.
--   
--   Warnings displayed when trying to construct invalid <a>Natural</a> or
--   <a>Word</a> literal are hardcoded for these types in GHC
--   implementation, so we can only exploit these existing rules.
toMutez :: Word32 -> Mutez

-- | Mutez is a wrapper over integer data type. 1 mutez is 1 token (μTz).
data Mutez

-- | Time in the real world. Use the functions below to convert it to/from
--   Unix time in seconds.
data Timestamp

-- | Identifier of a network (babylonnet, mainnet, test network or other).
--   Evaluated as hash of the genesis block.
--   
--   The only operation supported for this type is packing. Use case:
--   multisig contract, for instance, now includes chain ID into signed
--   data "in order to add extra replay protection between the main chain
--   and the test chain".
data ChainId

-- | Public cryptographic key used by Tezos. There are three cryptographic
--   curves each represented by its own constructor.
data PublicKey

-- | Cryptographic signatures used by Tezos. Constructors correspond to
--   <a>PublicKey</a> constructors.
--   
--   Tezos distinguishes signatures for different curves. For instance,
--   ed25519 signatures and secp256k1 signatures are printed differently
--   (have different prefix). However, signatures are packed without
--   information about the curve. For this purpose there is a generic
--   signature which only stores bytes and doesn't carry information about
--   the curve. Apparently unpacking from bytes always produces such
--   signature. Unpacking from string produces a signature with curve
--   information.
data Signature

-- | Blake2b_160 hash of a public key.
data KeyHash

-- | QuasyQuoter for constructing Michelson strings.
--   
--   Validity of result will be checked at compile time. Note:
--   
--   <ul>
--   <li>slash must be escaped</li>
--   <li>newline character must appear as '\n'</li>
--   <li>use quotes as is</li>
--   <li>other special characters are not allowed.</li>
--   </ul>
mt :: QuasiQuoter

-- | Michelson string value.
--   
--   This is basically a mere text with limits imposed by the language:
--   <a>https://tezos.gitlab.io/whitedoc/michelson.html#constants</a>
--   Although, this document seems to be not fully correct, and thus we
--   applied constraints deduced empirically.
--   
--   You construct an item of this type using one of the following ways:
--   
--   <ul>
--   <li>With QuasyQuotes when need to create a string literal.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; [mt|Some text|]
--   MTextUnsafe { unMText = "Some text" }
--   </pre>
--   
--   <ul>
--   <li>With <a>mkMText</a> when constructing from a runtime text
--   value.</li>
--   <li>With <a>mkMTextUnsafe</a> or <a>MTextUnsafe</a> when absolutelly
--   sure that given string does not violate invariants.</li>
--   <li>With <a>mkMTextCut</a> when not sure about text contents and want
--   to make it compliant with Michelson constraints.</li>
--   </ul>
data MText

-- | Proxy for a label type that includes the <a>KnownSymbol</a> constraint
data Label (name :: Symbol)
[Label] :: forall (name :: Symbol). KnownSymbol name => Label name
pattern DefEpName :: () => () => EpName

-- | Entrypoint name.
--   
--   Empty if this entrypoint is default one. Cannot be equal to "default",
--   the reference implementation forbids that. Also, set of allowed
--   characters should be the same as in annotations.
data EpName

-- | A piece of markdown document.
--   
--   This is opposed to <a>Text</a> type, which in turn is not supposed to
--   contain markup elements.
type Markdown = Builder

-- | Infix notation for the type of an optional named parameter.
type (:?) (name :: Symbol) a = NamedF Maybe a name

-- | Infix notation for the type of a named parameter.
type (:!) (name :: Symbol) a = NamedF Identity a name

-- | <a>error</a> that takes <a>Text</a> as an argument.
error :: HasCallStack => Text -> a

-- | <a>undefined</a> that leaves a warning in code on every usage.
undefined :: HasCallStack => a

-- | Infix application.
--   
--   <pre>
--   f :: Either String $ Maybe Int
--   =
--   f :: Either String (Maybe Int)
--   </pre>
type ($) (f :: k -> k1) (a :: k) = f a
infixr 2 $

-- | A variation of <a>arg</a> for optional arguments. Requires a default
--   value to handle the case when the optional argument was omitted:
--   
--   <pre>
--   fn (argDef #answer 42 -&gt; ans) = ...
--   </pre>
--   
--   In case you want to get a value wrapped in <a>Maybe</a> instead, use
--   <a>argF</a> or <a>ArgF</a>.
argDef :: () => Name name -> a -> (name :? a) -> a

-- | <a>argF</a> is similar to <a>arg</a>: it unwraps a named parameter
--   with the specified name. The difference is that the result of
--   <a>argF</a> is inside an arity wrapper, which is <a>Identity</a> for
--   normal parameters and <a>Maybe</a> for optional parameters.
argF :: () => Name name -> NamedF f a name -> f a

-- | <a>arg</a> unwraps a named parameter with the specified name. One way
--   to use it is to match on arguments with <tt>-XViewPatterns</tt>:
--   
--   <pre>
--   fn (arg #t -&gt; t) (arg #f -&gt; f) = ...
--   </pre>
--   
--   This way, the names of parameters can be inferred from the patterns:
--   no type signature for <tt>fn</tt> is required. In case a type
--   signature for <tt>fn</tt> is provided, the parameters must come in the
--   same order:
--   
--   <pre>
--   fn :: "t" :! Integer -&gt; "f" :! Integer -&gt; ...
--   fn (arg #t -&gt; t) (arg #f -&gt; f) = ... -- ok
--   fn (arg #f -&gt; f) (arg #t -&gt; t) = ... -- does not typecheck
--   </pre>
arg :: () => Name name -> (name :! a) -> a

-- | A record is parameterized by a universe <tt>u</tt>, an interpretation
--   <tt>f</tt> and a list of rows <tt>rs</tt>. The labels or indices of
--   the record are given by inhabitants of the kind <tt>u</tt>; the type
--   of values at any label <tt>r :: u</tt> is given by its interpretation
--   <tt>f r :: *</tt>.
data Rec (a :: u -> Type) (b :: [u]) :: forall u. () => u -> Type -> [u] -> Type
[RNil] :: forall u (a :: u -> Type) (b :: [u]). () => Rec a ([] :: [u])
[:&] :: forall u (a :: u -> Type) (b :: [u]) (r :: u) (rs :: [u]). () => !a r -> !Rec a rs -> Rec a (r : rs)
infixr 7 :&
type NiceComparable a = (KnownValue a, ProperComparabilityBetterErrors (ToT a))
type NicePrintedValue a = (KnownValue a, ProperPrintedValBetterErrors (ToT a))
type NiceFullPackedValue a = (NicePackedValue a, NiceUnpackedValue a)
type NiceUnpackedValue a = (KnownValue a, ProperUnpackedValBetterErrors (ToT a))
type NicePackedValue a = (KnownValue a, ProperPackedValBetterErrors (ToT a))
type NiceConstant a = (KnownValue a, ProperConstantBetterErrors (ToT a))
type NiceStorage a = (KnownValue a, ProperStorageBetterErrors (ToT a))

-- | Constraint applied to any part of parameter type.
--   
--   Note that you don't usually apply this constraint to the whole
--   parameter, consider using <a>NiceParameterFull</a> in such case.
--   
--   Using this type is justified e.g. when calling another contract, there
--   you usually supply an entrypoint argument, not the whole parameter.
type NiceParameter a = (KnownValue a, ProperParameterBetterErrors (ToT a))
class (IsoValue a, HasNoNestedBigMaps (ToT a)) => CanHaveBigMap a
class (IsoValue a, ForbidBigMap (ToT a)) => NoBigMap a
class (IsoValue a, ForbidContract (ToT a)) => NoContractType a

-- | Ensure given type does not contain "operation".
class (IsoValue a, ForbidOp (ToT a)) => NoOperation a
class (IsoValue a, Typeable (ToCT a), SingI (ToCT a)) => KnownCValue a

-- | Gathers constraints, commonly required for values.
class (IsoValue a, Typeable (ToT a), SingI (ToT a)) => KnownValue a
niceParameterEvi :: forall a. NiceParameter a :- ParameterScope (ToT a)
niceStorageEvi :: forall a. NiceStorage a :- StorageScope (ToT a)
niceConstantEvi :: forall a. NiceConstant a :- ConstantScope (ToT a)
nicePackedValueEvi :: forall a. NicePackedValue a :- PackedValScope (ToT a)
niceUnpackedValueEvi :: forall a. NiceUnpackedValue a :- UnpackedValScope (ToT a)
nicePrintedValueEvi :: forall a. NicePrintedValue a :- PrintedValScope (ToT a)

-- | A special type which wraps over a primitive type and states that it
--   has entrypoints (one).
--   
--   Assuming that any type can have entrypoints makes use of Lorentz
--   entrypoints too annoying, so for declaring entrypoints for not sum
--   types we require an explicit wrapper.
newtype ShouldHaveEntryPoints a
ShouldHaveEntryPoints :: a -> ShouldHaveEntryPoints a
[unHasEntryPoints] :: ShouldHaveEntryPoints a -> a

-- | Lifted <a>EDivOp</a>.
class (EDivOp (ToCT n) (ToCT m), IsComparable n, IsComparable m, ToT (EDivOpResHs n m) ~  'Tc (EDivOpRes (ToCT n) (ToCT m)), ToT (EModOpResHs n m) ~  'Tc (EModOpRes (ToCT n) (ToCT m))) => EDivOpHs n m where {
    type family EDivOpResHs n m :: Type;
    type family EModOpResHs n m :: Type;
}

-- | Lifted <a>SliceOp</a>.
class SliceOp (ToT c) => SliceOpHs c

-- | Lifted <a>ConcatOp</a>.
class ConcatOp (ToT c) => ConcatOpHs c

-- | Lifted <a>GetOp</a>.
class (GetOp (ToT c), ToT (GetOpKeyHs c) ~  'Tc (GetOpKey (ToT c)), ToT (GetOpValHs c) ~ GetOpVal (ToT c)) => GetOpHs c where {
    type family GetOpKeyHs c :: Type;
    type family GetOpValHs c :: Type;
}

-- | Lifted <a>UpdOp</a>.
class (UpdOp (ToT c), ToT (UpdOpKeyHs c) ~  'Tc (UpdOpKey (ToT c)), ToT (UpdOpParamsHs c) ~ UpdOpParams (ToT c)) => UpdOpHs c where {
    type family UpdOpKeyHs c :: Type;
    type family UpdOpParamsHs c :: Type;
}

-- | Lifted <a>SizeOp</a>.
--   
--   This could be just a constraint alias, but to avoid <a>T</a> types
--   appearance in error messages we make a full type class with concrete
--   instances.
class SizeOp (ToT c) => SizeOpHs c

-- | Lifted <a>IterOp</a>.
class (IterOp (ToT c), ToT (IterOpElHs c) ~ IterOpEl (ToT c)) => IterOpHs c where {
    type family IterOpElHs c :: Type;
}

-- | Lifted <a>MapOp</a>.
class (MapOp (ToT c), ToT (MapOpInpHs c) ~ MapOpInp (ToT c), ToT (MapOpResHs c ()) ~ MapOpRes (ToT c) (ToT ())) => MapOpHs c where {
    type family MapOpInpHs c :: Type;
    type family MapOpResHs c :: Type -> Type;
}

-- | A useful property which holds for reasonable <a>MapOp</a> instances.
--   
--   It's a separate thing from <a>MapOpHs</a> because it mentions
--   <tt>b</tt> type parameter.
type family IsoMapOpRes c b

-- | Lifted <a>MemOpKey</a>.
class (MemOp (ToT c), ToT (MemOpKeyHs c) ~  'Tc (MemOpKey (ToT c))) => MemOpHs c where {
    type family MemOpKeyHs c :: Type;
}
class GHasTypeAnn a
gGetTypeAnn :: GHasTypeAnn a => Notes (GValueType a)
class HasTypeAnn a
getTypeAnn :: HasTypeAnn a => Notes (ToT a)
getTypeAnn :: (HasTypeAnn a, GHasTypeAnn (Rep a), GValueType (Rep a) ~ ToT a) => Notes (ToT a)

-- | No entrypoints declared, parameter type will serve as argument type of
--   the only existing entrypoint (default one).
data EpdNone

-- | Check that the given entrypoint has some fields inside. This interface
--   allows for an abstraction of contract parameter so that it requires
--   some *minimal* specification, but not a concrete one.
type family ParameterContainsEntryPoints param (fields :: [NamedEp]) :: Constraint
type n :> ty =  'NamedEp n ty
infixr 0 :>

-- | Checks that the given parameter consists of some specific entrypoint.
--   Similar as <a>HasEntryPointArg</a> but ensures that the argument
--   matches the following datatype.
type HasEntryPointOfType param con exp = (GetEntryPointArgCustom param ( 'Just con) ~ exp, ParameterDeclaresEntryPoints param)

-- | This wrapper allows to pass untyped <a>EpName</a> and bypass checking
--   that entrypoint with given name and type exists.
newtype TrustEpName
TrustEpName :: EpName -> TrustEpName

-- | <a>HasEntryPointArg</a> constraint specialized to default entrypoint.
type HasDefEntryPointArg cp defEpName defArg = (defEpName ~ EntryPointRef  'Nothing, HasEntryPointArg cp defEpName defArg)

-- | When we call a Lorentz contract we should pass entrypoint name and
--   corresponding argument. Ideally we want to statically check that
--   parameter has entrypoint with given name and argument. Constraint
--   defined by this type class holds for contract with parameter
--   <tt>cp</tt> that have entrypoint matching <tt>name</tt> with type
--   <tt>arg</tt>.
--   
--   In order to check this property statically, we need to know entrypoint
--   name in compile time, <a>EntryPointRef</a> type serves this purpose.
--   If entrypoint name is not known, one can use <a>TrustEpName</a>
--   wrapper to take responsibility for presence of this entrypoint.
--   
--   If you want to call a function which has this constraint, you have two
--   options: 1. Pass contract parameter <tt>cp</tt> using type
--   application, pass <a>EntryPointRef</a> as a value and pass entrypoint
--   argument. Type system will check that <tt>cp</tt> has an entrypoint
--   with given reference and type. 2. Pass <a>EpName</a> wrapped into
--   <a>TrustEpName</a> and entrypoint argument. In this case passing
--   contract parameter is not necessary, you do not even have to know it.
class HasEntryPointArg cp name arg

-- | Data returned by this method may look somewhat arbitrary.
--   <a>EpName</a> is obviously needed because <tt>name</tt> can be
--   <a>EntryPointRef</a> or <a>TrustEpName</a>. <tt>Dict</tt> is returned
--   because in <a>EntryPointRef</a> case we get this evidence for free and
--   don't want to use it. We seem to always need it anyway.
useHasEntryPointArg :: HasEntryPointArg cp name arg => name -> (Dict (ParameterScope (ToT arg)), EpName)

-- | Universal entrypoint lookup.
type family GetEntryPointArgCustom cp mname :: Type

-- | Which entrypoint to call.
--   
--   We intentionally distinguish default and non-default cases because
--   this makes API more details-agnostic.
data EntryPointRef (mname :: Maybe Symbol)

-- | Call the default entrypoint, or root if no explicit default is
--   assigned.
[CallDefault] :: EntryPointRef  'Nothing

-- | Call the given entrypoint; calling default is not treated specially.
--   You have to provide entrypoint name via passing it as type argument.
--   
--   Unfortunatelly, here we cannot accept a label because in most cases
--   our entrypoints begin from capital letter (being derived from
--   constructor name), while labels must start from a lower-case letter,
--   and there is no way to make a conversion at type-level.
[Call] :: NiceEntryPointName name => EntryPointRef ( 'Just name)

-- | Similar to <a>ForbidExplicitDefaultEntryPoint</a>, but in a version
--   which the compiler can work with (and which produces errors confusing
--   for users :/)
type NoExplicitDefaultEntryPoint cp = Eval (LookupParameterEntryPoint cp DefaultEpName) ~  'Nothing

-- | Ensure that there is no explicit "default" entrypoint.
type ForbidExplicitDefaultEntryPoint cp = Eval (LiftM3 UnMaybe (Pure (Pure (() :: Constraint))) (TError ( 'Text "Parameter used here must have no explicit \"default\" entrypoint" :$$:  'Text "In parameter type `" :<>:  'ShowType cp :<>:  'Text "`")) (LookupParameterEntryPoint cp DefaultEpName))

-- | Get type of entrypoint with given name, fail if not found.
type GetDefaultEntryPointArg cp = Eval (LiftM2 FromMaybe (Pure cp) (LookupParameterEntryPoint cp DefaultEpName))

-- | Get type of entrypoint with given name, fail if not found.
type GetEntryPointArg cp name = Eval (LiftM2 FromMaybe (TError ( 'Text "Entrypoint not found: " :<>:  'ShowType name :$$:  'Text "In contract parameter `" :<>:  'ShowType cp :<>:  'Text "`")) (LookupParameterEntryPoint cp name))

-- | Lookup for entrypoint type by name.
--   
--   Does not treat default entrypoints in a special way.
type family LookupParameterEntryPoint (cp :: Type) :: Symbol -> Exp (Maybe Type)

-- | Get all entrypoints declared for parameter.
type family AllParameterEntryPoints (cp :: Type) :: [(Symbol, Type)]

-- | Parameter declares some entrypoints.
--   
--   This is a version of <a>ParameterHasEntryPoints</a> which we actually
--   use in constraints. When given type is a sum type or newtype, we refer
--   to <a>ParameterHasEntryPoints</a> instance, otherwise this instance is
--   not necessary.
type ParameterDeclaresEntryPoints cp = (If (CanHaveEntryPoints cp) (ParameterHasEntryPoints cp) (() :: Constraint), NiceParameter cp, EntryPointsDerivation (GetParameterEpDerivation cp) cp)

-- | Which entrypoints given parameter declares.
--   
--   Note that usually this function should not be used as constraint, use
--   <a>ParameterDeclaresEntryPoints</a> for this purpose.
class (EntryPointsDerivation (ParameterEntryPointsDerivation cp) cp, RequireAllUniqueEntryPoints cp) => ParameterHasEntryPoints cp where {
    type family ParameterEntryPointsDerivation cp :: Type;
}

-- | Ensure that all declared entrypoints are unique.
type RequireAllUniqueEntryPoints cp = RequireAllUniqueEntryPoints' (ParameterEntryPointsDerivation cp) cp

-- | Defines a generalized way to declare entrypoints for various parameter
--   types.
--   
--   When defining instances of this typeclass, set concrete <tt>deriv</tt>
--   argument and leave variable <tt>cp</tt> argument. Also keep in mind,
--   that in presence of explicit default entrypoint, all other <a>Or</a>
--   arms should be callable, though you can put this burden on user if
--   very necessary.
--   
--   Methods of this typeclass aim to better type-safety when making up an
--   implementation and they may be not too convenient to use; users should
--   exploit their counterparts.
class EntryPointsDerivation deriv cp where {
    
    -- | Name and argument of each entrypoint. This may include intermediate
    --   ones, even root if necessary.
    --   
    --   Touching this type family is costly (<tt>O(N^2)</tt>), don't use it
    --   often.
    --   
    --   Note [order of entrypoints children]: If this contains entrypoints
    --   referring to indermediate nodes (not leaves) in <tt>or</tt> tree, then
    --   each such entrypoint should be mentioned eariler than all of its
    --   children.
    type family EpdAllEntryPoints deriv cp :: [(Symbol, Type)];
    
    -- | Get entrypoint argument by name.
    type family EpdLookupEntryPoint deriv cp :: Symbol -> Exp (Maybe Type);
}

-- | Construct parameter annotations corresponding to expected entrypoints
--   set.
--   
--   This method is implementation detail, for actual notes construction
--   use <a>parameterEntryPointsToNotes</a>.
--   
--   TODO [#35]: Should also return field annotation
epdNotes :: EntryPointsDerivation deriv cp => Notes (ToT cp)

-- | Construct entrypoint caller.
--   
--   This does not treat calls to default entrypoint in a special way.
--   
--   This method is implementation detail, for actual entrypoint lookup use
--   <a>parameterEntryPointCall</a>.
epdCall :: (EntryPointsDerivation deriv cp, ParameterScope (ToT cp)) => Label name -> EpConstructionRes (ToT cp) (Eval (EpdLookupEntryPoint deriv cp name))

-- | Description of how each of the entrypoints is constructed.
epdDescs :: EntryPointsDerivation deriv cp => Rec EpCallingDesc (EpdAllEntryPoints deriv cp)

-- | Derive annotations for given parameter.
parameterEntryPointsToNotes :: forall cp. (Typeable cp, ParameterDeclaresEntryPoints cp) => ParamNotes (ToT cp)

-- | Prepare call to given entrypoint.
--   
--   This does not treat calls to default entrypoint in a special way. To
--   call default entrypoint properly use
--   <a>parameterEntryPointCallDefault</a>.
parameterEntryPointCall :: forall cp name. ParameterDeclaresEntryPoints cp => Label name -> EntryPointCall cp (GetEntryPointArg cp name)

-- | Call the default entrypoint.
parameterEntryPointCallDefault :: forall cp. ParameterDeclaresEntryPoints cp => EntryPointCall cp (GetDefaultEntryPointArg cp)

-- | Call root entrypoint safely.
sepcCallRootChecked :: forall cp. (NiceParameter cp, ForbidExplicitDefaultEntryPoint cp) => SomeEntryPointCall cp
eprName :: forall mname. EntryPointRef mname -> EpName

-- | Universal entrypoint calling.
parameterEntryPointCallCustom :: forall cp mname. ParameterDeclaresEntryPoints cp => EntryPointRef mname -> EntryPointCall cp (GetEntryPointArgCustom cp mname)

-- | Constraint applied to a whole parameter type.
type NiceParameterFull cp = (Typeable cp, ParameterDeclaresEntryPoints cp)
lPackValue :: forall a. NicePackedValue a => a -> ByteString
lUnpackValue :: forall a. NiceUnpackedValue a => ByteString -> Either UnpackError a
lEncodeValue :: forall a. NicePrintedValue a => a -> ByteString

-- | Wrap parameter into this to locally assign a way to derive entrypoints
--   for it.
newtype ParameterWrapper (deriv :: Type) cp
ParameterWrapper :: cp -> ParameterWrapper cp
[unParameterWraper] :: ParameterWrapper cp -> cp
type Lambda i o = '[i] :-> '[o]
type (&) (a :: Type) (b :: [Type]) = a : b
infixr 2 &
data SomeContract
[SomeContract] :: (NiceParameterFull cp, NiceStorage st) => ContractCode cp st -> SomeContract
type ContractCode cp st = '[(cp, st)] :-> ContractOut st
type ContractOut st = '[([Operation], st)]

-- | Alias for <a>:-&gt;</a>, seems to make signatures more readable
--   sometimes.
--   
--   Let's someday decide which one of these two should remain.
type (%>) = (:->)
infixr 1 %>

-- | Alias for instruction which hides inner types representation via
--   <tt>T</tt>.
newtype (inp :: [Type]) :-> (out :: [Type])
LorentzInstr :: RemFail Instr (ToTs inp) (ToTs out) -> (:->)
[unLorentzInstr] :: (:->) -> RemFail Instr (ToTs inp) (ToTs out)
infixr 1 :->
pattern FI :: (forall out'. Instr (ToTs inp) out') -> inp :-> out
pattern I :: Instr (ToTs inp) (ToTs out) -> inp :-> out
iGenericIf :: (forall s'. Instr (ToTs a) s' -> Instr (ToTs b) s' -> Instr (ToTs c) s') -> (a :-> s) -> (b :-> s) -> c :-> s
iAnyCode :: (inp :-> out) -> Instr (ToTs inp) (ToTs out)
iNonFailingCode :: HasCallStack => (inp :-> out) -> Instr (ToTs inp) (ToTs out)
iMapAnyCode :: (forall o'. Instr (ToTs i1) o' -> Instr (ToTs i2) o') -> (i1 :-> o) -> i2 :-> o
iForceNotFail :: (i :-> o) -> i :-> o

-- | Wrap Lorentz instruction with variable annotations, <tt>annots</tt>
--   list has to be non-empty, otherwise this function raises an error.
iWithVarAnnotations :: HasCallStack => [Text] -> (inp :-> out) -> inp :-> out
(#) :: (a :-> b) -> (b :-> c) -> a :-> c
infixl 8 #

-- | Version of <a>#</a> which performs some optimizations immediately.
(##) :: (a :-> b) -> (b :-> c) -> a :-> c

-- | Parse textual representation of a Michelson value and turn it into
--   corresponding Haskell value.
--   
--   Note: it won't work in some complex cases, e. g. if there is a lambda
--   which uses an instruction which depends on current contract's type.
--   Obviously it can not work, because we don't have any information about
--   a contract to which this value belongs (there is no such contract at
--   all).
parseLorentzValue :: forall v. (IsoValue v, SingI (ToT v), Typeable (ToT v)) => Text -> Either ParseLorentzError v

-- | Lorentz version of <a>transformStrings</a>.
transformStringsLorentz :: Bool -> (MText -> MText) -> (inp :-> out) -> inp :-> out

-- | Lorentz version of <a>transformBytes</a>.
transformBytesLorentz :: Bool -> (ByteString -> ByteString) -> (inp :-> out) -> inp :-> out
optimizeLorentzWithConf :: OptimizerConf -> (inp :-> out) -> inp :-> out
optimizeLorentz :: (inp :-> out) -> inp :-> out
stackRef :: forall (gn :: Nat) st n. (n ~ ToPeano gn, SingI n, KnownPeano n, RequireLongerThan st n) => PrintComment st
printComment :: PrintComment (ToTs s) -> s :-> s
testAssert :: (Typeable (ToTs out), HasCallStack) => Text -> PrintComment (ToTs inp) -> (inp :-> (Bool & out)) -> inp :-> inp
stackType :: forall s. s :-> s

-- | Version of <a>Entrypoint</a> which accepts no argument.
type Entrypoint_ store = '[store] :-> ContractOut store

-- | Single entrypoint of a contract.
--   
--   Note that we cannot make it return <tt>[[Operation], store]</tt>
--   because such entrypoint should've been followed by <tt>pair</tt>, and
--   this is not possible if entrypoint implementation ends with
--   <tt>failWith</tt>.
type Entrypoint param store = '[param, store] :-> ContractOut store

-- | Convert something from <tt>ContractAddr</tt> in <i>Haskell</i> world.
class FromContractRef (cp :: Type) (contract :: Type)
fromContractRef :: FromContractRef cp contract => ContractRef cp -> contract

-- | Convert something to <a>ContractRef</a> in <i>Haskell</i> world.
class ToContractRef (cp :: Type) (contract :: Type)
toContractRef :: (ToContractRef cp contract, HasCallStack) => contract -> ContractRef cp

-- | Convert something referring to a contract (not specific entrypoint) to
--   <a>TAddress</a> in <i>Haskell</i> world.
class ToTAddress (cp :: Type) (a :: Type)
toTAddress :: ToTAddress cp a => a -> TAddress cp

-- | Convert something to <a>Address</a> in <i>Haskell</i> world.
--   
--   Use this when you want to access state of the contract and are not
--   interested in calling it.
class ToAddress a
toAddress :: ToAddress a => a -> Address

-- | Address associated with value of <tt>contract arg</tt> type.
--   
--   Places where <a>ContractRef</a> can appear are now severely limited,
--   this type gives you type-safety of <a>ContractRef</a> but still can be
--   used everywhere. This type is not a full-featured one rather a helper;
--   in particular, once pushing it on stack, you cannot return it back to
--   Haskell world.
--   
--   Note that it refers to an entrypoint of the contract, not just the
--   contract as a whole. In this sense this type differs from
--   <a>TAddress</a>.
--   
--   Unlike with <a>ContractRef</a>, having this type you still cannot be
--   sure that the referred contract exists and need to perform a lookup
--   before calling it.
newtype FutureContract arg
FutureContract :: ContractRef arg -> FutureContract arg
[unFutureContract] :: FutureContract arg -> ContractRef arg

-- | Address which remembers the parameter type of the contract it refers
--   to.
--   
--   It differs from Michelson's <tt>contract</tt> type because it cannot
--   contain entrypoint, and it always refers to entire contract parameter
--   even if this contract has explicit default entrypoint.
newtype TAddress p
TAddress :: Address -> TAddress p
[unTAddress] :: TAddress p -> Address

-- | Turn <a>TAddress</a> to <a>ContractRef</a> in <i>Haskell</i> world.
--   
--   This is an analogy of <tt>address</tt> to <tt>contract</tt> convertion
--   in Michelson world, thus you have to supply an entrypoint (or call the
--   default one explicitly).
callingTAddress :: forall cp mname. NiceParameterFull cp => TAddress cp -> EntryPointRef mname -> ContractRef (GetEntryPointArgCustom cp mname)

-- | Specification of <tt>callTAddress</tt> to call the default entrypoint.
callingDefTAddress :: forall cp. NiceParameterFull cp => TAddress cp -> ContractRef (GetDefaultEntryPointArg cp)

-- | Cast something appropriate to <a>TAddress</a>.
toTAddress_ :: forall cp addr s. ToTAddress_ cp addr => (addr : s) :-> (TAddress cp : s)
convertContractRef :: forall cp contract2 contract1. (ToContractRef cp contract1, FromContractRef cp contract2) => contract1 -> contract2
type List = []

-- | Extension of <a>EpdPlain</a> on parameters being defined as several
--   nested datatypes.
--   
--   In particular, it will traverse the immediate sum type, and require
--   another <a>ParameterHasEntryPoints</a> for the inner complex
--   datatypes. Only those inner types are considered which are the only
--   fields in their respective constructors. Inner types should not
--   themselves declare default entrypoint, we enforce this for better
--   modularity. Each top-level constructor will be treated as entrypoint
--   even if it contains a complex datatype within, in such case that would
--   be an entrypoint corresponding to intermediate node in <tt>or</tt>
--   tree.
--   
--   Comparing to <a>EpdRecursive</a> this gives you more control over
--   where and how entrypoints will be derived.
data EpdDelegate

-- | Extension of <a>EpdPlain</a> on parameters being defined as several
--   nested datatypes.
--   
--   In particular, this will traverse sum types recursively, stopping at
--   Michelson primitives (like <a>Natural</a>) and constructors with
--   number of fields different from one.
--   
--   It does not assign names to intermediate nodes of <a>Or</a> tree, only
--   to the very leaves.
--   
--   If some entrypoint arguments have custom <a>IsoValue</a> instance,
--   this derivation way will not work. As a workaround, you can wrap your
--   argument into some primitive (e.g. <tt>:!</tt>).
data EpdRecursive

-- | Implementation of <a>ParameterHasEntryPoints</a> which fits for case
--   when your contract exposes multiple entrypoints via having sum type as
--   its parameter.
--   
--   In particular, each constructor would produce a homonymous entrypoint
--   with argument type equal to type of constructor field (each
--   constructor should have only one field). Constructor called
--   <a>Default</a> will designate the default entrypoint.
data EpdPlain
data CompilationOptions
CompilationOptions :: Bool -> CompilationOptions

-- | Flag which defines, whether compiled Michelson contract will have
--   <tt>CAST</tt> (which drops parameter annotations) as a first
--   instruction. Note, that when flag is false, there still can be no
--   <tt>CAST</tt> (in case when parameter type has no annotations).
[coDisableInitialCast] :: CompilationOptions -> Bool

-- | For use outside of Lorentz.
compileLorentz :: (inp :-> out) -> Instr (ToTs inp) (ToTs out)

-- | Version of <a>compileLorentz</a> specialized to instruction
--   corresponding to contract code.
compileLorentzContract :: forall cp st. (NiceParameterFull cp, NiceStorage st) => ContractCode cp st -> FullContract (ToT cp) (ToT st)

-- | Version on <a>compileLorentzContract</a> which accepts
--   <tt>CompilationOptions</tt>.
--   
--   Note that compiled contract can be ill-typed in terms of Michelson
--   code when some of the compilation options are used (e.g. when
--   coDoInitialCast is False, resulted contract can be ill-typed).
--   However, compilation with <tt>defaultCompilationOptions</tt> should be
--   valid.
compileLorentzContractWithOptions :: forall cp st. (NiceParameterFull cp, NiceStorage st) => CompilationOptions -> ContractCode cp st -> FullContract (ToT cp) (ToT st)

-- | Interpret a Lorentz instruction, for test purposes.
interpretLorentzInstr :: (IsoValuesStack inp, IsoValuesStack out) => ContractEnv -> (inp :-> out) -> Rec Identity inp -> Either MichelsonFailed (Rec Identity out)

-- | Like <a>interpretLorentzInstr</a>, but works on lambda rather than
--   arbitrary instruction.
interpretLorentzLambda :: (IsoValue inp, IsoValue out) => ContractEnv -> Lambda inp out -> inp -> Either MichelsonFailed out

-- | Lorentz version of analyzer.
analyzeLorentz :: (inp :-> out) -> AnalyzerRes

-- | Pretty-print a Haskell value as Michelson one.
printLorentzValue :: forall v. NicePrintedValue v => Bool -> v -> LText

-- | Pretty-print a Lorentz contract into Michelson code.
printLorentzContract :: forall cp st. (NiceParameterFull cp, NiceStorage st) => Bool -> ContractCode cp st -> LText

-- | Lifted <tt>UnaryAithOp</tt>.
class (UnaryArithOp aop (ToCT n), IsComparable n, Typeable (ToCT n), ToT (UnaryArithResHs aop n) ~  'Tc (UnaryArithRes aop (ToCT n))) => UnaryArithOpHs (aop :: Type) (n :: Type) where {
    type family UnaryArithResHs aop n :: Type;
}

-- | Lifted <tt>AithOp</tt>.
class (ArithOp aop (ToCT n) (ToCT m), IsComparable n, IsComparable m, Typeable (ToCT n), Typeable (ToCT m), ToT (ArithResHs aop n m) ~  'Tc (ArithRes aop (ToCT n) (ToCT m))) => ArithOpHs (aop :: Type) (n :: Type) (m :: Type) where {
    type family ArithResHs aop n m :: Type;
}

-- | Retain the value only if it is not zero.
nonZero :: NonZero t => (t : s) :-> (Maybe t : s)
class LorentzFunctor (c :: Type -> Type)
lmap :: (LorentzFunctor c, KnownValue b) => ((a : s) :-> (b : s)) -> (c a : s) :-> (c b : s)
type ConstraintDIPNLorentz (n :: Peano) (inp :: [Type]) (out :: [Type]) (s :: [Type]) (s' :: [Type]) = (ConstraintDIPN n (ToTs inp) (ToTs out) (ToTs s) (ToTs s'), ConstraintDIPN' Type n inp out s s')
type ConstraintDUGLorentz (n :: Peano) (inp :: [Type]) (out :: [Type]) (a :: Type) = (ConstraintDUG n (ToTs inp) (ToTs out) (ToT a), ConstraintDUG' Type n inp out a)
type ConstraintDIGLorentz (n :: Peano) (inp :: [Type]) (out :: [Type]) (a :: Type) = (ConstraintDIG n (ToTs inp) (ToTs out) (ToT a), ConstraintDIG' Type n inp out a)
nop :: s :-> s
drop :: (a & s) :-> s

-- | Drop top <tt>n</tt> elements from the stack.
dropN :: forall (n :: Nat) (s :: [Type]). (SingI (ToPeano n), KnownPeano (ToPeano n), RequireLongerOrSameLength (ToTs s) (ToPeano n), Drop (ToPeano n) (ToTs s) ~ ToTs (Drop (ToPeano n) s)) => s :-> Drop (ToPeano n) s
dup :: (a & s) :-> (a & (a & s))
swap :: (a & (b & s)) :-> (b & (a & s))

-- | Version of <a>dig</a> which uses Peano number. It is inteded for
--   internal usage in Lorentz.
digPeano :: forall (n :: Peano) inp out a. ConstraintDIGLorentz n inp out a => inp :-> out
dig :: forall (n :: Nat) inp out a. ConstraintDIGLorentz (ToPeano n) inp out a => inp :-> out

-- | Version of <a>dug</a> which uses Peano number. It is inteded for
--   internal usage in Lorentz.
dugPeano :: forall (n :: Peano) inp out a. ConstraintDUGLorentz n inp out a => inp :-> out
dug :: forall (n :: Nat) inp out a. ConstraintDUGLorentz (ToPeano n) inp out a => inp :-> out
push :: forall t s. NiceConstant t => t -> s :-> (t & s)
some :: (a & s) :-> (Maybe a & s)
none :: forall a s. KnownValue a => s :-> (Maybe a & s)
unit :: s :-> (() & s)
ifNone :: (s :-> s') -> ((a & s) :-> s') -> (Maybe a & s) :-> s'
pair :: (a & (b & s)) :-> ((a, b) & s)
car :: ((a, b) & s) :-> (a & s)
cdr :: ((a, b) & s) :-> (b & s)
left :: forall a b s. KnownValue b => (a & s) :-> (Either a b & s)
right :: forall a b s. KnownValue a => (b & s) :-> (Either a b & s)
ifLeft :: ((a & s) :-> s') -> ((b & s) :-> s') -> (Either a b & s) :-> s'
nil :: KnownValue p => s :-> (List p & s)
cons :: (a & (List a & s)) :-> (List a & s)
ifCons :: ((a & (List a & s)) :-> s') -> (s :-> s') -> (List a & s) :-> s'
size :: SizeOpHs c => (c & s) :-> (Natural & s)
emptySet :: KnownCValue e => s :-> (Set e & s)
emptyMap :: (KnownCValue k, KnownValue v) => s :-> (Map k v & s)
emptyBigMap :: (KnownCValue k, KnownValue v) => s :-> (BigMap k v & s)
map :: (MapOpHs c, IsoMapOpRes c b, HasCallStack) => ((MapOpInpHs c & s) :-> (b & s)) -> (c & s) :-> (MapOpResHs c b & s)
iter :: (IterOpHs c, HasCallStack) => ((IterOpElHs c & s) :-> s) -> (c & s) :-> s
mem :: MemOpHs c => (MemOpKeyHs c & (c & s)) :-> (Bool & s)
get :: GetOpHs c => (GetOpKeyHs c & (c & s)) :-> (Maybe (GetOpValHs c) & s)
update :: UpdOpHs c => (UpdOpKeyHs c & (UpdOpParamsHs c & (c & s))) :-> (c & s)
if_ :: (s :-> s') -> (s :-> s') -> (Bool & s) :-> s'
loop :: (s :-> (Bool & s)) -> (Bool & s) :-> s
loopLeft :: ((a & s) :-> (Either a b & s)) -> (Either a b & s) :-> (b & s)
lambda :: (ZipInstrs [i, o], KnownValue (ZippedStack i), KnownValue (ZippedStack o)) => (i :-> o) -> s :-> ((i :-> o) & s)
exec :: (a & (Lambda a b & s)) :-> (b & s)

-- | Similar to <a>exec</a> but works for lambdas with arbitrary size of
--   input and output.
--   
--   Note that this instruction has its arguments flipped, lambda goes
--   first. This seems to be the only reasonable way to achieve good
--   inference.
execute :: forall i o s. Each [KnownList, ZipInstr] [i, o] => ((i :-> o) : (i ++ s)) :-> (o ++ s)
apply :: forall a b c s. NiceConstant a => (a & (Lambda (a, b) c & s)) :-> (Lambda b c & s)
dip :: forall a s s'. HasCallStack => (s :-> s') -> (a & s) :-> (a & s')

-- | Version of <a>dipN</a> which uses Peano number. It is inteded for
--   internal usage in Lorentz.
dipNPeano :: forall (n :: Peano) (inp :: [Type]) (out :: [Type]) (s :: [Type]) (s' :: [Type]). ConstraintDIPNLorentz n inp out s s' => (s :-> s') -> inp :-> out
dipN :: forall (n :: Nat) (inp :: [Type]) (out :: [Type]) (s :: [Type]) (s' :: [Type]). ConstraintDIPNLorentz (ToPeano n) inp out s s' => (s :-> s') -> inp :-> out
failWith :: KnownValue a => (a & s) :-> t
cast :: KnownValue a => (a & s) :-> (a & s)
pack :: forall a s. NicePackedValue a => (a & s) :-> (ByteString & s)
unpack :: forall a s. NiceUnpackedValue a => (ByteString & s) :-> (Maybe a & s)
concat :: ConcatOpHs c => (c & (c & s)) :-> (c & s)
concat' :: ConcatOpHs c => (List c & s) :-> (c & s)
slice :: SliceOpHs c => (Natural & (Natural & (c & s))) :-> (Maybe c & s)
isNat :: (Integer & s) :-> (Maybe Natural & s)
add :: ArithOpHs Add n m => (n & (m & s)) :-> (ArithResHs Add n m & s)
sub :: ArithOpHs Sub n m => (n & (m & s)) :-> (ArithResHs Sub n m & s)
rsub :: ArithOpHs Sub n m => (m & (n & s)) :-> (ArithResHs Sub n m & s)
mul :: ArithOpHs Mul n m => (n & (m & s)) :-> (ArithResHs Mul n m & s)
ediv :: EDivOpHs n m => (n & (m & s)) :-> (Maybe (EDivOpResHs n m, EModOpResHs n m) & s)
abs :: UnaryArithOpHs Abs n => (n & s) :-> (UnaryArithResHs Abs n & s)
neg :: UnaryArithOpHs Neg n => (n & s) :-> (UnaryArithResHs Neg n & s)
lsl :: ArithOpHs Lsl n m => (n & (m & s)) :-> (ArithResHs Lsl n m & s)
lsr :: ArithOpHs Lsr n m => (n & (m & s)) :-> (ArithResHs Lsr n m & s)
or :: ArithOpHs Or n m => (n & (m & s)) :-> (ArithResHs Or n m & s)
and :: ArithOpHs And n m => (n & (m & s)) :-> (ArithResHs And n m & s)
xor :: ArithOpHs Xor n m => (n & (m & s)) :-> (ArithResHs Xor n m & s)
not :: UnaryArithOpHs Not n => (n & s) :-> (UnaryArithResHs Not n & s)
compare :: NiceComparable n => (n & (n & s)) :-> (Integer & s)
eq0 :: UnaryArithOpHs Eq' n => (n & s) :-> (UnaryArithResHs Eq' n & s)
neq0 :: UnaryArithOpHs Neq n => (n & s) :-> (UnaryArithResHs Neq n & s)
lt0 :: UnaryArithOpHs Lt n => (n & s) :-> (UnaryArithResHs Lt n & s)
gt0 :: UnaryArithOpHs Gt n => (n & s) :-> (UnaryArithResHs Gt n & s)
le0 :: UnaryArithOpHs Le n => (n & s) :-> (UnaryArithResHs Le n & s)
ge0 :: UnaryArithOpHs Ge n => (n & s) :-> (UnaryArithResHs Ge n & s)
int :: (Natural & s) :-> (Integer & s)

-- | Get a reference to the current contract.
--   
--   Note that, similar to <a>CONTRACT</a> instruction, in Michelson
--   <a>SELF</a> instruction can accept an entrypoint as field annotation,
--   and without annotation specified it creates a <tt>contract</tt> value
--   which calls the default entrypoint.
--   
--   This particular function carries the behaviour of <tt>SELF</tt> before
--   introduction of lightweight entrypoints feature. Thus the contract
--   must <b>not</b> have explicit "default" entrypoint for this to work.
--   
--   If you are going to call a specific entrypoint of the contract, see
--   <a>selfCalling</a>.
self :: forall p s. (NiceParameterFull p, ForbidExplicitDefaultEntryPoint p) => s :-> (ContractRef p & s)

-- | Make a reference to the current contract, maybe a specific entrypoint.
--   
--   Note that, since information about parameter of the current contract
--   is not carried around, in this function you need to specify parameter
--   type <tt>p</tt> explicitly.
selfCalling :: forall p mname s. NiceParameterFull p => EntryPointRef mname -> s :-> (ContractRef (GetEntryPointArgCustom p mname) & s)

-- | Get a reference to a contract by its address.
--   
--   This instruction carries the behaviour of <tt>CONTRACT</tt> before
--   introduction of lightweight entrypoints feature. The contract must
--   <b>not</b> have explicit "default" entrypoint for this to work.
--   
--   If you are going to call a specific entrypoint of the contract, see
--   <a>contractCalling</a>.
contract :: forall p addr s. (NiceParameterFull p, ForbidExplicitDefaultEntryPoint p, ToTAddress_ p addr) => (addr & s) :-> (Maybe (ContractRef p) & s)

-- | Make a reference to a contract, maybe a specific entrypoint.
--   
--   When calling this function, make sure that parameter type is known.
--   It's recommended that you supply <a>TAddress</a> with a concrete
--   parameter as the stack argument.
contractCalling :: forall cp epRef epArg addr s. (HasEntryPointArg cp epRef epArg, ToTAddress_ cp addr) => epRef -> (addr & s) :-> (Maybe (ContractRef epArg) & s)

-- | Specialized version of <a>contractCalling</a> for the case when you do
--   not have compile-time evidence of appropriate <a>HasEntryPointArg</a>.
--   For instance, if you have untyped <a>EpName</a> you can not have this
--   evidence (the value is only available in runtime). If you have typed
--   <a>EntryPointRef</a>, use <a>eprName</a> to construct <a>EpName</a>.
contractCallingUnsafe :: forall arg s. NiceParameter arg => EpName -> (Address & s) :-> (Maybe (ContractRef arg) & s)

-- | Version of <a>contract</a> instruction which may accept address with
--   already specified entrypoint name.
--   
--   Also you cannot specify entrypoint name here because this could result
--   in conflict.
runFutureContract :: forall p s. NiceParameter p => (FutureContract p & s) :-> (Maybe (ContractRef p) & s)

-- | Similar to <a>runFutureContract</a>, works with <a>EpAddress</a>.
--   
--   Validity of such operation cannot be ensured at compile time.
epAddressToContract :: forall p s. NiceParameter p => (EpAddress & s) :-> (Maybe (ContractRef p) & s)
transferTokens :: forall p s. NiceParameter p => (p & (Mutez & (ContractRef p & s))) :-> (Operation & s)
setDelegate :: (Maybe KeyHash & s) :-> (Operation & s)
createContract :: forall p g s. (NiceStorage g, NiceParameterFull p) => ContractCode p g -> (Maybe KeyHash & (Mutez & (g & s))) :-> (Operation & (Address & s))
implicitAccount :: (KeyHash & s) :-> (ContractRef () & s)
now :: s :-> (Timestamp & s)
amount :: s :-> (Mutez & s)
balance :: s :-> (Mutez & s)
checkSignature :: (PublicKey & (Signature & (ByteString & s))) :-> (Bool & s)
sha256 :: (ByteString & s) :-> (ByteString & s)
sha512 :: (ByteString & s) :-> (ByteString & s)
blake2B :: (ByteString & s) :-> (ByteString & s)
hashKey :: (PublicKey & s) :-> (KeyHash & s)

-- | <i>Warning: STEPS_TO_QUOTA instruction is deprecated in Michelson
--   005</i>
stepsToQuota :: s :-> (Natural & s)

-- | <i>Warning: Using <a>source</a> is considered a bad practice. Consider
--   using <a>sender</a> instead until further investigation</i>
source :: s :-> (Address & s)
sender :: s :-> (Address & s)
address :: (ContractRef a & s) :-> (Address & s)
chainId :: s :-> (ChainId & s)

-- | Execute given instruction on truncated stack.
--   
--   This instruction requires you to specify the piece of stack to
--   truncate as type argument.
framed :: forall s i o. (KnownList i, KnownList o) => (i :-> o) -> (i ++ s) :-> (o ++ s)

-- | Helper instruction.
--   
--   Checks whether given key present in the storage and fails if it is.
--   This instruction leaves stack intact.
failingWhenPresent :: forall c k s v st e. (MemOpHs c, k ~ MemOpKeyHs c, KnownValue e, st ~ (k & (v & (c & s)))) => (forall s0. (k : s0) :-> (e : s0)) -> st :-> st

-- | Like <a>update</a>, but throw an error on attempt to overwrite
--   existing entry.
updateNew :: forall c k s e. (UpdOpHs c, MemOpHs c, k ~ UpdOpKeyHs c, k ~ MemOpKeyHs c, KnownValue e) => (forall s0. (k : s0) :-> (e : s0)) -> (k & (UpdOpParamsHs c & (c & s))) :-> (c & s)

-- | Duplicate an element of stack referring it by type.
--   
--   If stack contains multiple entries of this type, compile error is
--   raised.
dupT :: forall a st. DupT st a st => st :-> (a : st)

-- | Dip repeatedly until element of the given type is on top of the stack.
--   
--   If stack contains multiple entries of this type, compile error is
--   raised.
dipT :: forall a inp dinp dout out. DipT inp a inp dinp dout out => (dinp :-> dout) -> inp :-> out

-- | Remove element with the given type from the stack.
dropT :: forall a inp dinp dout out. (DipT inp a inp dinp dout out, dinp ~ (a : dout)) => inp :-> out

-- | Put a document item.
doc :: DocItem di => di -> s :-> s

-- | Group documentation built in the given piece of code into block
--   dedicated to one thing, e.g. to one entrypoint.
docGroup :: DocGrouping -> (inp :-> out) -> inp :-> out

-- | Give a name to given contract. Apply it to the whole contract code.
contractName :: Text -> (inp :-> out) -> inp :-> out
buildLorentzDoc :: (inp :-> out) -> ContractDoc
renderLorentzDoc :: (inp :-> out) -> LText

-- | Leave only instructions related to documentation.
--   
--   This function is useful when your method executes a lambda coming from
--   outside, but you know its properties and want to propagate its
--   documentation to your contract code.
cutLorentzNonDoc :: (inp :-> out) -> s :-> s

-- | Collect all fields with the given marker.
type PickMarkedFields marker template = GPickMarkedFields marker (Rep template)

-- | Get kind of field.
type GetUStoreFieldMarker store name = FSMarker (GetUStore name store)

-- | Get type of plain field. This ignores marker with field type.
type GetUStoreField store name = FSValue (GetUStore name store)

-- | Get type of submap value.
type GetUStoreValue store name = MSValue (GetUStore name store)

-- | Get type of submap key.
type GetUStoreKey store name = MSKey (GetUStore name store)

-- | Allows to specify format of key under which fields of this type are
--   stored. Useful to avoid collisions.
class KnownUStoreMarker (marker :: UStoreMarkerType) where {
    
    -- | Display type-level information about UStore field with given marker
    --   and field value type. Used for error messages.
    type family ShowUStoreField marker v :: ErrorMessage;
    type ShowUStoreField marker v =  'Text "field of type " :<>:  'ShowType v;
}

-- | By field name derive key under which field should be stored.
mkFieldMarkerUKey :: KnownUStoreMarker marker => MText -> ByteString

-- | By field name derive key under which field should be stored.
mkFieldMarkerUKey :: KnownUStoreMarker marker => MText -> ByteString

-- | Just a plain field used as data.
type UStoreField = UStoreFieldExt UMarkerPlainField

-- | Specific kind used to designate markers for <a>UStoreFieldExt</a>.
--   
--   We suggest that fields may serve different purposes and so annotated
--   with special markers accordingly. See example below.
--   
--   This kind is implemented like that because we want markers to differ
--   from all other types in kind; herewith <a>UStoreMarkerType</a> is
--   still an open kind (has potentially infinite number of inhabitants).
type UStoreMarkerType = UStoreMarker -> Type

-- | Describes plain field in the storage.
newtype UStoreFieldExt (m :: UStoreMarkerType) (v :: Type)
UStoreField :: v -> UStoreFieldExt
[unUStoreField] :: UStoreFieldExt -> v

-- | Describes one virtual big map in the storage.
newtype k |~> v
UStoreSubMap :: Map k v -> (|~>) k v
[unUStoreSubMap] :: (|~>) k v -> Map k v

-- | Gathers multple fields and <a>BigMap</a>s under one object.
--   
--   Type argument of this datatype stands for a "store template" - a
--   datatype with one constructor and multiple fields, each containing an
--   object of type <a>UStoreFieldExt</a> or <a>|~&gt;</a> and
--   corresponding to single virtual field or <a>BigMap</a> respectively.
--   It's also possible to parameterize it with a larger type which is a
--   product of types satisfying the above property.
data UStore (a :: Type)

-- | Signature of <tt>userFailWith</tt>.
type FailUsingArg e name fieldTy s s' = (KnownSymbol name, IsError e, IsoValue fieldTy, CtorHasOnlyField name e fieldTy, Each [Typeable, SingI] '[ToT fieldTy], HasCallStack) => Label name -> fieldTy : s :-> s'

-- | Prompt an error message saying that <a>IsoValue</a> is not applicable
--   for this type.
type family CustomErrorNoIsoValue a

-- | Documentation for custom errors.
--   
--   Mentions that entrypoint throws given error.
data DThrows
[DThrows] :: ErrorHasDoc e => Proxy e -> DThrows

-- | Mentions that contract uses given error.
data DError
[DError] :: ErrorHasDoc e => Proxy e -> DError
class (KnownSymbol tag, TypeHasDoc (ErrorArg tag), IsError (CustomError tag)) => CustomErrorHasDoc tag

-- | What should happen for this error to be raised.
customErrDocMdCause :: CustomErrorHasDoc tag => Markdown

-- | Brief version of <a>customErrDocMdCause</a>. This will appear along
--   with the error when mentioned in entrypoint description.
--   
--   By default, the first sentence of the full description is used.
customErrDocMdCauseInEntrypoint :: CustomErrorHasDoc tag => Markdown

-- | Error class.
--   
--   By default this returns "unknown error" class; though you should
--   provide explicit implementation in order to avoid a warning.
customErrClass :: CustomErrorHasDoc tag => ErrorClass

-- | Clarification of error argument meaning.
--   
--   Provide when it's not obvious, e.g. argument is not named with
--   <tt>:!</tt>.
--   
--   NOTE: This should <i>not</i> be an entire sentence, rather just the
--   semantic backbone.
--   
--   Bad: * <tt>Error argument stands for the previous value of
--   approval.</tt>
--   
--   Good: * <tt>the previous value of approval</tt> * <tt>pair, first
--   argument of which is one thing, and the second is another</tt>
customErrArgumentSemantics :: CustomErrorHasDoc tag => Maybe Markdown

-- | Error class on how the error should be handled by the client.
data ErrorClass

-- | Normal expected error. Examples: "insufficient balance", "wallet does
--   not exist".
ErrClassActionException :: ErrorClass

-- | Invalid argument passed to entrypoint. Examples: your entrypoint
--   accepts an enum represented as <tt>nat</tt>, and unknown value is
--   provided. This includes more complex cases which involve multiple
--   entrypoints. E.g. API provides iterator interface, middleware should
--   care about using it hiding complex details and exposing a simpler API
--   to user; then an attempt to request non-existing element would also
--   correspond to an error from this class.
ErrClassBadArgument :: ErrorClass

-- | Unexpected error. Most likely it means that there is a bug in the
--   contract or the contract has been deployed incorrectly.
ErrClassContractInternal :: ErrorClass

-- | It's possible to leave error class unspecified.
ErrClassUnknown :: ErrorClass
type RequireNoArgError tag msg = (TypeErrorUnless (ErrorArg tag == ()) msg, msg ~ ( 'Text "Expected no-arg error, but given error requires argument of type " :<>:  'ShowType (ErrorArg tag)))

-- | Material custom error.
--   
--   Use this in pattern matches against error (e.g. in tests).
data CustomError (tag :: Symbol)
CustomError :: Label tag -> ErrorArg tag -> CustomError
[ceTag] :: CustomError -> Label tag
[ceArg] :: CustomError -> ErrorArg tag

-- | Declares a custom error, defining <tt>error name - error argument</tt>
--   relation.
--   
--   If your error is supposed to carry no argument, then provide
--   <tt>()</tt>.
--   
--   Note that this relation is defined globally rather than on
--   per-contract basis, so define errors accordingly. If your error has
--   argument specific to your contract, call it such that error name
--   reflects its belonging to this contract.
--   
--   This is the basic [error format].
type family ErrorArg (tag :: Symbol) :: Type

-- | Use this type as replacement for <tt>()</tt> when you <b>really</b>
--   want to leave error cause unspecified.
data UnspecifiedError
UnspecifiedError :: UnspecifiedError
class Typeable e => ErrorHasDoc (e :: Type) where {
    
    -- | Constraints which we require in a particular instance. You are not
    --   oblidged to often instantiate this correctly, it is only useful for
    --   some utilities.
    type family ErrorRequirements e :: Constraint;
    type ErrorRequirements e = ();
}

-- | Name of error as it appears in the corresponding section title.
errorDocName :: ErrorHasDoc e => Text

-- | What should happen for this error to be raised.
errorDocMdCause :: ErrorHasDoc e => Markdown

-- | Brief version of <a>errorDocMdCause</a>.
--   
--   This will appear along with the error when mentioned in entrypoint
--   description. By default, the first sentence of the full description is
--   used.
errorDocMdCauseInEntrypoint :: ErrorHasDoc e => Markdown

-- | How this error is represented in Haskell.
errorDocHaskellRep :: ErrorHasDoc e => Markdown

-- | Error class.
errorDocClass :: ErrorHasDoc e => ErrorClass

-- | Which definitions documentation for this error mentions.
errorDocDependencies :: ErrorHasDoc e => [SomeDocDefinitionItem]

-- | Captured constraints which we require in a particular instance. This
--   is a way to encode a bidirectional instance in the nowaday Haskell,
--   for <tt>class MyConstraint =&gt; ErrorHasDoc MyType</tt> instance it
--   lets deducing <tt>MyConstraint</tt> by <tt>ErrorHasDoc MyType</tt>.
--   
--   You are not oblidged to always instantiate, it is only useful for some
--   utilities which otherwise would not compile.
errorDocRequirements :: ErrorHasDoc e => Dict (ErrorRequirements e)

-- | Captured constraints which we require in a particular instance. This
--   is a way to encode a bidirectional instance in the nowaday Haskell,
--   for <tt>class MyConstraint =&gt; ErrorHasDoc MyType</tt> instance it
--   lets deducing <tt>MyConstraint</tt> by <tt>ErrorHasDoc MyType</tt>.
--   
--   You are not oblidged to always instantiate, it is only useful for some
--   utilities which otherwise would not compile.
errorDocRequirements :: (ErrorHasDoc e, ErrorRequirements e) => Dict (ErrorRequirements e)

-- | Haskell type representing error.
class (Typeable e, ErrorHasDoc e) => IsError e

-- | Converts a Haskell error into <tt>Value</tt> representation.
errorToVal :: IsError e => e -> (forall t. ErrorScope t => Value t -> r) -> r

-- | Converts a <tt>Value</tt> into Haskell error.
errorFromVal :: (IsError e, Typeable t, SingI t) => Value t -> Either Text e

-- | Implementation of <a>errorToVal</a> via <a>IsoValue</a>.
isoErrorToVal :: (KnownError e, IsoValue e) => e -> (forall t. ErrorScope t => Value t -> r) -> r

-- | Implementation of <a>errorFromVal</a> via <a>IsoValue</a>.
isoErrorFromVal :: (Typeable t, Typeable (ToT e), IsoValue e) => Value t -> Either Text e

-- | Fail with the given Haskell value.
failUsing :: forall e s t. IsError e => e -> s :-> t

-- | Fail, providing a reference to the place in the code where this
--   function is called.
--   
--   Like <a>error</a> in Haskell code, this instruction is for internal
--   errors only.
failUnexpected :: MText -> s :-> t

-- | Description of error representation in Haskell.
customErrorDocHaskellRepGeneral :: (SingI (ToT (ErrorArg tag)), IsError (CustomError tag), TypeHasDoc (ErrorArg tag), CustomErrorHasDoc tag) => Text -> Proxy tag -> Markdown

-- | Demote error tag to term level.
errorTagToMText :: Label tag -> MText
errorTagToText :: forall tag. KnownSymbol tag => Text

-- | Fail with given custom error.
failCustom :: forall tag err s any. (err ~ ErrorArg tag, CustomErrorHasDoc tag, KnownError err) => Label tag -> (err : s) :-> any

-- | Specialization of <a>failCustom</a> for no-arg errors.
failCustom_ :: forall tag s any notVoidErrorMsg. (RequireNoArgError tag notVoidErrorMsg, CustomErrorHasDoc tag) => Label tag -> s :-> any

-- | Implementation of <a>typeDocMdDescription</a> (of <a>TypeHasDoc</a>
--   typeclass) for Haskell types which sole purpose is to be error.
typeDocMdDescriptionReferToError :: forall e. IsError e => Markdown

-- | Implementation of <a>errorToVal</a> for custom errors.

-- | <i>Deprecated: Datatype error declarations has been deprecated</i>
customErrorToVal :: (LooseSumC e, HasCallStack) => e -> (forall t. ErrorScope t => Value t -> r) -> r

-- | Implementation of <a>errorFromVal</a> for custom errors.
--   
--   This function is deprecated.

-- | <i>Deprecated: Datatype error declarations has been deprecated</i>
customErrorFromVal :: forall t e. (SingI t, LooseSumC e) => Value t -> Either Text e

-- | Derive <a>IsError</a> instance for given type.
--   
--   This will also forbid deriving <a>IsoValue</a> instance for that type
--   to avoid having multiple different Michelson representations.

-- | <i>Deprecated: Datatype error declarations has been deprecated</i>
deriveCustomError :: Name -> Q [Dec]

-- | Fail with given error, picking argument for error from the top of the
--   stack.
--   
--   If your error constructor does not carry an argument, use
--   <a>failUsing</a> function instead. Consider the following practice:
--   once error datatype for your contract is defined, create a
--   specialization of this function to the error type.
--   
--   This function is deprecated.

-- | <i>Deprecated: Datatype error declarations has been deprecated</i>
failUsingArg :: forall err name fieldTy s s'. FailUsingArg err name fieldTy s s'

-- | Tags excluded from map.
type ErrorTagExclusions = HashSet MText

-- | This is a bidirectional map with correspondence between numeric and
--   textual error tags.
type ErrorTagMap = Bimap Natural MText

-- | Find all textual error tags that are used in typical <tt>FAILWITH</tt>
--   patterns within given instruction. Map them to natural numbers.
gatherErrorTags :: (inp :-> out) -> HashSet MText

-- | Add more error tags to an existing <a>ErrorTagMap</a>. It is useful
--   when your contract consists of multiple parts (e. g. in case of
--   contract upgrade), you have existing map for some part and want to add
--   tags from another part to it. You can pass empty map as existing one
--   if you just want to build <a>ErrorTagMap</a> from a set of textual
--   tags. See <a>buildErrorTagMap</a>.
addNewErrorTags :: ErrorTagMap -> HashSet MText -> ErrorTagMap

-- | Build <a>ErrorTagMap</a> from a set of textual tags.
buildErrorTagMap :: HashSet MText -> ErrorTagMap

-- | Remove some error tags from map. This way you say to remain these
--   string tags intact, while others will be converted to numbers when
--   this map is applied.
--   
--   Note that later you have to apply this map using
--   <a>applyErrorTagMapWithExclusions</a>, otherwise an error would be
--   raised.
excludeErrorTags :: HasCallStack => ErrorTagExclusions -> ErrorTagMap -> ErrorTagMap

-- | For each typical <a>FAILWITH</a> that uses a string to represent error
--   tag this function changes error tag to be a number using the supplied
--   conversion map. It assumes that supplied map contains all such strings
--   (and will error out if it does not). It will always be the case if you
--   gather all error tags using <a>gatherErrorTags</a> and build
--   <a>ErrorTagMap</a> from them using <a>addNewErrorTags</a>.
applyErrorTagMap :: HasCallStack => ErrorTagMap -> (inp :-> out) -> inp :-> out

-- | Similar to <a>applyErrorTagMap</a>, but for case when you have
--   excluded some tags from map via <a>excludeErrorTags</a>. Needed,
--   because both <a>excludeErrorTags</a> and this function do not tolerate
--   unknown errors in contract code (for your safety).
applyErrorTagMapWithExclusions :: HasCallStack => ErrorTagMap -> ErrorTagExclusions -> (inp :-> out) -> inp :-> out

-- | This function implements the simplest scenario of using this module's
--   functionality: 1. Gather all error tags from a single instruction. 2.
--   Turn them into error conversion map. 3. Apply this conversion.
useNumericErrors :: HasCallStack => (inp :-> out) -> (inp :-> out, ErrorTagMap)

-- | If you apply numeric error representation in your contract,
--   <a>errorFromVal</a> will stop working because it doesn't know about
--   this transformation. This function takes this transformation into
--   account. If a number is used as a tag, but it is not found in the
--   passed map, we conservatively preserve that number (because this whole
--   approach is rather a heuristic).
errorFromValNumeric :: (Typeable t, SingI t, IsError e) => ErrorTagMap -> Value t -> Either Text e

-- | Replacement for uninhabited type.
data Empty

-- | Witness of that this code is unreachable.
absurd_ :: (Empty : s) :-> s'

-- | Coercions between <tt>a</tt> to <tt>b</tt> are permitted and safe.
type Coercible_ a b = (MichelsonCoercible a b, CanCastTo a b, CanCastTo b a)

-- | Explicitly allowed coercions.
--   
--   <tt>a <a>CanCastTo</a> b</tt> proclaims that <tt>a</tt> can be casted
--   to <tt>b</tt> without violating any invariants of <tt>b</tt>.
--   
--   This relation is reflexive; it <i>may</i> be symmetric or not. It
--   tends to be composable: casting complex types usually requires
--   permission to cast their respective parts; for such types consider
--   using <a>castDummyG</a> as implementation of the method of this
--   typeclass.
--   
--   For cases when a cast from <tt>a</tt> to <tt>b</tt> requires some
--   validation, consider rather making a dedicated function which performs
--   the necessary checks and then calls <tt>forcedCoerce</tt>.
class a `CanCastTo` b

-- | An optional method which helps passing -Wredundant-constraints check.
--   Also, you can set specific implementation for it with specific sanity
--   checks.
castDummy :: CanCastTo a b => Proxy a -> Proxy b -> ()

-- | Whether two types have the same Michelson representation.
type MichelsonCoercible a b = ToT a ~ ToT b

-- | Coercion for Haskell world.
--   
--   We discourage using this function on Lorentz types, consider using
--   <tt>coerce</tt> instead. One of the reasons forthat is that in Lorentz
--   it's common to declare types as newtypes consisting of existing
--   primitives, and <tt>forcedCoerce</tt> tends to ignore all phantom type
--   variables of newtypes thus violating their invariants.
forcedCoerce :: Coercible a b => a -> b

-- | Convert between values of types that have the same representation.
--   
--   This function is not safe in a sense that this allows breaking
--   invariants of casted type (example: <tt>UStore</tt>) or may stop
--   compile on code changes (example: coercion of pair to a datatype with
--   two fields will break if new field is added). Still, produced
--   Michelson code will always be valid.
--   
--   Prefer using one of more specific functions from this module.
forcedCoerce_ :: MichelsonCoercible a b => (a & s) :-> (b & s)
gForcedCoerce_ :: MichelsonCoercible (t a) (t b) => (t a : s) :-> (t b : s)

-- | Convert between two stacks via failing.
fakeCoerce :: s1 :-> s2
fakeCoercing :: (s1 :-> s2) -> s1' :-> s2'

-- | Specialized version of <tt>coerce_</tt> to wrap into a haskell
--   newtype.
coerceWrap :: forall newtyp inner s. (inner ~ Unwrapped newtyp, MichelsonCoercible newtyp (Unwrapped newtyp)) => (inner : s) :-> (newtyp : s)

-- | Specialized version of <tt>coerce_</tt> to unwrap a haskell newtype.
coerceUnwrap :: forall newtyp inner s. (inner ~ Unwrapped newtyp, MichelsonCoercible newtyp (Unwrapped newtyp)) => (newtyp : s) :-> (inner : s)

-- | Lift given value to a named value.
toNamed :: Label name -> (a : s) :-> (NamedF Identity a name : s)

-- | Unpack named value.
fromNamed :: Label name -> (NamedF Identity a name : s) :-> (a : s)

-- | Coercion in Haskell world which respects <a>CanCastTo</a>.
checkedCoerce :: forall a b. (CanCastTo a b, Coercible a b) => a -> b

-- | Coerce between types which have an explicit permission for that in the
--   face of <a>CanCastTo</a> constraint.
checkedCoerce_ :: forall a b s. Castable_ a b => (a : s) :-> (b : s)

-- | Pretends that the top item of the stack was coerced.
checkedCoercing_ :: forall a b s. Coercible_ a b => ((b : s) :-> (b : s)) -> (a : s) :-> (a : s)

-- | Locally provide given <a>CanCastTo</a> instance.
allowCheckedCoerceTo :: forall b a. Dict (CanCastTo a b)

-- | Locally provide bidirectional <a>CanCastTo</a> instance.
allowCheckedCoerce :: forall a b. Dict (CanCastTo a b, CanCastTo b a)

-- | Implementation of <a>castDummy</a> for types composed from smaller
--   types. It helps to ensure that all necessary constraints are requested
--   in instance head.
castDummyG :: (Generic a, Generic b, GCanCastTo (Rep a) (Rep b)) => Proxy a -> Proxy b -> ()
type MigrationScript_ = MigrationScript SomeUTemplate SomeUTemplate

-- | Code of migration for <a>UStore</a>.
--   
--   Invariant: preferably should fit into op size / gas limits (quite
--   obvious). Often this stands for exactly one stage of migration (one
--   Tezos transaction).
newtype MigrationScript (oldStore :: Type) (newStore :: Type)
MigrationScript :: Lambda UStore_ UStore_ -> MigrationScript
[unMigrationScript] :: MigrationScript -> Lambda UStore_ UStore_

-- | Keeps information about migration between <a>UStore</a>s with two
--   given templates.
data UStoreMigration (oldTempl :: Type) (newTempl :: Type)

-- | Turn <tt>Migration</tt> into a whole piece of code for transforming
--   storage.
--   
--   This is not want you'd want to use for contract deployment because of
--   gas and operation size limits that Tezos applies to transactions.
migrationToLambda :: UStoreMigration oldTemplate newTemplate -> Lambda (UStore oldTemplate) (UStore newTemplate)

-- | Safe way to create migration scripts for <a>UStore</a>.
--   
--   You have to supply a code which would transform <a>MUStore</a>,
--   coverring required diff step-by-step. All basic instructions work,
--   also use <tt>migrate*</tt> functions from this module to operate with
--   <a>MUStore</a>.
--   
--   This method produces a whole migration, it cannot be splitted in
--   batches. In case if your migration is too big to be applied within a
--   single transaction, use <a>mkUStoreBatchedMigration</a>.
mkUStoreMigration :: Lambda (MUStore oldTempl newTempl (BuildDiff oldTempl newTempl) '[]) (MUStore oldTempl newTempl '[] _1) -> UStoreMigration oldTempl newTempl

-- | Get migration script in case of simple (non-batched) migration.
migrationToScriptI :: UStoreMigration os ns -> Identity (MigrationScript os ns)

-- | Get migration script in case of simple (non-batched) migration.
migrationToScript :: UStoreMigration os ns -> MigrationScript os ns

-- | Lift an <a>UStore</a> to another <a>UStore</a> which contains all the
--   entries of the former under given field.
--   
--   This function is not intended for use in migrations, only in normal
--   entry points.
--   
--   Note that this function ensures that template of resulting store does
--   not contain inner nested templates with duplicated fields, otherwise
--   <a>UStore</a> invariants could get broken.
liftUStore :: (Generic template, RequireAllUniqueFields template) => Label name -> (UStore (GetFieldType template name) : s) :-> (UStore template : s)

-- | Unlift an <a>UStore</a> to a smaller <a>UStore</a> which is part of
--   the former.
--   
--   This function is not intended for use in migrations, only in normal
--   entry points.
--   
--   Surprisingly, despite smaller <a>UStore</a> may have extra entries,
--   this function is safe when used in contract code. Truly, all getters
--   and setters are still safe to use. Also, there is no way for the
--   resulting small <tt>UStore</tt> to leak outside of the contract since
--   the only place where <tt>big_map</tt> can appear is contract storage,
--   so this small <tt>UStore</tt> can be either dropped or lifted back via
--   <a>liftUStore</a> to appear as part of the new contract's state.
--   
--   When this function is run as part of standalone instructions sequence,
--   not as part of contract code (e.g. in tests), you may get an
--   <tt>UStore</tt> with entries not inherent to it.
unliftUStore :: Generic template => Label name -> (UStore template : s) :-> (UStore (GetFieldType template name) : s)

-- | Newtype over void result type used in tests to distinguish successful
--   void result from other errors.
--   
--   Usage example: lExpectFailWith (== VoidResult roleMaster)`
--   
--   This error is special - it can contain arguments of different types
--   depending on entrypoint which raises it.
newtype VoidResult r
VoidResult :: r -> VoidResult r
[unVoidResult] :: VoidResult r -> r

-- | <tt>void</tt> type synonym as described in A1.
data Void_ (a :: Type) (b :: Type)
Void_ :: a -> Lambda b b -> Void_

-- | Entry point argument.
[voidParam] :: Void_ -> a

-- | Type of result reported via <a>failWith</a>.
[voidResProxy] :: Void_ -> Lambda b b

-- | <tt>view</tt> type synonym as described in A1.
data View (a :: Type) (r :: Type)
View :: a -> ContractRef r -> View
[viewParam] :: View -> a
[viewCallbackTo] :: View -> ContractRef r
class UpdateN (n :: Peano) (s :: [Type]) (a :: Type) (b :: Type) mid tail
updateNImpl :: UpdateN n s a b mid tail => ('[a, b] :-> '[b]) -> (a : s) :-> s

-- | Constraint for updateN that combines kind-agnostic constraint for
--   Lorentz (Haskell) types and for our typed Michelson.
type ConstraintUpdateNLorentz (n :: Peano) (s :: [Type]) (a :: Type) (b :: Type) (mid :: [Type]) (tail :: [Type]) = (UpdateNConstraint' T n (ToTs s) (ToT a) (ToT b) (ToTs mid) (ToTs tail), UpdateNConstraint' Type n s a b mid tail)
class ReplaceN (n :: Peano) (s :: [Type]) (a :: Type) mid tail
replaceNImpl :: ReplaceN n s a mid tail => (a : s) :-> s

-- | Constraint for replaceN that combines kind-agnostic constraint for
--   Lorentz (Haskell) types and for our typed Michelson.
type ConstraintReplaceNLorentz (n :: Peano) (s :: [Type]) (a :: Type) (mid :: [Type]) (tail :: [Type]) = (ReplaceNConstraint' T n (ToTs s) (ToT a) (ToTs mid) (ToTs tail), ReplaceNConstraint' Type n s a mid tail)

-- | Insert given element into map.
mapInsert :: (MapInstrs map, IsComparable k) => (k : (v : (map k v : s))) :-> (map k v : s)

-- | Insert given element into map, ensuring that it does not overwrite any
--   existing entry.
--   
--   As first argument accepts container name (for error message).
mapInsertNew :: (MapInstrs map, IsComparable k, KnownValue e) => (forall s0. (k : s0) :-> (e : s0)) -> (k : (v : (map k v : s))) :-> (map k v : s)

-- | Delete element from the map.
deleteMap :: forall k v s. (MapInstrs map, IsComparable k, KnownValue k, KnownValue v) => (k : (map k v : s)) :-> (map k v : s)
class DuupX (n :: Peano) (s :: [Type]) (a :: Type) s1 tail
duupXImpl :: DuupX n s a s1 tail => s :-> (a : s)

-- | Constraint for duupX that combines kind-agnostic constraint for
--   Lorentz (Haskell) types and for our typed Michelson.
type ConstraintDuupXLorentz (n :: Peano) (s :: [Type]) (a :: Type) (s1 :: [Type]) (tail :: [Type]) = (DuupXConstraint' T n (ToTs s) (ToT a) (ToTs s1) (ToTs tail), DuupXConstraint' Type n s a s1 tail)
eq :: NiceComparable n => (n & (n & s)) :-> (Bool & s)
neq :: NiceComparable n => (n & (n & s)) :-> (Bool & s)
gt :: NiceComparable n => (n & (n & s)) :-> (Bool & s)
le :: NiceComparable n => (n & (n & s)) :-> (Bool & s)
ge :: NiceComparable n => (n & (n & s)) :-> (Bool & s)
lt :: NiceComparable n => (n & (n & s)) :-> (Bool & s)
ifEq0 :: IfCmp0Constraints a Eq' => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifNeq0 :: IfCmp0Constraints a Neq => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifLt0 :: IfCmp0Constraints a Lt => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifGt0 :: IfCmp0Constraints a Gt => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifLe0 :: IfCmp0Constraints a Le => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifGe0 :: IfCmp0Constraints a Ge => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifEq :: NiceComparable a => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifNeq :: NiceComparable a => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifLt :: NiceComparable a => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifGt :: NiceComparable a => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifLe :: NiceComparable a => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifGe :: NiceComparable a => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'

-- | Analog of the FAIL macro in Michelson. Its usage is discouraged
--   because it doesn't carry any information about failure.

-- | <i>Warning: <a>fail_</a> remains in code</i>
fail_ :: a :-> c
assert :: IsError err => err -> (Bool & s) :-> s
assertEq0 :: (IfCmp0Constraints a Eq', IsError err) => err -> (a & s) :-> s
assertNeq0 :: (IfCmp0Constraints a Neq, IsError err) => err -> (a & s) :-> s
assertLt0 :: (IfCmp0Constraints a Lt, IsError err) => err -> (a & s) :-> s
assertGt0 :: (IfCmp0Constraints a Gt, IsError err) => err -> (a & s) :-> s
assertLe0 :: (IfCmp0Constraints a Le, IsError err) => err -> (a & s) :-> s
assertGe0 :: (IfCmp0Constraints a Ge, IsError err) => err -> (a & s) :-> s
assertEq :: (NiceComparable a, IsError err) => err -> (a & (a & s)) :-> s
assertNeq :: (NiceComparable a, IsError err) => err -> (a & (a & s)) :-> s
assertLt :: (NiceComparable a, IsError err) => err -> (a & (a & s)) :-> s
assertGt :: (NiceComparable a, IsError err) => err -> (a & (a & s)) :-> s
assertLe :: (NiceComparable a, IsError err) => err -> (a & (a & s)) :-> s
assertGe :: (NiceComparable a, IsError err) => err -> (a & (a & s)) :-> s
assertNone :: IsError err => err -> (Maybe a & s) :-> s
assertSome :: IsError err => err -> (Maybe a & s) :-> (a & s)
assertLeft :: IsError err => err -> (Either a b & s) :-> (a & s)
assertRight :: IsError err => err -> (Either a b & s) :-> (b & s)
assertUsing :: IsError a => a -> (Bool & s) :-> s

-- | Custom Lorentz macro that drops element with given index (starting
--   from 0) from the stack.
dropX :: forall (n :: Nat) a inp out s s'. (ConstraintDIPNLorentz (ToPeano n) inp out s s', s ~ (a : s')) => inp :-> out

-- | Duplicate the top of the stack <tt>n</tt> times.
--   
--   For example, `cloneX @3` has type `a &amp; s :-&gt; a &amp; a &amp; a
--   &amp; a &amp; s`.
cloneX :: forall (n :: Nat) a s. CloneX (ToPeano n) a s => (a & s) :-> CloneXT (ToPeano n) a s

-- | <tt>DUU+P</tt> macro. For example, `duupX @3` is <tt>DUUUP</tt>, it
--   puts the 3-rd (starting from 1) element to the top of the stack. Note
--   that it is implemented differently for `n ≤ 2` and for `n &gt; 2`. In
--   the latter case it is implemented using <a>dipN</a>, <a>dig</a> and
--   <a>dup</a>. In the former case it uses specialized versions. There is
--   also a minor difference with the implementation of `DUU*P` in
--   Michelson. They implement <tt>DUUUUP</tt> as `DIP 3 { DUP }; DIG 4`.
--   We implement it as `DIP 3 { DUP }; DIG 3`. These are equivalent. Our
--   version is supposedly cheaper, at least it should be packed more
--   efficiently due to the way numbers are packed.
duupX :: forall (n :: Nat) a (s :: [Type]) (s1 :: [Type]) (tail :: [Type]). (ConstraintDuupXLorentz (ToPeano (n - 1)) s a s1 tail, DuupX (ToPeano n) s a s1 tail) => s :-> (a : s)

-- | Version of <a>framed</a> which accepts number of elements on input
--   stack which should be preserved.
--   
--   You can treat this macro as calling a Michelson function with given
--   number of arguments.
framedN :: forall n nNat s i i' o o'. (nNat ~ ToPeano n, i' ~ Take nNat i, s ~ Drop nNat i, i ~ (i' ++ s), o ~ (o' ++ s), KnownList i', KnownList o') => (i' :-> o') -> i :-> o
papair :: (a & (b & (c & s))) :-> (((a, b), c) & s)
ppaiir :: (a & (b & (c & s))) :-> ((a, (b, c)) & s)
unpair :: ((a, b) & s) :-> (a & (b & s))
cdar :: ((a1, (a2, b)) & s) :-> (a2 & s)
cddr :: ((a1, (a2, b)) & s) :-> (b & s)
caar :: (((a, b1), b2) & s) :-> (a & s)
cadr :: (((a, b1), b2) & s) :-> (b1 & s)
setCar :: ((a, b1) & (b2 & s)) :-> ((b2, b1) & s)
setCdr :: ((a, b1) & (b2 & s)) :-> ((a, b2) & s)
mapCar :: ((a & s) :-> (a1 & s)) -> ((a, b) & s) :-> ((a1, b) & s)
mapCdr :: ((b & ((a, b) & s)) :-> (b1 & ((a, b) & s))) -> ((a, b) & s) :-> ((a, b1) & s)
ifRight :: ((b & s) :-> s') -> ((a & s) :-> s') -> (Either a b & s) :-> s'
ifSome :: ((a & s) :-> s') -> (s :-> s') -> (Maybe a & s) :-> s'
when_ :: (s :-> s) -> (Bool : s) :-> s
unless_ :: (s :-> s) -> (Bool : s) :-> s
whenSome :: ((a : s) :-> s) -> (Maybe a : s) :-> s

-- | Insert given element into set.
--   
--   This is a separate function from <tt>updateMap</tt> because stacks
--   they operate with differ in length.
setInsert :: IsComparable e => (e & (Set e & s)) :-> (Set e & s)

-- | Insert given element into set, ensuring that it does not overwrite any
--   existing entry.
--   
--   As first argument accepts container name.
setInsertNew :: (IsComparable e, KnownValue err) => (forall s0. (e : s0) :-> (err : s0)) -> (e & (Set e & s)) :-> (Set e & s)

-- | Delete given element from the set.
setDelete :: IsComparable e => (e & (Set e & s)) :-> (Set e & s)

-- | Replace nth element (0-indexed) with the one on the top of the stack.
--   For example, `replaceN <tt>3` replaces the 3rd element with the 0th
--   one. `replaceN </tt>0` is not a valid operation (and it is not
--   implemented). `replaceN <tt>1` is equivalent to `swap # drop` (and is
--   the only one implemented like this). In all other cases `replaceN
--   </tt>n` will drop the nth element (`dipN <tt>n drop`) and then put the
--   0th one in its place (`dug </tt>(n-1)`).
replaceN :: forall (n :: Nat) a (s :: [Type]) (s1 :: [Type]) (tail :: [Type]). (ConstraintReplaceNLorentz (ToPeano (n - 1)) s a s1 tail, ReplaceN (ToPeano n) s a s1 tail) => (a : s) :-> s

-- | Replaces the nth element (0-indexed) with the result of the given
--   "updating" instruction (binary with the return type equal to the
--   second argument) applied to the 0th element and the nth element
--   itself. For example, `updateN <tt>3 cons` replaces the 3rd element
--   with the result of <a>cons</a> applied to the topmost element and the
--   3rd one. `updateN </tt>0 instr` is not a valid operation (and it is
--   not implemented). `updateN <tt>1 instr` is equivalent to
--   <tt>instr</tt> (and so is implemented). `updateN </tt>2 instr` is
--   equivalent to `swap # dip instr` (and so is implemented). In all other
--   cases `updateN <tt>n instr` will put the topmost element right above
--   the nth one (`dug </tt>(n-1)`) and then apply the function to them in
--   place (`dipN @(n-1) instr`).
updateN :: forall (n :: Nat) a b (s :: [Type]) (mid :: [Type]) (tail :: [Type]). (ConstraintUpdateNLorentz (ToPeano (n - 1)) s a b mid tail, UpdateN (ToPeano n) s a b mid tail) => ('[a, b] :-> '[b]) -> (a : s) :-> s
buildViewTuple :: TupleF a => View a r -> Builder
buildView :: (a -> Builder) -> View a r -> Builder

-- | Polymorphic version of <a>View</a> constructor.
mkView :: ToContractRef r contract => a -> contract -> View a r

-- | Wrap internal representation of view into <a>View</a> itself.
--   
--   <a>View</a> is part of public standard and should not change often.
wrapView :: ((a, ContractRef r) : s) :-> (View a r : s)

-- | Unwrap <a>View</a> into its internal representation.
--   
--   <a>View</a> is part of public standard and should not change often.
unwrapView :: (View a r : s) :-> ((a, ContractRef r) : s)
view_ :: NiceParameter r => (forall s0. ((a, storage) & s0) :-> (r : s0)) -> (View a r & (storage & s)) :-> ((List Operation, storage) & s)
voidResultTag :: MText
mkVoid :: forall b a. a -> Void_ a b
void_ :: forall a b s s' anything. (IsError (VoidResult b), KnownValue b) => ((a & s) :-> (b & s')) -> (Void_ a b & s) :-> anything
addressToEpAddress :: (Address : s) :-> (EpAddress : s)

-- | Push a value of <tt>contract</tt> type.
--   
--   Doing this via <a>push</a> instruction is not possible, so we need to
--   perform extra actions here.
--   
--   Aside from <tt>contract</tt> value itself you will need to specify
--   which error to throw in case this value is not valid.
pushContractRef :: NiceParameter arg => (forall s0. (FutureContract arg : s) :-> s0) -> ContractRef arg -> s :-> (ContractRef arg : s)

-- | Write down all sensisble constraints which given <tt>store</tt>
--   satisfies and apply them to <tt>constrained</tt>.
--   
--   This store should have <a>|~&gt;</a> and <a>UStoreFieldExt</a> fields
--   in its immediate fields, no deep inspection is performed.
type HasUStoreForAllIn store constrained = (Generic store, GHasStoreForAllIn constrained (Rep store))

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some field of it.
type HasUField name ty store = (FieldAccessC store name, GetUStoreField store name ~ ty)

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some submap(s) of it.
--   
--   It can use all UStore operations for a particular name, key and value
--   without knowing whole template.
type HasUStore name key value store = (KeyAccessC store name, ValueAccessC store name, GetUStoreKey store name ~ key, GetUStoreValue store name ~ value)
ustoreMem :: forall store name s. KeyAccessC store name => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (Bool : s)
ustoreGet :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (Maybe (GetUStoreValue store name) : s)
ustoreUpdate :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (Maybe (GetUStoreValue store name) : (UStore store : s))) :-> (UStore store : s)
ustoreInsert :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (GetUStoreValue store name : (UStore store : s))) :-> (UStore store : s)

-- | Insert a key-value pair, but fail if it will overwrite some existing
--   entry.
ustoreInsertNew :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (forall s0 any. (GetUStoreKey store name : s0) :-> any) -> (GetUStoreKey store name : (GetUStoreValue store name : (UStore store : s))) :-> (UStore store : s)
ustoreDelete :: forall store name s. KeyAccessC store name => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (UStore store : s)

-- | Like <tt>toField</tt>, but for <a>UStore</a>.
--   
--   This may fail only if <a>UStore</a> was made up incorrectly during
--   contract initialization.
ustoreToField :: forall store name s. FieldAccessC store name => Label name -> (UStore store : s) :-> (GetUStoreField store name : s)

-- | Like <tt>getField</tt>, but for <a>UStore</a>.
--   
--   This may fail only if <a>UStore</a> was made up incorrectly during
--   contract initialization.
ustoreGetField :: forall store name s. FieldAccessC store name => Label name -> (UStore store : s) :-> (GetUStoreField store name : (UStore store : s))

-- | Like <tt>setField</tt>, but for <a>UStore</a>.
ustoreSetField :: forall store name s. FieldAccessC store name => Label name -> (GetUStoreField store name : (UStore store : s)) :-> (UStore store : s)

-- | Get a field present in old version of <a>UStore</a>.
migrateGetField :: forall field oldTempl newTempl diff touched fieldTy s. (HasUField field fieldTy oldTempl, RequireUntouched field (field `IsElem` touched)) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (fieldTy : (MUStore oldTempl newTempl diff touched : s))

-- | Add a field which was not present before. This covers one addition
--   from the diff and any removals of field with given name.
--   
--   This function cannot overwrite existing field with the same name, if
--   this is necessary use <a>migrateOverwriteField</a> which would declare
--   removal explicitly.
migrateAddField :: forall field oldTempl newTempl diff touched fieldTy newDiff marker s. ('(UStoreFieldExt marker fieldTy, newDiff) ~ CoverDiff  'DcAdd field diff, HasUField field fieldTy newTempl) => Label field -> (fieldTy : (MUStore oldTempl newTempl diff touched : s)) :-> (MUStore oldTempl newTempl newDiff (field : touched) : s)

-- | Remove a field which should not be present in new version of storage.
--   This covers one removal from the diff.
--   
--   In fact, this action could be performed automatically, but since
--   removal is a destructive operation, being explicit about it seems like
--   a good thing.
migrateRemoveField :: forall field oldTempl newTempl diff touched fieldTy newDiff marker s. ('(UStoreFieldExt marker fieldTy, newDiff) ~ CoverDiff  'DcRemove field diff, HasUField field fieldTy oldTempl) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (MUStore oldTempl newTempl newDiff (field : touched) : s)

-- | Get and remove a field from old version of <a>UStore</a>.
--   
--   You probably want to use this more often than plain
--   <a>migrateRemoveField</a>.
migrateExtractField :: forall field oldTempl newTempl diff touched fieldTy newDiff marker s. ('(UStoreFieldExt marker fieldTy, newDiff) ~ CoverDiff  'DcRemove field diff, HasUField field fieldTy oldTempl, RequireUntouched field (field `IsElem` touched)) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (fieldTy : (MUStore oldTempl newTempl newDiff (field : touched) : s))

-- | Remove field and write new one in place of it.
--   
--   This is semantically equivalent to <tt>dip (migrateRemoveField label)
--   &gt;&gt; migrateAddField label</tt>, but is cheaper.
migrateOverwriteField :: forall field oldTempl newTempl diff touched fieldTy oldFieldTy marker oldMarker newDiff newDiff0 s. ('(UStoreFieldExt oldMarker oldFieldTy, newDiff0) ~ CoverDiff  'DcRemove field diff, '(UStoreFieldExt marker fieldTy, newDiff) ~ CoverDiff  'DcAdd field newDiff0, HasUField field fieldTy newTempl) => Label field -> (fieldTy : (MUStore oldTempl newTempl diff touched : s)) :-> (MUStore oldTempl newTempl newDiff (field : touched) : s)

-- | Modify field which should stay in new version of storage. This does
--   not affect remaining diff.
migrateModifyField :: forall field oldTempl newTempl diff touched fieldTy s. (HasUField field fieldTy oldTempl, HasUField field fieldTy newTempl) => Label field -> (fieldTy : (MUStore oldTempl newTempl diff touched : s)) :-> (MUStore oldTempl newTempl diff touched : s)

-- | Get the old version of storage.
--   
--   This can be applied only in the beginning of migration.
--   
--   In fact this function is not very useful, all required operations
--   should be available for <a>MUStore</a>, but leaving it here just in
--   case.
mustoreToOld :: RequireBeInitial touched => (MUStore oldTemplate newTemplate remDiff touched : s) :-> (UStore oldTemplate : s)

-- | Given template can be converted to <a>UStore</a> value.
class (Generic template, GUStoreConversible (Rep template)) => UStoreConversible template

-- | Make <a>UStore</a> from separate <tt>big_map</tt>s and fields.
mkUStore :: UStoreConversible template => template -> UStore template

-- | Decompose <a>UStore</a> into separate <tt>big_map</tt>s and fields.
--   
--   Since this function needs to <tt>UNPACK</tt> content of
--   <tt>UStore</tt> to actual keys and values, you have to provide
--   <tt>UnpackEnv</tt>.
--   
--   Along with resulting value, you get a list of <tt>UStore</tt> entries
--   which were not recognized as belonging to any submap or field
--   according to <tt>UStore</tt>'s template - this should be empty unless
--   <tt>UStore</tt> invariants were violated.
ustoreDecompose :: forall template. UStoreConversible template => UStore template -> Either Text (UStoreContent, template)

-- | Make migration script which initializes <a>UStore</a> from scratch.
fillUStore :: UStoreConversible template => template -> UStoreMigration () template

-- | Like <a>ustoreDecompose</a>, but requires all entries from
--   <tt>UStore</tt> to be recognized.
ustoreDecomposeFull :: forall template. UStoreConversible template => UStore template -> Either Text template

-- | Predicate for <tt>if ... then .. else ...</tt> construction, defines a
--   kind of operation applied to the top elements of the current stack.
--   
--   Type arguments mean: 1. Input of <tt>if</tt> 2. Left branch input 3.
--   Right branch input 4. Output of branches 5. Output of <tt>if</tt>
data Condition arg argl argr outb out
[Holds] :: Condition (Bool : s) s s o o
[IsSome] :: Condition (Maybe a : s) (a : s) s o o
[IsNone] :: Condition (Maybe a : s) s (a : s) o o
[IsLeft] :: Condition (Either l r : s) (l : s) (r : s) o o
[IsRight] :: Condition (Either l r : s) (r : s) (l : s) o o
[IsCons] :: Condition ([a] : s) (a : ([a] : s)) s o o
[IsNil] :: Condition ([a] : s) s (a : ([a] : s)) o o
[IsZero] :: (UnaryArithOpHs Eq' a, UnaryArithResHs Eq' a ~ Bool) => Condition (a : s) s s o o
[IsNotZero] :: (UnaryArithOpHs Eq' a, UnaryArithResHs Eq' a ~ Bool) => Condition (a : s) s s o o
[IsEq] :: NiceComparable a => Condition (a : (a : s)) s s o o
[IsNeq] :: NiceComparable a => Condition (a : (a : s)) s s o o
[IsLt] :: NiceComparable a => Condition (a : (a : s)) s s o o
[IsGt] :: NiceComparable a => Condition (a : (a : s)) s s o o
[IsLe] :: NiceComparable a => Condition (a : (a : s)) s s o o
[IsGe] :: NiceComparable a => Condition (a : (a : s)) s s o o

-- | Explicitly named binary condition, to ensure proper order of stack
--   arguments.
[NamedBinCondition] :: Condition (a : (a : s)) s s o o -> Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o

-- | Provide the compared arguments to <tt>if</tt> branches.
[PreserveArgsBinCondition] :: (forall st o. Condition (a : (b : st)) st st o o) -> Condition (a : (b : s)) (a : (b : s)) (a : (b : s)) (a : (b : s)) s

-- | Aliases for '(#)' used by do-blocks.
(>>) :: (a :-> b) -> (b :-> c) -> a :-> c

-- | Defines semantics of <tt>if ... then ... else ...</tt> construction.
ifThenElse :: Condition arg argl argr outb out -> (argl :-> outb) -> (argr :-> outb) -> arg :-> out

-- | Named version of <a>IsLt</a>.
--   
--   In this and similar operators you provide names of accepted stack
--   operands as a safety measure of that they go in the expected order.
(<.) :: NiceComparable a => Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o
infix 4 <.

-- | Named version of <a>IsGt</a>.
(>.) :: NiceComparable a => Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o
infix 4 >.

-- | Named version of <a>IsLe</a>.
(<=.) :: NiceComparable a => Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o
infix 4 <=.

-- | Named version of <a>IsGe</a>.
(>=.) :: NiceComparable a => Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o
infix 4 >=.

-- | Named version of <a>IsEq</a>.
(==.) :: NiceComparable a => Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o
infix 4 ==.

-- | Named version of <a>IsNeq</a>.
(/=.) :: NiceComparable a => Label n1 -> Label n2 -> Condition ((n1 :! a) : ((n2 :! a) : s)) s s o o
infix 4 /=.

-- | Condition modifier, makes stack operands of binary comparison to be
--   available within <tt>if</tt> branches.
keepIfArgs :: (forall st o. Condition (a : (b : st)) st st o o) -> Condition (a : (b : s)) (a : (b : s)) (a : (b : s)) (a : (b : s)) s

-- | Some error with a numeric tag attached.
data NumericErrorWrapper (numTag :: Nat) (err :: Type)

-- | Handler which changes documentation for one particular error type.
data NumericErrorDocHandler

-- | Errors for <a>NumericErrorDocHandler</a>
data NumericErrorDocHandlerError

-- | Adds a section which explains error tag mapping.
data DDescribeErrorTagMap
DDescribeErrorTagMap :: Text -> DDescribeErrorTagMap

-- | Describes where the error tag map is defined in Haskell code.
[detmSrcLoc] :: DDescribeErrorTagMap -> Text

-- | Modify documentation generated for given code so that all
--   <a>CustomError</a> mention not their textual error tag rather
--   respective numeric one from the given map.
--   
--   If some documented error is not present in the map, it remains
--   unmodified. This function may fail with <a>error</a> if contract uses
--   some uncommon errors, see <a>applyErrorTagToErrorsDocWith</a> for
--   details.
applyErrorTagToErrorsDoc :: HasCallStack => ErrorTagMap -> (inp :-> out) -> inp :-> out

-- | Extended version of <a>applyErrorTagToErrorsDoc</a> which accepts
--   error handlers.
--   
--   In most cases that function should be enough for your purposes, but it
--   uses a fixed set of base handlers which may be not enough in case when
--   you define your own errors. In this case define and pass all the
--   necessary handlers to this function.
--   
--   It fails with <a>error</a> if some of the errors used in the contract
--   cannot be handled with given handlers.
applyErrorTagToErrorsDocWith :: HasCallStack => [NumericErrorDocHandler] -> ErrorTagMap -> (inp :-> out) -> inp :-> out

-- | Handler for all <a>CustomError</a>s.
customErrorDocHandler :: NumericErrorDocHandler

-- | Handler for <a>VoidResult</a>.
voidResultDocHandler :: NumericErrorDocHandler

-- | Handlers for most common errors defined in Lorentz.
baseErrorDocHandlers :: [NumericErrorDocHandler]
type CaseTC dt out inp clauses = (InstrCaseC dt inp out, RMap (CaseClauses dt), RecFromTuple clauses, clauses ~ Rec (CaseClauseL inp out) (CaseClauses dt))

-- | Provides "case" arrow which works on different wrappers for clauses.
class CaseArrow name body clause | clause -> name, clause -> body

-- | Lift an instruction to case clause.
--   
--   You should write out constructor name corresponding to the clause
--   explicitly. Prefix constructor name with "c" letter, otherwise your
--   label will not be recognized by Haskell parser. Passing constructor
--   name can be circumvented but doing so is not recomended as mentioning
--   contructor name improves readability and allows avoiding some
--   mistakes.
(/->) :: CaseArrow name body clause => Label name -> body -> clause
infixr 0 /->

-- | Lorentz analogy of <a>CaseClause</a>, it works on plain <a>Type</a>
--   types.
data CaseClauseL (inp :: [Type]) (out :: [Type]) (param :: CaseClauseParam)
[CaseClauseL] :: (AppendCtorField x inp :-> out) -> CaseClauseL inp out ( 'CaseClauseParam ctor x)

-- | Shortcut for multiple <a>HasFieldOfType</a> constraints.
type family HasFieldsOfType (dt :: Type) (fs :: [NamedField]) :: Constraint
type n := ty =  'NamedField n ty
infixr 0 :=

-- | A pair of field name and type.
data NamedField
NamedField :: Symbol -> Type -> NamedField

-- | Like <a>HasField</a>, but allows constrainting field type.
type HasFieldOfType dt fname fieldTy = (HasField dt fname, GetFieldType dt fname ~ fieldTy)

-- | Allows field access and modification.
type HasField dt fname = (InstrGetFieldC dt fname, InstrSetFieldC dt fname)

-- | Extract a field of a datatype replacing the value of this datatype
--   with the extracted field.
--   
--   For this and the following functions you have to specify field name
--   which is either record name or name attached with <tt>(:!)</tt>
--   operator.
toField :: forall dt name st. InstrGetFieldC dt name => Label name -> (dt & st) :-> (GetFieldType dt name & st)

-- | Like <a>toField</a>, but leaves field named.
toFieldNamed :: forall dt name st. InstrGetFieldC dt name => Label name -> (dt & st) :-> ((name :! GetFieldType dt name) & st)

-- | Extract a field of a datatype, leaving the original datatype on stack.
getField :: forall dt name st. InstrGetFieldC dt name => Label name -> (dt & st) :-> (GetFieldType dt name & (dt : st))

-- | Like <a>getField</a>, but leaves field named.
getFieldNamed :: forall dt name st. InstrGetFieldC dt name => Label name -> (dt & st) :-> ((name :! GetFieldType dt name) & (dt : st))

-- | Set a field of a datatype.
setField :: forall dt name st. InstrSetFieldC dt name => Label name -> (GetFieldType dt name : (dt : st)) :-> (dt : st)

-- | Apply given modifier to a datatype field.
modifyField :: forall dt name st. (InstrGetFieldC dt name, InstrSetFieldC dt name) => Label name -> (forall st0. (GetFieldType dt name : st0) :-> (GetFieldType dt name : st0)) -> (dt & st) :-> (dt & st)

-- | Make up a datatype. You provide a pack of individual fields
--   constructors.
--   
--   Each element of the accepted record should be an instruction wrapped
--   with <a>fieldCtor</a> function. This instruction will have access to
--   the stack at the moment of calling <tt>construct</tt>. Instructions
--   have to output fields of the built datatype, one per instruction;
--   instructions order is expected to correspond to the order of fields in
--   the datatype.
construct :: forall dt st. (InstrConstructC dt, RMap (ConstructorFieldTypes dt)) => Rec (FieldConstructor st) (ConstructorFieldTypes dt) -> st :-> (dt & st)

-- | Version of <a>construct</a> which accepts tuple of field constructors.
constructT :: forall dt fctors st. (InstrConstructC dt, RMap (ConstructorFieldTypes dt), fctors ~ Rec (FieldConstructor st) (ConstructorFieldTypes dt), RecFromTuple fctors) => IsoRecTuple fctors -> st :-> (dt & st)

-- | Lift an instruction to field constructor.
fieldCtor :: HasCallStack => (st :-> (f & st)) -> FieldConstructor st f

-- | Wrap entry in constructor. Useful for sum types.
wrap_ :: forall dt name st. InstrWrapC dt name => Label name -> AppendCtorField (GetCtorField dt name) st :-> (dt & st)

-- | Pattern match on the given sum type.
--   
--   You have to provide a <a>Rec</a> containing case branches. To
--   construct a case branch use <a>/-&gt;</a> operator.
case_ :: forall dt out inp. (InstrCaseC dt inp out, RMap (CaseClauses dt)) => Rec (CaseClauseL inp out) (CaseClauses dt) -> (dt & inp) :-> out

-- | Like <a>case_</a>, accepts a tuple of clauses, which may be more
--   convenient.
--   
--   If user is experiencing problems with wierd errors about tuples while
--   using this function, he should take look at <a>Instances</a> and
--   ensure that his tuple isn't bigger than generated instances, if so, he
--   should probably extend number of generated instances.
caseT :: forall dt out inp clauses. CaseTC dt out inp clauses => IsoRecTuple clauses -> (dt & inp) :-> out

-- | Wrap entry in constructor. Useful for sum types.
unwrapUnsafe_ :: forall dt name st. InstrUnwrapC dt name => Label name -> (dt & st) :-> (CtorOnlyField name dt : st)

-- | Concise way to write down constraints with expected content of a
--   storage.
--   
--   Use it like follows:
--   
--   <pre>
--   type StorageConstraint = StorageContains
--     [ "fieldInt" := Int
--     , "fieldNat" := Nat
--     , "balances" := Address ~&gt; Int
--     ]
--   </pre>
type family StorageContains store (content :: [NamedField]) :: Constraint

-- | Indicates a submap with given key and value types.
data k ~> v
infix 9 ~>

-- | Provides operations on fields for storage.
class StoreHasSubmap store mname key value | store mname -> key value
storeSubmapOps :: StoreHasSubmap store mname key value => StoreSubmapOps store mname key value

-- | Datatype containing the full implementation of <a>StoreHasField</a>
--   typeclass.
--   
--   We use this grouping because in most cases implementation will be
--   chosen among the default ones, and initializing all methods at once is
--   simpler and more consistent. (One can say that we are trying to
--   emulate <tt>DerivingVia</tt> extension.)
data StoreSubmapOps store mname key value
StoreSubmapOps :: (forall s. Label mname -> (key : (store : s)) :-> (Bool : s)) -> (forall s. Label mname -> (key : (store : s)) :-> (Maybe value : s)) -> (forall s. Label mname -> (key : (Maybe value : (store : s))) :-> (store : s)) -> (forall s. Maybe (Label mname -> (key : (store : s)) :-> (store : s))) -> (forall s. Maybe (Label mname -> (key : (value : (store : s))) :-> (store : s))) -> StoreSubmapOps store mname key value
[sopMem] :: StoreSubmapOps store mname key value -> forall s. Label mname -> (key : (store : s)) :-> (Bool : s)
[sopGet] :: StoreSubmapOps store mname key value -> forall s. Label mname -> (key : (store : s)) :-> (Maybe value : s)
[sopUpdate] :: StoreSubmapOps store mname key value -> forall s. Label mname -> (key : (Maybe value : (store : s))) :-> (store : s)
[sopDelete] :: StoreSubmapOps store mname key value -> forall s. Maybe (Label mname -> (key : (store : s)) :-> (store : s))
[sopInsert] :: StoreSubmapOps store mname key value -> forall s. Maybe (Label mname -> (key : (value : (store : s))) :-> (store : s))

-- | Provides operations on fields for storage.
class StoreHasField store fname ftype | store fname -> ftype
storeFieldOps :: StoreHasField store fname ftype => StoreFieldOps store fname ftype

-- | Datatype containing the full implementation of <a>StoreHasField</a>
--   typeclass.
--   
--   We use this grouping because in most cases implementation will be
--   chosen among the default ones, and initializing all methods at once is
--   simpler and more consistent. (One can say that we are trying to
--   emulate benefits of <tt>DerivingVia</tt> extension.)
data StoreFieldOps store fname ftype
StoreFieldOps :: (forall s. Label fname -> (store : s) :-> (ftype : s)) -> (forall s. Label fname -> (ftype : (store : s)) :-> (store : s)) -> StoreFieldOps store fname ftype
[sopToField] :: StoreFieldOps store fname ftype -> forall s. Label fname -> (store : s) :-> (ftype : s)
[sopSetField] :: StoreFieldOps store fname ftype -> forall s. Label fname -> (ftype : (store : s)) :-> (store : s)

-- | Pick storage field.
stToField :: StoreHasField store fname ftype => Label fname -> (store : s) :-> (ftype : s)

-- | Get storage field, preserving the storage itself on stack.
stGetField :: StoreHasField store fname ftype => Label fname -> (store : s) :-> (ftype : (store : s))

-- | Update storage field.
stSetField :: StoreHasField store fname ftype => Label fname -> (ftype : (store : s)) :-> (store : s)

-- | Check value presence in storage.
stMem :: StoreHasSubmap store mname key value => Label mname -> (key : (store : s)) :-> (Bool : s)

-- | Get value in storage.
stGet :: StoreHasSubmap store mname key value => Label mname -> (key : (store : s)) :-> (Maybe value : s)

-- | Update a value in storage.
stUpdate :: StoreHasSubmap store mname key value => Label mname -> (key : (Maybe value : (store : s))) :-> (store : s)

-- | Delete a value in storage.
stDelete :: forall store mname key value s. (StoreHasSubmap store mname key value, KnownValue value) => Label mname -> (key : (store : s)) :-> (store : s)

-- | Add a value in storage.
stInsert :: StoreHasSubmap store mname key value => Label mname -> (key : (value : (store : s))) :-> (store : s)

-- | Add a value in storage, but fail if it will overwrite some existing
--   entry.
stInsertNew :: StoreHasSubmap store mname key value => Label mname -> (forall s0 any. (key : s0) :-> any) -> (key : (value : (store : s))) :-> (store : s)

-- | Implementation of <a>StoreHasField</a> for case of datatype keeping a
--   pack of fields.
storeFieldOpsADT :: HasFieldOfType dt fname ftype => StoreFieldOps dt fname ftype

-- | Implementation of <a>StoreHasField</a> for a data type which has an
--   instance of <a>StoreHasField</a> inside. For instance, it can be used
--   for top-level storage.
storeFieldOpsDeeper :: (HasFieldOfType storage fieldsPartName fields, StoreHasField fields fname ftype) => Label fieldsPartName -> StoreFieldOps storage fname ftype

-- | Implementation of <a>StoreHasSubmap</a> for a data type which has an
--   instance of <a>StoreHasSubmap</a> inside. For instance, it can be used
--   for top-level storage.
storeSubmapOpsDeeper :: (HasFieldOfType storage bigMapPartName fields, StoreHasSubmap fields mname key value) => Label bigMapPartName -> StoreSubmapOps storage mname key value

-- | Pretend that given <a>StoreSubmapOps</a> implementation is made up for
--   submap with name <tt>desiredName</tt>, not its actual name. Logic of
--   the implementation remains the same.
--   
--   Use case: imagine that your code requires access to submap named
--   <tt>X</tt>, but in your storage that submap is called <tt>Y</tt>. Then
--   you implement the instance which makes <tt>X</tt> refer to <tt>Y</tt>:
--   
--   <pre>
--   instance StoreHasSubmap Store X Key Value where
--     storeSubmapOps = storeSubmapOpsReferTo #Y storeSubmapOpsForY
--   </pre>
storeSubmapOpsReferTo :: Label name -> StoreSubmapOps storage name key value -> StoreSubmapOps storage desiredName key value

-- | Pretend that given <a>StoreSubmapOps</a> implementation is made up for
--   submap with name <tt>desiredName</tt>, not its actual name. Logic of
--   the implementation remains the same.
--   
--   See also <a>storeSubmapOpsReferTo</a>.
storeFieldOpsReferTo :: Label name -> StoreFieldOps storage name field -> StoreFieldOps storage desiredName field

-- | Chain two implementations of field operations.
--   
--   Suits for a case when your store does not contain its fields directly
--   rather has a nested structure.
composeStoreFieldOps :: Label nameInStore -> StoreFieldOps store nameInStore substore -> StoreFieldOps substore nameInSubstore field -> StoreFieldOps store nameInSubstore field

-- | Chain implementations of field and submap operations.
composeStoreSubmapOps :: Label nameInStore -> StoreFieldOps store nameInStore substore -> StoreSubmapOps substore mname key value -> StoreSubmapOps store mname key value
type family RequireFlatEpDerivation cp deriv :: Constraint
type family RequireFlatParamEps cp :: Constraint

-- | Provides arror for convenient entrypoint documentation
class EntryArrow kind name body

-- | Lift entrypoint implementation.
--   
--   Entrypoint names should go with "e" prefix.
(#->) :: EntryArrow kind name body => (Label name, Proxy kind) -> body -> body

-- | Constraint for <a>documentEntryPoints</a>.
type DocumentEntryPoints kind a = (Generic a, GDocumentEntryPoints kind (Rep a))

-- | Pick a type documentation from <a>CtorField</a>.
class (KnownSymbol con) => DeriveCtorFieldDoc con (cf :: CtorField)
deriveCtorFieldDoc :: DeriveCtorFieldDoc con cf => DEntryPointArg

-- | Describes argument of an entrypoint.
data DEntryPointArg
DEntryPointArg :: Maybe DType -> [ParamBuildingStep] -> Type -> DEntryPointArg

-- | Argument of the entrypoint. Pass <a>Nothing</a> if no argument is
--   required.
[epaArg] :: DEntryPointArg -> Maybe DType

-- | Describes a way to lift an entrypoint argument into full parameter
--   which can be passed to the contract.
--   
--   Steps are supposed to be applied in the order opposite to one in which
--   they are given. E.g. suppose that an entrypoint is called as <tt>Run
--   (Service1 arg)</tt>; then the first step (actual last) should describe
--   wrapping into <tt>Run</tt> constructor, and the second step (actual
--   first) should be about wrapping into <tt>Service1</tt> constructor.
[epaBuilding] :: DEntryPointArg -> [ParamBuildingStep]

-- | Untyped representation of entrypoint, used for printing its michelson
--   type representation.
[epaType] :: DEntryPointArg -> Type

-- | Describes a parameter building step.
--   
--   This can be wrapping into (Haskell) constructor, or a more complex
--   transformation.
data ParamBuildingStep

-- | Wraps something into constructor with given name. Constructor should
--   be the one which corresponds to an entrypoint defined via field
--   annotation, for more complex cases use <a>PbsCustom</a>.
PbsWrapIn :: Text -> ParamBuildingDesc -> ParamBuildingStep

-- | Directly call an entrypoint marked with a field annotation.
PbsCallEntrypoint :: EpName -> ParamBuildingStep

-- | Other action.
PbsCustom :: ParamBuildingDesc -> ParamBuildingStep

-- | This entrypoint cannot be called, which is possible when an explicit
--   default entrypoint is present. This is not a true entrypoint but just
--   some intermediate node in <tt>or</tt> tree and neither it nor any of
--   its parents are marked with a field annotation.
--   
--   It contains dummy <a>ParamBuildingStep</a>s which were assigned before
--   entrypoints were taken into account.
PbsUncallable :: [ParamBuildingStep] -> ParamBuildingStep
data ParamBuildingDesc
ParamBuildingDesc :: Markdown -> ParamBuilder -> ParamBuilder -> ParamBuildingDesc

-- | Plain english description of this step.
[pbdEnglish] :: ParamBuildingDesc -> Markdown

-- | How to construct parameter in Haskell code.
[pbdHaskell] :: ParamBuildingDesc -> ParamBuilder

-- | How to construct parameter working on raw Michelson.
[pbdMichelson] :: ParamBuildingDesc -> ParamBuilder

-- | When describing the way of parameter construction - piece of
--   incremental builder for this description.
newtype ParamBuilder
ParamBuilder :: (Markdown -> Markdown) -> ParamBuilder

-- | Argument stands for previously constructed parameter piece, and
--   returned value - a piece constructed after our step.
[unParamBuilder] :: ParamBuilder -> Markdown -> Markdown
data DEntryPointReference
DEntryPointReference :: Text -> Anchor -> DEntryPointReference

-- | Default value for <a>DEntryPoint</a> type argument.
data PlainEntryPointsKind

-- | Gathers information about single entrypoint.
--   
--   We assume that entry points might be of different kinds, which is
--   designated by phantom type parameter. For instance, you may want to
--   have several groups of entry points corresponding to various parts of
--   a contract - specifying different <tt>kind</tt> type argument for each
--   of those groups will allow you defining different <a>DocItem</a>
--   instances with appropriate custom descriptions for them.
data DEntryPoint (kind :: Type)
DEntryPoint :: Text -> SubDoc -> DEntryPoint
[depName] :: DEntryPoint -> Text
[depSub] :: DEntryPoint -> SubDoc

-- | Default implementation of <a>docItemToMarkdown</a> for entry points.
diEntryPointToMarkdown :: HeaderLevel -> DEntryPoint level -> Markdown

-- | Make a <a>ParamBuildingStep</a> that tells about wrapping an argument
--   into a constructor with given name and uses given <a>ParamBuilder</a>
--   as description of Michelson part.
mkPbsWrapIn :: Text -> ParamBuilder -> ParamBuildingStep
constructDEpArg :: forall arg. (TypeHasDoc arg, HasTypeAnn arg, KnownValue arg) => DEntryPointArg
emptyDEpArg :: DEntryPointArg
mkDEpUType :: forall t. (KnownValue t, HasTypeAnn t) => Type
mkDEntryPointArgSimple :: forall t. (KnownValue t, HasTypeAnn t, TypeHasDoc t) => DEntryPointArg

-- | Go over contract code and update every occurrence of
--   <a>DEntryPointArg</a> documentation item, adding the given step to its
--   "how to build parameter" description.
clarifyParamBuildingSteps :: ParamBuildingStep -> (inp :-> out) -> inp :-> out

-- | Like <a>case_</a>, to be used for pattern-matching on a parameter or
--   its part.
--   
--   Modifies documentation accordingly. Including description of
--   entrypoints' arguments, thus for them you will need to supply
--   <a>TypeHasDoc</a> instance.
entryCase_ :: forall dt entryPointKind out inp. (InstrCaseC dt inp out, RMap (CaseClauses dt), DocumentEntryPoints entryPointKind dt) => Proxy entryPointKind -> Rec (CaseClauseL inp out) (CaseClauses dt) -> (dt & inp) :-> out

-- | Version of <a>entryCase_</a> for tuples.
entryCase :: forall dt entryPointKind out inp clauses. (CaseTC dt out inp clauses, DocumentEntryPoints entryPointKind dt) => Proxy entryPointKind -> IsoRecTuple clauses -> (dt & inp) :-> out

-- | Wrapper for documenting single entrypoint which parameter isn't going
--   to be unwrapped from some datatype.
--   
--   <tt>entryCase</tt> unwraps a datatype, however, sometimes we want to
--   have entrypoint parameter to be not wrapped into some datatype.
documentEntryPoint :: forall kind epName param s out. (KnownSymbol epName, DocItem (DEntryPoint kind), TypeHasDoc param, HasTypeAnn param, KnownValue param) => ((param & s) :-> out) -> (param & s) :-> out

-- | Modify param building steps with respect to entrypoints that given
--   parameter declares.
--   
--   Each contract with entrypoints should eventually call this function,
--   otherwise, in case if contract uses built-in entrypoints feature, the
--   resulting parameter building steps in the generated documentation will
--   not consider entrypoints and thus may be incorrect.
--   
--   Calling this twice over the same code is also prohibited.
finalizeParamCallingDoc :: forall cp inp out. (NiceParameterFull cp, RequireSumType cp, HasCallStack) => ((cp : inp) :-> out) -> (cp : inp) :-> out

-- | Whether <a>finalizeParamCallingDoc</a> has already been applied to
--   these steps.
areFinalizedParamBuildingSteps :: [ParamBuildingStep] -> Bool
entryCaseSimple_ :: forall cp out inp. (InstrCaseC cp inp out, RMap (CaseClauses cp), DocumentEntryPoints PlainEntryPointsKind cp, NiceParameterFull cp, RequireFlatParamEps cp) => Rec (CaseClauseL inp out) (CaseClauses cp) -> (cp & inp) :-> out

-- | Version of <a>entryCase</a> for contracts with flat parameter, use it
--   when you need only one <a>entryCase</a> all over the contract
--   implementation.
--   
--   This method calls <a>finalizeParamCallingDoc</a> inside.
entryCaseSimple :: forall cp out inp clauses. (CaseTC cp out inp clauses, DocumentEntryPoints PlainEntryPointsKind cp, NiceParameterFull cp, RequireFlatParamEps cp) => IsoRecTuple clauses -> (cp & inp) :-> out

-- | Entry points template derived from given ADT sum.
type UParamLinearized p = GUParamLinearized (Rep p)

-- | Constraint required by <a>uparamFromAdt</a>.
type UParamLinearize p = (Generic p, GUParamLinearize (Rep p))

-- | Make up a "case" over entry points.
class CaseUParam (entries :: [EntryPointKind])

-- | An action invoked when user-provided entrypoint is not found.
type UParamFallback inp out = ((MText, ByteString) : inp) :-> out

-- | Implementations of some entry points.
--   
--   Note that this thing inherits properties of <a>Rec</a>, e.g. you can
--   <tt>Data.Vinyl.Core.rappend</tt> implementations for two entrypoint
--   sets when assembling scattered parts of a contract.
type EntryPointsImpl inp out entries = Rec (CaseClauseU inp out) entries
data EntryPointLookupError
NoSuchEntryPoint :: MText -> EntryPointLookupError
ArgumentUnpackFailed :: EntryPointLookupError

-- | This class is needed to implement <a>unpackUParam</a>.
class UnpackUParam (c :: Type -> Constraint) entries

-- | Turn <a>UParam</a> into a Haskell value. Since we don't know its type
--   in compile time, we have to erase it using <a>ConstrainedSome</a>. The
--   user of this function can require arbitrary constraint to hold
--   (depending on how they want to use the result).
unpackUParam :: UnpackUParam c entries => UParam entries -> Either EntryPointLookupError (MText, ConstrainedSome c)

-- | This type can store any value that satisfies a certain constraint.
data ConstrainedSome (c :: Type -> Constraint)
[ConstrainedSome] :: c a => a -> ConstrainedSome c

-- | Ensure that given entry points do no contain duplicated names.
type family RequireUniqueEntryPoints (entries :: [EntryPointKind]) :: Constraint

-- | Get type of entrypoint argument by its name.
type family LookupEntryPoint (name :: Symbol) (entries :: [EntryPointKind]) :: Type

-- | Homomorphic version of <a>UParam</a>, forgets the exact interface.
type UParam_ = UParam SomeInterface

-- | Pseudo value for <a>UParam</a> type variable.
type SomeInterface = '['("SomeEntrypoints", Void)]

-- | Encapsulates parameter for one of entry points. It keeps entrypoint
--   name and corresponding argument serialized.
--   
--   In Haskell world, we keep an invariant of that contained value relates
--   to one of entry points from <tt>entries</tt> list.
newtype UParam (entries :: [EntryPointKind])
UParamUnsafe :: (MText, ByteString) -> UParam

-- | A convenient alias for type-level name-something pair.
type (n :: Symbol) ?: (a :: k) = '(n, a)

-- | An entrypoint is described by two types: its name and type of
--   argument.
type EntryPointKind = (Symbol, Type)

-- | Construct a <a>UParam</a> safely.
mkUParam :: (NicePackedValue a, LookupEntryPoint name entries ~ a, RequireUniqueEntryPoints entries) => Label name -> a -> UParam entries

-- | Helper instruction which extracts content of <a>UParam</a>.
unwrapUParam :: (UParam entries : s) :-> ((MText, ByteString) : s)

-- | Default implementation for <a>UParamFallback</a>, simply reports an
--   error.
uparamFallbackFail :: UParamFallback inp out

-- | Pattern-match on given <tt>UParam entries</tt>.
--   
--   You have to provide all case branches and a fallback action on case
--   when entrypoint is not found.
caseUParam :: (CaseUParam entries, RequireUniqueEntryPoints entries) => Rec (CaseClauseU inp out) entries -> UParamFallback inp out -> (UParam entries : inp) :-> out

-- | Like <a>caseUParam</a>, but accepts a tuple of clauses, not a
--   <a>Rec</a>.
caseUParamT :: forall entries inp out clauses. (clauses ~ Rec (CaseClauseU inp out) entries, RecFromTuple clauses, CaseUParam entries) => IsoRecTuple clauses -> UParamFallback inp out -> (UParam entries : inp) :-> out

-- | Make up <a>UParam</a> from ADT sum.
--   
--   Entry points template will consist of <tt>(constructorName,
--   constructorFieldType)</tt> pairs. Each constructor is expected to have
--   exactly one field.
uparamFromAdt :: UParamLinearize up => up -> UParam (UParamLinearized up)

-- | Note that calling given entrypoints involves constructing
--   <a>UParam</a>.
pbsUParam :: forall ctorName. KnownSymbol ctorName => ParamBuildingStep


-- | Unit tests for Lorentz.
module Lorentz.Test.Unit

-- | Expect the given contract to have some specific entrypoints.
expectContractEntrypoints :: forall expectedEps contractEps st. (NiceParameterFull expectedEps, NiceParameterFull contractEps, NiceStorage st) => ContractCode contractEps st -> Assertion

module Lorentz.Test

-- | Import contract and use it in the spec. Both versions of contract are
--   passed to the callback function (untyped and typed).
--   
--   If contract's import fails, a spec with single failing expectation
--   will be generated (so tests will likely run unexceptionally, but a
--   failing result will notify about problem).
specWithContract :: (Each ((Typeable :: T -> Constraint) : ((SingI :: T -> Constraint) : ([] :: [T -> Constraint]))) (cp : (st : ([] :: [T]))), HasCallStack) => FilePath -> ((Contract, FullContract cp st) -> Spec) -> Spec

-- | A version of <a>specWithContract</a> which passes only the typed
--   representation of the contract.
specWithTypedContract :: (Each ((Typeable :: T -> Constraint) : ((SingI :: T -> Constraint) : ([] :: [T -> Constraint]))) (cp : (st : ([] :: [T]))), HasCallStack) => FilePath -> (FullContract cp st -> Spec) -> Spec
specWithUntypedContract :: FilePath -> (Contract -> Spec) -> Spec
type ContractReturn (st :: T) = (Either MichelsonFailed ([Operation], Value st), InterpreterState)

-- | Type for contract execution validation.
--   
--   It's a function which is supplied with contract execution output
--   (failure or new storage with operation list).
--   
--   Function returns a property which type is designated by type variable
--   <tt>prop</tt> and might be <a>Property</a> or <a>Expectation</a> or
--   anything else relevant.
type ContractPropValidator (st :: T) prop = ContractReturn st -> prop

-- | ContractCode's property tester against given input. Takes contract
--   environment, initial storage and parameter, interprets contract on
--   this input and invokes validation function.
contractProp :: (IsoValue param, IsoValue storage, ToT param ~ cp, ToT storage ~ st, ParameterScope cp) => FullContract cp st -> ContractPropValidator st prop -> ContractEnv -> param -> storage -> prop

-- | Version of <a>contractProp</a> which takes <tt>Val</tt> as arguments
--   instead of regular Haskell values.
--   
--   This function assumes that contract has no explicit default
--   entrypoints and you always have to construct parameter manually; if
--   you need to test contract calling specific entrypoints, use
--   integrational testing defined by <a>Michelson.Test.Integrational</a>
--   module.
contractPropVal :: ParameterScope cp => FullContract cp st -> ContractPropValidator st prop -> ContractEnv -> Value cp -> Value st -> prop

-- | Expect the given contract to have some specific entrypoints.
expectContractEntrypoints :: forall expectedEps contractEps st. (NiceParameterFull expectedEps, NiceParameterFull contractEps, NiceStorage st) => ContractCode contractEps st -> Assertion

-- | Validator for integrational testing. If an error is expected, it
--   should be <a>Left</a> with validator for errors. Otherwise it should
--   check final global state and its updates.
type IntegrationalValidator = Either ExecutorError -> Bool SuccessValidator

-- | Validator for integrational testing that expects successful execution.
type SuccessValidator = InternalState -> GState -> [GStateUpdate] -> Either ValidationError ()
type IntegrationalScenario = IntegrationalScenarioM Validated

-- | A monad inside which integrational tests can be described using
--   do-notation.
type IntegrationalScenarioM = StateT InternalState Except ScenarioError
data ValidationError
UnexpectedExecutorError :: IntegrationalExecutorError -> ValidationError
UnexpectedTypeCheckError :: TCError -> ValidationError
ExpectingInterpreterToFail :: ValidationError
IncorrectUpdates :: ValidationError -> [GStateUpdate] -> ValidationError
IncorrectStorageUpdate :: AddressName -> Text -> ValidationError
InvalidStorage :: AddressName -> ExpectedStorage -> Text -> ValidationError
StoragePredicateMismatch :: AddressName -> Text -> ValidationError
InvalidBalance :: AddressName -> ExpectedBalance -> Text -> ValidationError
UnexpectedUpdates :: NonEmpty GStateUpdate -> ValidationError
CustomValidationError :: Text -> ValidationError

-- | Integrational test that executes given operations and validates them
--   using given validator. It can fail using <a>Expectation</a>
--   capability. It starts with <a>initGState</a> and some reasonable dummy
--   values for gas limit and current timestamp. You can update blockchain
--   state by performing some operations.
integrationalTestExpectation :: HasCallStack -> IntegrationalScenario -> Expectation

-- | Integrational test similar to <a>integrationalTestExpectation</a>. It
--   can fail using <a>Property</a> capability. It can be used with
--   QuickCheck's <tt>forAll</tt> to make a property-based test with
--   arbitrary data.
integrationalTestProperty :: IntegrationalScenario -> Property

-- | Like <a>originate</a>, but for Lorentz contracts.
lOriginate :: forall cp st. (NiceParameterFull cp, NiceStorage st) => ContractCode cp st -> Text -> st -> Mutez -> IntegrationalScenarioM (TAddress cp)

-- | Originate a contract with empty balance and default storage.
lOriginateEmpty :: (NiceParameterFull cp, NiceStorage st, Default st) => ContractCode cp st -> Text -> IntegrationalScenarioM (TAddress cp)

-- | Similar to <a>transfer</a>, for Lorentz values.
lTransfer :: forall cp epRef epArg addr. (HasEntryPointArg cp epRef epArg, IsoValue epArg, ToTAddress cp addr) => ("from" :! Address) -> ("to" :! addr) -> Mutez -> epRef -> epArg -> IntegrationalScenarioM ()

-- | Legacy version of <a>lCallEP</a> function. Calls default entrypoint of
--   a contract assuming its argument is the same as contract parameter
--   (which is equivalent to absence of explicit default entrypoint).
--   
--   This function is DEPRECATED and exists only for backwards
--   compatibility.

-- | <i>Deprecated: <a>lCall</a> will likely be replaced with
--   <a>lCallEP</a> in future version</i>
lCall :: forall cp defEpName addr. (HasDefEntryPointArg cp defEpName cp, IsoValue cp, ToTAddress cp addr) => addr -> cp -> IntegrationalScenarioM ()

-- | Call an entrypoint of a contract without caring about the source
--   address. Transfers 0 mutez.
lCallEP :: forall cp epRef epArg addr. (HasEntryPointArg cp epRef epArg, IsoValue epArg, ToTAddress cp addr) => addr -> epRef -> epArg -> IntegrationalScenarioM ()

-- | Which entrypoint to call.
--   
--   We intentionally distinguish default and non-default cases because
--   this makes API more details-agnostic.
data EntryPointRef (mname :: Maybe Symbol)

-- | Call the default entrypoint, or root if no explicit default is
--   assigned.
[CallDefault] :: EntryPointRef  'Nothing

-- | Call the given entrypoint; calling default is not treated specially.
--   You have to provide entrypoint name via passing it as type argument.
--   
--   Unfortunatelly, here we cannot accept a label because in most cases
--   our entrypoints begin from capital letter (being derived from
--   constructor name), while labels must start from a lower-case letter,
--   and there is no way to make a conversion at type-level.
[Call] :: NiceEntryPointName name => EntryPointRef ( 'Just name)

-- | <a>lCallEP</a> for default entrypoint.
lCallDef :: forall cp defEpName defArg addr. (HasDefEntryPointArg cp defEpName defArg, IsoValue defArg, ToTAddress cp addr) => addr -> defArg -> IntegrationalScenarioM ()

-- | Validate the execution result.
validate :: IntegrationalValidator -> IntegrationalScenario

-- | Just fail with given error.
integrationalFail :: () => ValidationError -> IntegrationalScenarioM anything

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given gas limit.
setMaxSteps :: RemainingSteps -> IntegrationalScenarioM ()

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given timestamp as the current one.
setNow :: Timestamp -> IntegrationalScenarioM ()

-- | Increase current time by the given number of seconds.
rewindTime :: Integer -> IntegrationalScenarioM ()

-- | Pretend that given address initiates all the transfers within the code
--   block (i.e. <tt>SENDER</tt> instruction will return this address).
withSender :: () => Address -> IntegrationalScenarioM a -> IntegrationalScenarioM a

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given chain id.
setChainId :: ChainId -> IntegrationalScenarioM ()

-- | Execute multiple testing scenarios independently, basing them on
--   scenario built till this point.
--   
--   The following property holds for this function:
--   
--   <tt> pre &gt;&gt; branchout [a, b, c] = branchout [pre &gt;&gt; a, pre
--   &gt;&gt; b, pre &gt;&gt; c] </tt>.
--   
--   In case of property failure in one of the branches no following branch
--   is executed.
--   
--   Providing empty list of scenarios to this function causes error; we do
--   not require <a>NonEmpty</a> here though for convenience.
branchout :: HasCallStack -> [(Text, IntegrationalScenario)] -> IntegrationalScenario

-- | Make a tuple with name without extra syntactic noise.
(?-) :: () => Text -> a -> (Text, a)
infixr 0 ?-

-- | Test given scenario with the state gathered till this moment; if this
--   scenario passes, go on as if it never happened.
offshoot :: Text -> IntegrationalScenario -> IntegrationalScenarioM ()

-- | Compose two success validators.
--   
--   For example:
--   
--   expectBalance bal addr <a>composeValidators</a>
--   expectStorageUpdateConst addr2 ValueUnit
composeValidators :: SuccessValidator -> SuccessValidator -> SuccessValidator

-- | Compose a list of success validators.
composeValidatorsList :: [SuccessValidator] -> SuccessValidator

-- | <a>SuccessValidator</a> that always passes.
expectAnySuccess :: SuccessValidator

-- | Check that there were no updates.
expectNoUpdates :: SuccessValidator

-- | Check that there were no storage updates.
expectNoStorageUpdates :: SuccessValidator

-- | Similar to <a>expectStorageUpdate</a>, but for Lorentz values.
lExpectStorageUpdate :: forall st addr. (NiceStorage st, ToAddress addr, HasCallStack) => addr -> (st -> Either ValidationError ()) -> SuccessValidator

-- | Like <a>expectBalance</a>, for Lorentz values.
lExpectBalance :: ToAddress addr => addr -> Mutez -> SuccessValidator

-- | Similar to <a>expectStorage</a>, but for Lorentz values.
lExpectStorage :: forall st addr. (NiceStorage st, ToAddress addr, HasCallStack) => addr -> (st -> Either ValidationError ()) -> SuccessValidator

-- | Similar to <a>expectStorageConst</a>, for Lorentz values.
lExpectStorageConst :: forall st addr. (NiceStorage st, ToAddress addr) => addr -> st -> SuccessValidator

-- | Expect that interpretation of contract with given address ended with
--   [FAILED].
lExpectMichelsonFailed :: forall addr. ToAddress addr => (MichelsonFailed -> Bool) -> addr -> ExecutorError -> Bool

-- | Expect contract to fail with <a>FAILWITH</a> instruction and provided
--   value to match against the given predicate.
lExpectFailWith :: forall e. (Typeable (ToT e), IsoValue e) => (e -> Bool) -> ExecutorError -> Bool

-- | Expect contract to fail with given error.
lExpectError :: forall e. IsError e => (e -> Bool) -> ExecutorError -> Bool

-- | Version of <a>lExpectError</a> for the case when numeric
--   representation of errors is used.
lExpectErrorNumeric :: forall e. IsError e => ErrorTagMap -> (e -> Bool) -> ExecutorError -> Bool

-- | Expect contract to fail with given <tt>CustomError</tt>.
lExpectCustomError :: forall tag arg. (IsError (CustomError tag), arg ~ ErrorArg tag, Eq arg) => Label tag -> arg -> ExecutorError -> Bool

-- | Version of <a>lExpectCustomError</a> for the case when numeric
--   representation of errors is used.
lExpectCustomErrorNumeric :: forall tag arg. (IsError (CustomError tag), arg ~ ErrorArg tag, Eq arg) => ErrorTagMap -> Label tag -> arg -> ExecutorError -> Bool

-- | Specialization of <a>lExpectCustomError</a> for non-arg error case.
lExpectCustomError_ :: forall tag. (IsError (CustomError tag), ErrorArg tag ~ ()) => Label tag -> ExecutorError -> Bool

-- | Version of <a>lExpectCustomError_</a> for the case when numeric
--   representation of errors is used.
lExpectCustomErrorNumeric_ :: forall tag. (IsError (CustomError tag), ErrorArg tag ~ ()) => ErrorTagMap -> Label tag -> ExecutorError -> Bool

-- | Version of <a>lExpectStorageUpdate</a> specialized to "consumer"
--   contract (see <a>contractConsumer</a>).
lExpectConsumerStorage :: forall cp st addr. (st ~ [cp], NiceStorage st, ToTAddress cp addr) => addr -> (st -> Either ValidationError ()) -> SuccessValidator

-- | Assuming that "consumer" contract receives a value from <tt>View</tt>,
--   expect this view return value to be the given one.
--   
--   Despite consumer stores parameters it was called with in reversed
--   order, this function cares about it, so you should provide a list of
--   expected values in the same order in which the corresponding events
--   were happenning.
lExpectViewConsumerStorage :: (st ~ [cp], Eq cp, Buildable cp, NiceStorage st, ToTAddress cp addr) => addr -> [cp] -> SuccessValidator

-- | Data associated with a particular transaction.
data TxData
TxData :: Address -> Value -> EpName -> Mutez -> TxData
[tdSenderAddress] :: TxData -> Address
[tdParameter] :: TxData -> Value
[tdEntrypoint] :: TxData -> EpName
[tdAmount] :: TxData -> Mutez

-- | Initially these addresses have a lot of money.
genesisAddresses :: NonEmpty Address

-- | One of genesis addresses.
genesisAddress :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress1 :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress2 :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress3 :: Address
genesisAddress4 :: Address
genesisAddress5 :: Address
genesisAddress6 :: Address

-- | Finalize test suites.
runDocTests :: HasCallStack -> [DocTest] -> ContractDoc -> [TestTree]

-- | Tests all properties.
testLorentzDoc :: [DocTest]

-- | Calling <tt>excludeDocTests tests toExclude</tt> returns all test
--   suites from <tt>tests</tt> which are not present in
--   <tt>toExclude</tt>.
excludeDocTests :: [DocTest] -> [DocTest] -> [DocTest]

-- | A <a>Property</a> that always failes with given message.
failedProp :: Text -> Property

-- | A <a>Property</a> that always succeeds.
succeededProp :: Property

-- | The <a>Property</a> holds on `Left a`.
qcIsLeft :: Show b => Either a b -> Property

-- | The <a>Property</a> holds on `Right b`.
qcIsRight :: Show a => Either a b -> Property

-- | Dummy <a>ContractEnv</a> with some reasonable hardcoded values. You
--   can override values you are interested in using record update syntax.
dummyContractEnv :: ContractEnv

-- | Minimal (earliest) timestamp used for <tt>Arbitrary (CValue
--   'CTimestamp)</tt>
minTimestamp :: Timestamp

-- | Maximal (latest) timestamp used for <tt>Arbitrary (CValue
--   'CTimestamp)</tt>
maxTimestamp :: Timestamp

-- | Median of <a>minTimestamp</a> and <a>maxTimestamp</a>. Useful for
--   testing (exactly half of generated dates will be before and after this
--   date).
midTimestamp :: Timestamp

-- | Remembers parameters it was called with, last goes first.
contractConsumer :: ContractCode cp [cp]
