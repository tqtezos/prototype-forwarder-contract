-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automatic derivation of querying functions for servant
--   
--   This library lets you derive automatically Haskell functions that let
--   you query each endpoint of a <a>servant</a> webservice.
--   
--   See <a>the client section of the tutorial</a>.
--   
--   <a>CHANGELOG</a>
@package servant-client
@version 0.16.0.1

module Servant.Client.Internal.HttpClient

-- | The environment in which a request is run.
data ClientEnv
ClientEnv :: Manager -> BaseUrl -> Maybe (TVar CookieJar) -> ClientEnv
[manager] :: ClientEnv -> Manager
[baseUrl] :: ClientEnv -> BaseUrl
[cookieJar] :: ClientEnv -> Maybe (TVar CookieJar)

-- | <a>ClientEnv</a> smart constructor.
mkClientEnv :: Manager -> BaseUrl -> ClientEnv

-- | Generates a set of client functions for an API.
--   
--   Example:
--   
--   <pre>
--   type API = Capture "no" Int :&gt; Get '[JSON] Int
--          :&lt;|&gt; Get '[JSON] [Bool]
--   
--   api :: Proxy API
--   api = Proxy
--   
--   getInt :: Int -&gt; ClientM Int
--   getBools :: ClientM [Bool]
--   getInt :&lt;|&gt; getBools = client api
--   </pre>
client :: HasClient ClientM api => Proxy api -> Client ClientM api

-- | Change the monad the client functions live in, by supplying a
--   conversion function (a natural transformation to be precise).
--   
--   For example, assuming you have some <tt>manager ::
--   <tt>Manager</tt></tt> and <tt>baseurl :: <a>BaseUrl</a></tt> around:
--   
--   <pre>
--   type API = Get '[JSON] Int :&lt;|&gt; Capture "n" Int :&gt; Post '[JSON] Int
--   api :: Proxy API
--   api = Proxy
--   getInt :: IO Int
--   postInt :: Int -&gt; IO Int
--   getInt :&lt;|&gt; postInt = hoistClient api (flip runClientM cenv) (client api)
--     where cenv = mkClientEnv manager baseurl
--   </pre>
hoistClient :: HasClient ClientM api => Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api

-- | <tt>ClientM</tt> is the monad in which client functions run. Contains
--   the <a>Manager</a> and <a>BaseUrl</a> used for requests in the reader
--   environment.
newtype ClientM a
ClientM :: ReaderT ClientEnv (ExceptT ClientError IO) a -> ClientM a
[unClientM] :: ClientM a -> ReaderT ClientEnv (ExceptT ClientError IO) a
runClientM :: ClientM a -> ClientEnv -> IO (Either ClientError a)
performRequest :: Request -> ClientM Response
mkFailureResponse :: BaseUrl -> Request -> ResponseF ByteString -> ClientError
clientResponseToResponse :: (a -> b) -> Response a -> ResponseF b
requestToClientRequest :: BaseUrl -> Request -> Request
catchConnectionError :: IO a -> IO (Either ClientError a)
instance Control.Monad.Catch.MonadCatch Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Catch.MonadThrow Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Error.Class.MonadError Servant.Client.Core.ClientError.ClientError Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Reader.Class.MonadReader Servant.Client.Internal.HttpClient.ClientEnv Servant.Client.Internal.HttpClient.ClientM
instance GHC.Generics.Generic (Servant.Client.Internal.HttpClient.ClientM a)
instance Control.Monad.IO.Class.MonadIO Servant.Client.Internal.HttpClient.ClientM
instance GHC.Base.Monad Servant.Client.Internal.HttpClient.ClientM
instance GHC.Base.Applicative Servant.Client.Internal.HttpClient.ClientM
instance GHC.Base.Functor Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Base.MonadBase GHC.Types.IO Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Servant.Client.Internal.HttpClient.ClientM
instance Data.Functor.Alt.Alt Servant.Client.Internal.HttpClient.ClientM
instance Servant.Client.Core.RunClient.RunClient Servant.Client.Internal.HttpClient.ClientM


-- | This module provides <a>client</a> which can automatically generate
--   querying functions for each endpoint just from the type representing
--   your API.
module Servant.Client

-- | Generates a set of client functions for an API.
--   
--   Example:
--   
--   <pre>
--   type API = Capture "no" Int :&gt; Get '[JSON] Int
--          :&lt;|&gt; Get '[JSON] [Bool]
--   
--   api :: Proxy API
--   api = Proxy
--   
--   getInt :: Int -&gt; ClientM Int
--   getBools :: ClientM [Bool]
--   getInt :&lt;|&gt; getBools = client api
--   </pre>
client :: HasClient ClientM api => Proxy api -> Client ClientM api

-- | <tt>ClientM</tt> is the monad in which client functions run. Contains
--   the <a>Manager</a> and <a>BaseUrl</a> used for requests in the reader
--   environment.
data ClientM a
runClientM :: ClientM a -> ClientEnv -> IO (Either ClientError a)

-- | The environment in which a request is run.
data ClientEnv
ClientEnv :: Manager -> BaseUrl -> Maybe (TVar CookieJar) -> ClientEnv
[manager] :: ClientEnv -> Manager
[baseUrl] :: ClientEnv -> BaseUrl
[cookieJar] :: ClientEnv -> Maybe (TVar CookieJar)

-- | <a>ClientEnv</a> smart constructor.
mkClientEnv :: Manager -> BaseUrl -> ClientEnv

-- | Change the monad the client functions live in, by supplying a
--   conversion function (a natural transformation to be precise).
--   
--   For example, assuming you have some <tt>manager ::
--   <tt>Manager</tt></tt> and <tt>baseurl :: <a>BaseUrl</a></tt> around:
--   
--   <pre>
--   type API = Get '[JSON] Int :&lt;|&gt; Capture "n" Int :&gt; Post '[JSON] Int
--   api :: Proxy API
--   api = Proxy
--   getInt :: IO Int
--   postInt :: Int -&gt; IO Int
--   getInt :&lt;|&gt; postInt = hoistClient api (flip runClientM cenv) (client api)
--     where cenv = mkClientEnv manager baseurl
--   </pre>
hoistClient :: HasClient ClientM api => Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api

module Servant.Client.Internal.HttpClient.Streaming

-- | <tt>ClientM</tt> is the monad in which client functions run. Contains
--   the <a>Manager</a> and <a>BaseUrl</a> used for requests in the reader
--   environment.
newtype ClientM a
ClientM :: ReaderT ClientEnv (ExceptT ClientError (Codensity IO)) a -> ClientM a
[unClientM] :: ClientM a -> ReaderT ClientEnv (ExceptT ClientError (Codensity IO)) a

-- | Generates a set of client functions for an API.
--   
--   Example:
--   
--   <pre>
--   type API = Capture "no" Int :&gt; Get '[JSON] Int
--          :&lt;|&gt; Get '[JSON] [Bool]
--   
--   api :: Proxy API
--   api = Proxy
--   
--   getInt :: Int -&gt; ClientM Int
--   getBools :: ClientM [Bool]
--   getInt :&lt;|&gt; getBools = client api
--   </pre>
client :: HasClient ClientM api => Proxy api -> Client ClientM api

-- | Change the monad the client functions live in, by supplying a
--   conversion function (a natural transformation to be precise).
--   
--   For example, assuming you have some <tt>manager ::
--   <tt>Manager</tt></tt> and <tt>baseurl :: <a>BaseUrl</a></tt> around:
--   
--   <pre>
--   type API = Get '[JSON] Int :&lt;|&gt; Capture "n" Int :&gt; Post '[JSON] Int
--   api :: Proxy API
--   api = Proxy
--   getInt :: IO Int
--   postInt :: Int -&gt; IO Int
--   getInt :&lt;|&gt; postInt = hoistClient api (flip runClientM cenv) (client api)
--     where cenv = mkClientEnv manager baseurl
--   </pre>
hoistClient :: HasClient ClientM api => Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api
withClientM :: ClientM a -> ClientEnv -> (Either ClientError a -> IO b) -> IO b

-- | A <a>runClientM</a> variant for streaming client.
--   
--   It allows using this module's <a>ClientM</a> in a direct style. The
--   <a>NFData</a> constraint however prevents using this function with
--   genuine streaming response types (<tt>SourceT</tt>, <tt>Conduit</tt>,
--   pipes <a>Proxy</a> or <tt>Machine</tt>). For those you have to use
--   <a>withClientM</a>.
--   
--   <i>Note:</i> we <a>force</a> the result, so the likehood of
--   accidentally leaking a connection is smaller. Use with care.
runClientM :: NFData a => ClientM a -> ClientEnv -> IO (Either ClientError a)
performRequest :: Request -> ClientM Response
performWithStreamingRequest :: Request -> (StreamingResponse -> IO a) -> ClientM a

-- | The environment in which a request is run.
data ClientEnv
ClientEnv :: Manager -> BaseUrl -> Maybe (TVar CookieJar) -> ClientEnv
[manager] :: ClientEnv -> Manager
[baseUrl] :: ClientEnv -> BaseUrl
[cookieJar] :: ClientEnv -> Maybe (TVar CookieJar)

-- | <a>ClientEnv</a> smart constructor.
mkClientEnv :: Manager -> BaseUrl -> ClientEnv
clientResponseToResponse :: (a -> b) -> Response a -> ResponseF b
requestToClientRequest :: BaseUrl -> Request -> Request
catchConnectionError :: IO a -> IO (Either ClientError a)
instance Control.Monad.Error.Class.MonadError Servant.Client.Core.ClientError.ClientError Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Control.Monad.Reader.Class.MonadReader Servant.Client.Internal.HttpClient.ClientEnv Servant.Client.Internal.HttpClient.Streaming.ClientM
instance GHC.Generics.Generic (Servant.Client.Internal.HttpClient.Streaming.ClientM a)
instance Control.Monad.IO.Class.MonadIO Servant.Client.Internal.HttpClient.Streaming.ClientM
instance GHC.Base.Monad Servant.Client.Internal.HttpClient.Streaming.ClientM
instance GHC.Base.Applicative Servant.Client.Internal.HttpClient.Streaming.ClientM
instance GHC.Base.Functor Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Control.Monad.Base.MonadBase GHC.Types.IO Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Data.Functor.Alt.Alt Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Servant.Client.Core.RunClient.RunClient Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Servant.Client.Core.RunClient.RunStreamingClient Servant.Client.Internal.HttpClient.Streaming.ClientM


-- | This module provides <a>client</a> which can automatically generate
--   querying functions for each endpoint just from the type representing
--   your API.
--   
--   This client supports streaming operations.
module Servant.Client.Streaming

-- | Generates a set of client functions for an API.
--   
--   Example:
--   
--   <pre>
--   type API = Capture "no" Int :&gt; Get '[JSON] Int
--          :&lt;|&gt; Get '[JSON] [Bool]
--   
--   api :: Proxy API
--   api = Proxy
--   
--   getInt :: Int -&gt; ClientM Int
--   getBools :: ClientM [Bool]
--   getInt :&lt;|&gt; getBools = client api
--   </pre>
client :: HasClient ClientM api => Proxy api -> Client ClientM api

-- | <tt>ClientM</tt> is the monad in which client functions run. Contains
--   the <a>Manager</a> and <a>BaseUrl</a> used for requests in the reader
--   environment.
data ClientM a
withClientM :: ClientM a -> ClientEnv -> (Either ClientError a -> IO b) -> IO b

-- | A <a>runClientM</a> variant for streaming client.
--   
--   It allows using this module's <a>ClientM</a> in a direct style. The
--   <a>NFData</a> constraint however prevents using this function with
--   genuine streaming response types (<tt>SourceT</tt>, <tt>Conduit</tt>,
--   pipes <a>Proxy</a> or <tt>Machine</tt>). For those you have to use
--   <a>withClientM</a>.
--   
--   <i>Note:</i> we <a>force</a> the result, so the likehood of
--   accidentally leaking a connection is smaller. Use with care.
runClientM :: NFData a => ClientM a -> ClientEnv -> IO (Either ClientError a)

-- | The environment in which a request is run.
data ClientEnv
ClientEnv :: Manager -> BaseUrl -> Maybe (TVar CookieJar) -> ClientEnv
[manager] :: ClientEnv -> Manager
[baseUrl] :: ClientEnv -> BaseUrl
[cookieJar] :: ClientEnv -> Maybe (TVar CookieJar)

-- | <a>ClientEnv</a> smart constructor.
mkClientEnv :: Manager -> BaseUrl -> ClientEnv

-- | Change the monad the client functions live in, by supplying a
--   conversion function (a natural transformation to be precise).
--   
--   For example, assuming you have some <tt>manager ::
--   <tt>Manager</tt></tt> and <tt>baseurl :: <a>BaseUrl</a></tt> around:
--   
--   <pre>
--   type API = Get '[JSON] Int :&lt;|&gt; Capture "n" Int :&gt; Post '[JSON] Int
--   api :: Proxy API
--   api = Proxy
--   getInt :: IO Int
--   postInt :: Int -&gt; IO Int
--   getInt :&lt;|&gt; postInt = hoistClient api (flip runClientM cenv) (client api)
--     where cenv = mkClientEnv manager baseurl
--   </pre>
hoistClient :: HasClient ClientM api => Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api
