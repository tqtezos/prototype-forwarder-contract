-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic programming library for generalised deriving.
--   
--   This package provides functionality for generalising the deriving
--   mechanism in Haskell to arbitrary classes. It was first described in
--   the paper:
--   
--   <ul>
--   <li><i>A generic deriving mechanism for Haskell</i>. Jose Pedro
--   Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh.
--   Haskell'10.</li>
--   </ul>
--   
--   The current implementation integrates with the new GHC Generics. See
--   <a>http://www.haskell.org/haskellwiki/GHC.Generics</a> for more
--   information. Template Haskell code is provided for supporting older
--   GHCs.
@package generic-deriving
@version 1.12.4

module Generics.Deriving.Instances

module Generics.Deriving.Base

module Generics.Deriving.Functor
class GFunctor f
gmap :: GFunctor f => (a -> b) -> f a -> f b
gmap :: (GFunctor f, Generic1 f, GFunctor' (Rep1 f)) => (a -> b) -> f a -> f b
gmapdefault :: (Generic1 f, GFunctor' (Rep1 f)) => (a -> b) -> f a -> f b
class GFunctor' f
gmap' :: GFunctor' f => (a -> b) -> f a -> f b
instance Generics.Deriving.Functor.GFunctor f => Generics.Deriving.Functor.GFunctor' (GHC.Generics.Rec1 f)
instance (Generics.Deriving.Functor.GFunctor f, Generics.Deriving.Functor.GFunctor' g) => Generics.Deriving.Functor.GFunctor' (f GHC.Generics.:.: g)
instance Generics.Deriving.Functor.GFunctor ((->) r)
instance Generics.Deriving.Functor.GFunctor ((,) a)
instance Generics.Deriving.Functor.GFunctor []
instance Generics.Deriving.Functor.GFunctor f => Generics.Deriving.Functor.GFunctor (Data.Semigroup.Internal.Alt f)
instance Generics.Deriving.Functor.GFunctor (Data.Semigroup.Arg a)
instance Generics.Deriving.Functor.GFunctor Data.Complex.Complex
instance Generics.Deriving.Functor.GFunctor (Data.Functor.Const.Const m)
instance Generics.Deriving.Functor.GFunctor Data.Ord.Down
instance Generics.Deriving.Functor.GFunctor Data.Semigroup.Internal.Dual
instance Generics.Deriving.Functor.GFunctor (Data.Either.Either a)
instance Generics.Deriving.Functor.GFunctor Data.Monoid.First
instance Generics.Deriving.Functor.GFunctor Data.Semigroup.First
instance Generics.Deriving.Functor.GFunctor Data.Functor.Identity.Identity
instance Generics.Deriving.Functor.GFunctor GHC.Types.IO
instance Generics.Deriving.Functor.GFunctor Data.Monoid.Last
instance Generics.Deriving.Functor.GFunctor Data.Semigroup.Last
instance Generics.Deriving.Functor.GFunctor Data.Semigroup.Max
instance Generics.Deriving.Functor.GFunctor GHC.Maybe.Maybe
instance Generics.Deriving.Functor.GFunctor Data.Semigroup.Min
instance Generics.Deriving.Functor.GFunctor GHC.Base.NonEmpty
instance Generics.Deriving.Functor.GFunctor Data.Semigroup.Option
instance Generics.Deriving.Functor.GFunctor Data.Semigroup.Internal.Product
instance (Generics.Deriving.Functor.GFunctor f, Generics.Deriving.Functor.GFunctor g) => Generics.Deriving.Functor.GFunctor (Data.Functor.Product.Product f g)
instance Generics.Deriving.Functor.GFunctor Data.Proxy.Proxy
instance Generics.Deriving.Functor.GFunctor Data.Semigroup.Internal.Sum
instance (Generics.Deriving.Functor.GFunctor f, Generics.Deriving.Functor.GFunctor g) => Generics.Deriving.Functor.GFunctor (Data.Functor.Sum.Sum f g)
instance Generics.Deriving.Functor.GFunctor Data.Semigroup.WrappedMonoid
instance Generics.Deriving.Functor.GFunctor Control.Applicative.ZipList
instance Generics.Deriving.Functor.GFunctor' GHC.Generics.V1
instance Generics.Deriving.Functor.GFunctor' GHC.Generics.U1
instance Generics.Deriving.Functor.GFunctor' GHC.Generics.Par1
instance Generics.Deriving.Functor.GFunctor' (GHC.Generics.K1 i c)
instance Generics.Deriving.Functor.GFunctor' f => Generics.Deriving.Functor.GFunctor' (GHC.Generics.M1 i c f)
instance (Generics.Deriving.Functor.GFunctor' f, Generics.Deriving.Functor.GFunctor' g) => Generics.Deriving.Functor.GFunctor' (f GHC.Generics.:+: g)
instance (Generics.Deriving.Functor.GFunctor' f, Generics.Deriving.Functor.GFunctor' g) => Generics.Deriving.Functor.GFunctor' (f GHC.Generics.:*: g)
instance Generics.Deriving.Functor.GFunctor' GHC.Generics.UAddr
instance Generics.Deriving.Functor.GFunctor' GHC.Generics.UChar
instance Generics.Deriving.Functor.GFunctor' GHC.Generics.UDouble
instance Generics.Deriving.Functor.GFunctor' GHC.Generics.UFloat
instance Generics.Deriving.Functor.GFunctor' GHC.Generics.UInt
instance Generics.Deriving.Functor.GFunctor' GHC.Generics.UWord

module Generics.Deriving.Foldable
class GFoldable t
gfoldMap :: (GFoldable t, Monoid m) => (a -> m) -> t a -> m
gfoldMap :: (GFoldable t, Generic1 t, GFoldable' (Rep1 t), Monoid m) => (a -> m) -> t a -> m
gfold :: (GFoldable t, Monoid m) => t m -> m
gfoldr :: GFoldable t => (a -> b -> b) -> b -> t a -> b
gfoldr' :: GFoldable t => (a -> b -> b) -> b -> t a -> b
gfoldl :: GFoldable t => (a -> b -> a) -> a -> t b -> a
gfoldl' :: GFoldable t => (a -> b -> a) -> a -> t b -> a
gfoldr1 :: GFoldable t => (a -> a -> a) -> t a -> a
gfoldl1 :: GFoldable t => (a -> a -> a) -> t a -> a
gfoldMapdefault :: (Generic1 t, GFoldable' (Rep1 t), Monoid m) => (a -> m) -> t a -> m
gtoList :: GFoldable t => t a -> [a]
gconcat :: GFoldable t => t [a] -> [a]
gconcatMap :: GFoldable t => (a -> [b]) -> t a -> [b]
gand :: GFoldable t => t Bool -> Bool
gor :: GFoldable t => t Bool -> Bool
gany :: GFoldable t => (a -> Bool) -> t a -> Bool
gall :: GFoldable t => (a -> Bool) -> t a -> Bool
gsum :: (GFoldable t, Num a) => t a -> a
gproduct :: (GFoldable t, Num a) => t a -> a
gmaximum :: (GFoldable t, Ord a) => t a -> a
gmaximumBy :: GFoldable t => (a -> a -> Ordering) -> t a -> a
gminimum :: (GFoldable t, Ord a) => t a -> a
gminimumBy :: GFoldable t => (a -> a -> Ordering) -> t a -> a
gelem :: (GFoldable t, Eq a) => a -> t a -> Bool
gnotElem :: (GFoldable t, Eq a) => a -> t a -> Bool
gfind :: GFoldable t => (a -> Bool) -> t a -> Maybe a
class GFoldable' t
gfoldMap' :: (GFoldable' t, Monoid m) => (a -> m) -> t a -> m
instance Generics.Deriving.Foldable.GFoldable f => Generics.Deriving.Foldable.GFoldable' (GHC.Generics.Rec1 f)
instance (Generics.Deriving.Foldable.GFoldable f, Generics.Deriving.Foldable.GFoldable' g) => Generics.Deriving.Foldable.GFoldable' (f GHC.Generics.:.: g)
instance Generics.Deriving.Foldable.GFoldable ((,) a)
instance Generics.Deriving.Foldable.GFoldable []
instance Generics.Deriving.Foldable.GFoldable (Data.Semigroup.Arg a)
instance Generics.Deriving.Foldable.GFoldable Data.Complex.Complex
instance Generics.Deriving.Foldable.GFoldable (Data.Functor.Const.Const m)
instance Generics.Deriving.Foldable.GFoldable Data.Ord.Down
instance Generics.Deriving.Foldable.GFoldable Data.Semigroup.Internal.Dual
instance Generics.Deriving.Foldable.GFoldable (Data.Either.Either a)
instance Generics.Deriving.Foldable.GFoldable Data.Monoid.First
instance Generics.Deriving.Foldable.GFoldable Data.Semigroup.First
instance Generics.Deriving.Foldable.GFoldable Data.Functor.Identity.Identity
instance Generics.Deriving.Foldable.GFoldable Data.Monoid.Last
instance Generics.Deriving.Foldable.GFoldable Data.Semigroup.Last
instance Generics.Deriving.Foldable.GFoldable Data.Semigroup.Max
instance Generics.Deriving.Foldable.GFoldable GHC.Maybe.Maybe
instance Generics.Deriving.Foldable.GFoldable Data.Semigroup.Min
instance Generics.Deriving.Foldable.GFoldable GHC.Base.NonEmpty
instance Generics.Deriving.Foldable.GFoldable Data.Semigroup.Option
instance Generics.Deriving.Foldable.GFoldable Data.Semigroup.Internal.Product
instance (Generics.Deriving.Foldable.GFoldable f, Generics.Deriving.Foldable.GFoldable g) => Generics.Deriving.Foldable.GFoldable (Data.Functor.Product.Product f g)
instance Generics.Deriving.Foldable.GFoldable Data.Proxy.Proxy
instance Generics.Deriving.Foldable.GFoldable Data.Semigroup.Internal.Sum
instance (Generics.Deriving.Foldable.GFoldable f, Generics.Deriving.Foldable.GFoldable g) => Generics.Deriving.Foldable.GFoldable (Data.Functor.Sum.Sum f g)
instance Generics.Deriving.Foldable.GFoldable Data.Semigroup.WrappedMonoid
instance Generics.Deriving.Foldable.GFoldable Control.Applicative.ZipList
instance Generics.Deriving.Foldable.GFoldable' GHC.Generics.V1
instance Generics.Deriving.Foldable.GFoldable' GHC.Generics.U1
instance Generics.Deriving.Foldable.GFoldable' GHC.Generics.Par1
instance Generics.Deriving.Foldable.GFoldable' (GHC.Generics.K1 i c)
instance Generics.Deriving.Foldable.GFoldable' f => Generics.Deriving.Foldable.GFoldable' (GHC.Generics.M1 i c f)
instance (Generics.Deriving.Foldable.GFoldable' f, Generics.Deriving.Foldable.GFoldable' g) => Generics.Deriving.Foldable.GFoldable' (f GHC.Generics.:+: g)
instance (Generics.Deriving.Foldable.GFoldable' f, Generics.Deriving.Foldable.GFoldable' g) => Generics.Deriving.Foldable.GFoldable' (f GHC.Generics.:*: g)
instance Generics.Deriving.Foldable.GFoldable' GHC.Generics.UAddr
instance Generics.Deriving.Foldable.GFoldable' GHC.Generics.UChar
instance Generics.Deriving.Foldable.GFoldable' GHC.Generics.UDouble
instance Generics.Deriving.Foldable.GFoldable' GHC.Generics.UFloat
instance Generics.Deriving.Foldable.GFoldable' GHC.Generics.UInt
instance Generics.Deriving.Foldable.GFoldable' GHC.Generics.UWord

module Generics.Deriving.Eq
class GEq a
geq :: GEq a => a -> a -> Bool
geq :: (GEq a, Generic a, GEq' (Rep a)) => a -> a -> Bool
geqdefault :: (Generic a, GEq' (Rep a)) => a -> a -> Bool
class GEq' f
geq' :: GEq' f => f a -> f a -> Bool
instance Generics.Deriving.Eq.GEq c => Generics.Deriving.Eq.GEq' (GHC.Generics.K1 i c)
instance Generics.Deriving.Eq.GEq ()
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Eq.GEq b) => Generics.Deriving.Eq.GEq (a, b)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Eq.GEq b, Generics.Deriving.Eq.GEq c) => Generics.Deriving.Eq.GEq (a, b, c)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Eq.GEq b, Generics.Deriving.Eq.GEq c, Generics.Deriving.Eq.GEq d) => Generics.Deriving.Eq.GEq (a, b, c, d)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Eq.GEq b, Generics.Deriving.Eq.GEq c, Generics.Deriving.Eq.GEq d, Generics.Deriving.Eq.GEq e) => Generics.Deriving.Eq.GEq (a, b, c, d, e)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Eq.GEq b, Generics.Deriving.Eq.GEq c, Generics.Deriving.Eq.GEq d, Generics.Deriving.Eq.GEq e, Generics.Deriving.Eq.GEq f) => Generics.Deriving.Eq.GEq (a, b, c, d, e, f)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Eq.GEq b, Generics.Deriving.Eq.GEq c, Generics.Deriving.Eq.GEq d, Generics.Deriving.Eq.GEq e, Generics.Deriving.Eq.GEq f, Generics.Deriving.Eq.GEq g) => Generics.Deriving.Eq.GEq (a, b, c, d, e, f, g)
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq [a]
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (Generics.Deriving.Eq.GEq (f p), Generics.Deriving.Eq.GEq (g p)) => Generics.Deriving.Eq.GEq ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (Generics.Deriving.Eq.GEq (f p), Generics.Deriving.Eq.GEq (g p)) => Generics.Deriving.Eq.GEq ((GHC.Generics.:*:) f g p)
instance forall k1 k2 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). Generics.Deriving.Eq.GEq (f (g p)) => Generics.Deriving.Eq.GEq ((GHC.Generics.:.:) f g p)
instance Generics.Deriving.Eq.GEq Data.Semigroup.Internal.All
instance forall k (f :: k -> *) (a :: k). Generics.Deriving.Eq.GEq (f a) => Generics.Deriving.Eq.GEq (Data.Semigroup.Internal.Alt f a)
instance Generics.Deriving.Eq.GEq Data.Semigroup.Internal.Any
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Semigroup.Arg a b)
instance Generics.Deriving.Eq.GEq GHC.Generics.Associativity
instance Generics.Deriving.Eq.GEq GHC.Types.Bool
instance Generics.Deriving.Eq.GEq GHC.IO.Handle.Types.BufferMode
instance Generics.Deriving.Eq.GEq System.Posix.Types.CCc
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CChar
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CClock
instance Generics.Deriving.Eq.GEq System.Posix.Types.CDev
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CDouble
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CFloat
instance Generics.Deriving.Eq.GEq System.Posix.Types.CGid
instance Generics.Deriving.Eq.GEq GHC.Types.Char
instance Generics.Deriving.Eq.GEq System.Posix.Types.CIno
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CInt
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CIntMax
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CIntPtr
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CLLong
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CLong
instance Generics.Deriving.Eq.GEq System.Posix.Types.CMode
instance Generics.Deriving.Eq.GEq System.Posix.Types.CNlink
instance Generics.Deriving.Eq.GEq System.Posix.Types.COff
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Complex.Complex a)
instance forall k a (b :: k). Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Functor.Const.Const a b)
instance Generics.Deriving.Eq.GEq System.Posix.Types.CPid
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CPtrdiff
instance Generics.Deriving.Eq.GEq System.Posix.Types.CRLim
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CSChar
instance Generics.Deriving.Eq.GEq System.Posix.Types.CSpeed
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CSUSeconds
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CShort
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CSigAtomic
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CSize
instance Generics.Deriving.Eq.GEq System.Posix.Types.CSsize
instance Generics.Deriving.Eq.GEq System.Posix.Types.CTcflag
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CTime
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CUChar
instance Generics.Deriving.Eq.GEq System.Posix.Types.CUid
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CUInt
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CUIntMax
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CUIntPtr
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CULLong
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CULong
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CUSeconds
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CUShort
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CWchar
instance Generics.Deriving.Eq.GEq GHC.Generics.DecidedStrictness
instance Generics.Deriving.Eq.GEq GHC.Types.Double
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Ord.Down a)
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Semigroup.Internal.Dual a)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Eq.GEq b) => Generics.Deriving.Eq.GEq (Data.Either.Either a b)
instance Generics.Deriving.Eq.GEq Foreign.C.Error.Errno
instance Generics.Deriving.Eq.GEq GHC.IO.Exception.ExitCode
instance Generics.Deriving.Eq.GEq System.Posix.Types.Fd
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Monoid.First a)
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Semigroup.First a)
instance Generics.Deriving.Eq.GEq GHC.Generics.Fixity
instance Generics.Deriving.Eq.GEq GHC.Types.Float
instance Generics.Deriving.Eq.GEq (GHC.ForeignPtr.ForeignPtr a)
instance Generics.Deriving.Eq.GEq (GHC.Ptr.FunPtr a)
instance Generics.Deriving.Eq.GEq GHC.Unicode.GeneralCategory
instance Generics.Deriving.Eq.GEq GHC.IO.Handle.Types.Handle
instance Generics.Deriving.Eq.GEq GHC.IO.Handle.HandlePosn
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Functor.Identity.Identity a)
instance Generics.Deriving.Eq.GEq GHC.Types.Int
instance Generics.Deriving.Eq.GEq GHC.Int.Int8
instance Generics.Deriving.Eq.GEq GHC.Int.Int16
instance Generics.Deriving.Eq.GEq GHC.Int.Int32
instance Generics.Deriving.Eq.GEq GHC.Int.Int64
instance Generics.Deriving.Eq.GEq GHC.Integer.Type.Integer
instance Generics.Deriving.Eq.GEq Foreign.Ptr.IntPtr
instance Generics.Deriving.Eq.GEq GHC.IO.Exception.IOError
instance Generics.Deriving.Eq.GEq GHC.IO.Exception.IOErrorType
instance Generics.Deriving.Eq.GEq GHC.IO.IOMode.IOMode
instance forall k c i (p :: k). Generics.Deriving.Eq.GEq c => Generics.Deriving.Eq.GEq (GHC.Generics.K1 i c p)
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Monoid.Last a)
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Semigroup.Last a)
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Generics.Meta). Generics.Deriving.Eq.GEq (f p) => Generics.Deriving.Eq.GEq (GHC.Generics.M1 i c f p)
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (GHC.Maybe.Maybe a)
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Semigroup.Max a)
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Semigroup.Min a)
instance Generics.Deriving.Eq.GEq GHC.Natural.Natural
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (GHC.Base.NonEmpty a)
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Semigroup.Option a)
instance Generics.Deriving.Eq.GEq GHC.Types.Ordering
instance Generics.Deriving.Eq.GEq p => Generics.Deriving.Eq.GEq (GHC.Generics.Par1 p)
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Semigroup.Internal.Product a)
instance forall k (s :: k). Generics.Deriving.Eq.GEq (Data.Proxy.Proxy s)
instance Generics.Deriving.Eq.GEq (GHC.Ptr.Ptr a)
instance forall k (f :: k -> *) (p :: k). Generics.Deriving.Eq.GEq (f p) => Generics.Deriving.Eq.GEq (GHC.Generics.Rec1 f p)
instance Generics.Deriving.Eq.GEq GHC.IO.Device.SeekMode
instance Generics.Deriving.Eq.GEq (GHC.Stable.StablePtr a)
instance Generics.Deriving.Eq.GEq GHC.Generics.SourceStrictness
instance Generics.Deriving.Eq.GEq GHC.Generics.SourceUnpackedness
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Data.Semigroup.Internal.Sum a)
instance forall k (p :: k). Generics.Deriving.Eq.GEq (GHC.Generics.U1 p)
instance forall k (p :: k). Generics.Deriving.Eq.GEq (GHC.Generics.UAddr p)
instance forall k (p :: k). Generics.Deriving.Eq.GEq (GHC.Generics.UChar p)
instance forall k (p :: k). Generics.Deriving.Eq.GEq (GHC.Generics.UDouble p)
instance forall k (p :: k). Generics.Deriving.Eq.GEq (GHC.Generics.UFloat p)
instance forall k (p :: k). Generics.Deriving.Eq.GEq (GHC.Generics.UInt p)
instance forall k (p :: k). Generics.Deriving.Eq.GEq (GHC.Generics.UWord p)
instance Generics.Deriving.Eq.GEq Data.Version.Version
instance Generics.Deriving.Eq.GEq Data.Void.Void
instance Generics.Deriving.Eq.GEq GHC.Types.Word
instance Generics.Deriving.Eq.GEq GHC.Word.Word8
instance Generics.Deriving.Eq.GEq GHC.Word.Word16
instance Generics.Deriving.Eq.GEq GHC.Word.Word32
instance Generics.Deriving.Eq.GEq GHC.Word.Word64
instance Generics.Deriving.Eq.GEq Foreign.Ptr.WordPtr
instance Generics.Deriving.Eq.GEq m => Generics.Deriving.Eq.GEq (Data.Semigroup.WrappedMonoid m)
instance Generics.Deriving.Eq.GEq a => Generics.Deriving.Eq.GEq (Control.Applicative.ZipList a)
instance Generics.Deriving.Eq.GEq Foreign.C.Types.CBool
instance Generics.Deriving.Eq.GEq System.Posix.Types.CBlkSize
instance Generics.Deriving.Eq.GEq System.Posix.Types.CBlkCnt
instance Generics.Deriving.Eq.GEq System.Posix.Types.CClockId
instance Generics.Deriving.Eq.GEq System.Posix.Types.CFsBlkCnt
instance Generics.Deriving.Eq.GEq System.Posix.Types.CFsFilCnt
instance Generics.Deriving.Eq.GEq System.Posix.Types.CId
instance Generics.Deriving.Eq.GEq System.Posix.Types.CKey
instance Generics.Deriving.Eq.GEq' GHC.Generics.V1
instance Generics.Deriving.Eq.GEq' GHC.Generics.U1
instance forall k (a :: k -> *) i (c :: GHC.Generics.Meta). Generics.Deriving.Eq.GEq' a => Generics.Deriving.Eq.GEq' (GHC.Generics.M1 i c a)
instance forall k (a :: k -> *) (b :: k -> *). (Generics.Deriving.Eq.GEq' a, Generics.Deriving.Eq.GEq' b) => Generics.Deriving.Eq.GEq' (a GHC.Generics.:+: b)
instance forall k (a :: k -> *) (b :: k -> *). (Generics.Deriving.Eq.GEq' a, Generics.Deriving.Eq.GEq' b) => Generics.Deriving.Eq.GEq' (a GHC.Generics.:*: b)
instance Generics.Deriving.Eq.GEq' GHC.Generics.UAddr
instance Generics.Deriving.Eq.GEq' GHC.Generics.UChar
instance Generics.Deriving.Eq.GEq' GHC.Generics.UDouble
instance Generics.Deriving.Eq.GEq' GHC.Generics.UFloat
instance Generics.Deriving.Eq.GEq' GHC.Generics.UInt
instance Generics.Deriving.Eq.GEq' GHC.Generics.UWord

module Generics.Deriving.Enum
class GEnum a
genum :: GEnum a => [a]
genum :: (GEnum a, Generic a, Enum' (Rep a)) => [a]
genumDefault :: (Generic a, Enum' (Rep a)) => [a]
toEnumDefault :: (Generic a, Enum' (Rep a)) => Int -> a
fromEnumDefault :: (GEq a, Generic a, Enum' (Rep a)) => a -> Int
class Enum' f
enum' :: Enum' f => [f a]
class (Ord a) => GIx a

-- | The list of values in the subrange defined by a bounding pair.
range :: GIx a => (a, a) -> [a]

-- | The position of a subscript in the subrange.
index :: GIx a => (a, a) -> a -> Int

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: GIx a => (a, a) -> a -> Bool

-- | The list of values in the subrange defined by a bounding pair.
range :: (GIx a, GEq a, Generic a, Enum' (Rep a)) => (a, a) -> [a]

-- | The position of a subscript in the subrange.
index :: (GIx a, GEq a, Generic a, Enum' (Rep a)) => (a, a) -> a -> Int

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: (GIx a, GEq a, Generic a, Enum' (Rep a)) => (a, a) -> a -> Bool
rangeDefault :: (GEq a, Generic a, Enum' (Rep a)) => (a, a) -> [a]
indexDefault :: (GEq a, Generic a, Enum' (Rep a)) => (a, a) -> a -> Int
inRangeDefault :: (GEq a, Generic a, Enum' (Rep a)) => (a, a) -> a -> Bool
instance Generics.Deriving.Enum.GIx ()
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a, Generics.Deriving.Eq.GEq b, Generics.Deriving.Enum.GEnum b, Generics.Deriving.Enum.GIx b) => Generics.Deriving.Enum.GIx (a, b)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a, Generics.Deriving.Eq.GEq b, Generics.Deriving.Enum.GEnum b, Generics.Deriving.Enum.GIx b, Generics.Deriving.Eq.GEq c, Generics.Deriving.Enum.GEnum c, Generics.Deriving.Enum.GIx c) => Generics.Deriving.Enum.GIx (a, b, c)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a, Generics.Deriving.Eq.GEq b, Generics.Deriving.Enum.GEnum b, Generics.Deriving.Enum.GIx b, Generics.Deriving.Eq.GEq c, Generics.Deriving.Enum.GEnum c, Generics.Deriving.Enum.GIx c, Generics.Deriving.Eq.GEq d, Generics.Deriving.Enum.GEnum d, Generics.Deriving.Enum.GIx d) => Generics.Deriving.Enum.GIx (a, b, c, d)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a, Generics.Deriving.Eq.GEq b, Generics.Deriving.Enum.GEnum b, Generics.Deriving.Enum.GIx b, Generics.Deriving.Eq.GEq c, Generics.Deriving.Enum.GEnum c, Generics.Deriving.Enum.GIx c, Generics.Deriving.Eq.GEq d, Generics.Deriving.Enum.GEnum d, Generics.Deriving.Enum.GIx d, Generics.Deriving.Eq.GEq e, Generics.Deriving.Enum.GEnum e, Generics.Deriving.Enum.GIx e) => Generics.Deriving.Enum.GIx (a, b, c, d, e)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a, Generics.Deriving.Eq.GEq b, Generics.Deriving.Enum.GEnum b, Generics.Deriving.Enum.GIx b, Generics.Deriving.Eq.GEq c, Generics.Deriving.Enum.GEnum c, Generics.Deriving.Enum.GIx c, Generics.Deriving.Eq.GEq d, Generics.Deriving.Enum.GEnum d, Generics.Deriving.Enum.GIx d, Generics.Deriving.Eq.GEq e, Generics.Deriving.Enum.GEnum e, Generics.Deriving.Enum.GIx e, Generics.Deriving.Eq.GEq f, Generics.Deriving.Enum.GEnum f, Generics.Deriving.Enum.GIx f) => Generics.Deriving.Enum.GIx (a, b, c, d, e, f)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a, Generics.Deriving.Eq.GEq b, Generics.Deriving.Enum.GEnum b, Generics.Deriving.Enum.GIx b, Generics.Deriving.Eq.GEq c, Generics.Deriving.Enum.GEnum c, Generics.Deriving.Enum.GIx c, Generics.Deriving.Eq.GEq d, Generics.Deriving.Enum.GEnum d, Generics.Deriving.Enum.GIx d, Generics.Deriving.Eq.GEq e, Generics.Deriving.Enum.GEnum e, Generics.Deriving.Enum.GIx e, Generics.Deriving.Eq.GEq f, Generics.Deriving.Enum.GEnum f, Generics.Deriving.Enum.GIx f, Generics.Deriving.Eq.GEq g, Generics.Deriving.Enum.GEnum g, Generics.Deriving.Enum.GIx g) => Generics.Deriving.Enum.GIx (a, b, c, d, e, f, g)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx [a]
instance Generics.Deriving.Enum.GIx Data.Semigroup.Internal.All
instance forall k (f :: k -> *) (a :: k). (Generics.Deriving.Eq.GEq (f a), Generics.Deriving.Enum.GEnum (f a), Generics.Deriving.Enum.GIx (f a)) => Generics.Deriving.Enum.GIx (Data.Semigroup.Internal.Alt f a)
instance Generics.Deriving.Enum.GIx Data.Semigroup.Internal.Any
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a, Generics.Deriving.Enum.GEnum b) => Generics.Deriving.Enum.GIx (Data.Semigroup.Arg a b)
instance Generics.Deriving.Enum.GIx GHC.Generics.Associativity
instance Generics.Deriving.Enum.GIx GHC.Types.Bool
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CChar
instance Generics.Deriving.Enum.GIx System.Posix.Types.CGid
instance Generics.Deriving.Enum.GIx System.Posix.Types.CIno
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CInt
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CIntMax
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CIntPtr
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CLLong
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CLong
instance Generics.Deriving.Enum.GIx System.Posix.Types.CMode
instance Generics.Deriving.Enum.GIx System.Posix.Types.CNlink
instance Generics.Deriving.Enum.GIx System.Posix.Types.COff
instance Generics.Deriving.Enum.GIx System.Posix.Types.CPid
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CPtrdiff
instance Generics.Deriving.Enum.GIx System.Posix.Types.CRLim
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CSChar
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CShort
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CSigAtomic
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CSize
instance Generics.Deriving.Enum.GIx System.Posix.Types.CSsize
instance Generics.Deriving.Enum.GIx System.Posix.Types.CTcflag
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CUChar
instance Generics.Deriving.Enum.GIx System.Posix.Types.CUid
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CUInt
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CUIntMax
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CUIntPtr
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CULLong
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CULong
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CUShort
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CWchar
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (Data.Semigroup.Internal.Dual a)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a, Generics.Deriving.Eq.GEq b, Generics.Deriving.Enum.GEnum b, Generics.Deriving.Enum.GIx b) => Generics.Deriving.Enum.GIx (Data.Either.Either a b)
instance Generics.Deriving.Enum.GIx GHC.IO.Exception.ExitCode
instance Generics.Deriving.Enum.GIx System.Posix.Types.Fd
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (Data.Monoid.First a)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (Data.Semigroup.First a)
instance Generics.Deriving.Enum.GIx GHC.Generics.Fixity
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (Data.Functor.Identity.Identity a)
instance Generics.Deriving.Enum.GIx GHC.Types.Int
instance Generics.Deriving.Enum.GIx GHC.Int.Int8
instance Generics.Deriving.Enum.GIx GHC.Int.Int16
instance Generics.Deriving.Enum.GIx GHC.Int.Int32
instance Generics.Deriving.Enum.GIx GHC.Int.Int64
instance Generics.Deriving.Enum.GIx GHC.Integer.Type.Integer
instance Generics.Deriving.Enum.GIx Foreign.Ptr.IntPtr
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (Data.Monoid.Last a)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (Data.Semigroup.Last a)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (Data.Semigroup.Max a)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (GHC.Maybe.Maybe a)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (Data.Semigroup.Min a)
instance Generics.Deriving.Enum.GIx GHC.Natural.Natural
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (GHC.Base.NonEmpty a)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (Data.Semigroup.Option a)
instance Generics.Deriving.Enum.GIx GHC.Types.Ordering
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (Data.Semigroup.Internal.Product a)
instance forall k (s :: k). Generics.Deriving.Enum.GIx (Data.Proxy.Proxy s)
instance (Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GIx a) => Generics.Deriving.Enum.GIx (Data.Semigroup.Internal.Sum a)
instance Generics.Deriving.Enum.GIx GHC.Types.Word
instance Generics.Deriving.Enum.GIx GHC.Word.Word8
instance Generics.Deriving.Enum.GIx GHC.Word.Word16
instance Generics.Deriving.Enum.GIx GHC.Word.Word32
instance Generics.Deriving.Enum.GIx GHC.Word.Word64
instance Generics.Deriving.Enum.GIx Foreign.Ptr.WordPtr
instance (Generics.Deriving.Eq.GEq m, Generics.Deriving.Enum.GEnum m, Generics.Deriving.Enum.GIx m) => Generics.Deriving.Enum.GIx (Data.Semigroup.WrappedMonoid m)
instance Generics.Deriving.Enum.GIx Foreign.C.Types.CBool
instance Generics.Deriving.Enum.GIx System.Posix.Types.CBlkSize
instance Generics.Deriving.Enum.GIx System.Posix.Types.CBlkCnt
instance Generics.Deriving.Enum.GIx System.Posix.Types.CClockId
instance Generics.Deriving.Enum.GIx System.Posix.Types.CFsBlkCnt
instance Generics.Deriving.Enum.GIx System.Posix.Types.CFsFilCnt
instance Generics.Deriving.Enum.GIx System.Posix.Types.CId
instance Generics.Deriving.Enum.GIx System.Posix.Types.CKey
instance Generics.Deriving.Enum.GEnum c => Generics.Deriving.Enum.Enum' (GHC.Generics.K1 i c)
instance Generics.Deriving.Enum.GEnum ()
instance (Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GEnum b) => Generics.Deriving.Enum.GEnum (a, b)
instance (Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GEnum b, Generics.Deriving.Enum.GEnum c) => Generics.Deriving.Enum.GEnum (a, b, c)
instance (Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GEnum b, Generics.Deriving.Enum.GEnum c, Generics.Deriving.Enum.GEnum d) => Generics.Deriving.Enum.GEnum (a, b, c, d)
instance (Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GEnum b, Generics.Deriving.Enum.GEnum c, Generics.Deriving.Enum.GEnum d, Generics.Deriving.Enum.GEnum e) => Generics.Deriving.Enum.GEnum (a, b, c, d, e)
instance (Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GEnum b, Generics.Deriving.Enum.GEnum c, Generics.Deriving.Enum.GEnum d, Generics.Deriving.Enum.GEnum e, Generics.Deriving.Enum.GEnum f) => Generics.Deriving.Enum.GEnum (a, b, c, d, e, f)
instance (Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GEnum b, Generics.Deriving.Enum.GEnum c, Generics.Deriving.Enum.GEnum d, Generics.Deriving.Enum.GEnum e, Generics.Deriving.Enum.GEnum f, Generics.Deriving.Enum.GEnum g) => Generics.Deriving.Enum.GEnum (a, b, c, d, e, f, g)
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum [a]
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (Generics.Deriving.Enum.GEnum (f p), Generics.Deriving.Enum.GEnum (g p)) => Generics.Deriving.Enum.GEnum ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (Generics.Deriving.Enum.GEnum (f p), Generics.Deriving.Enum.GEnum (g p)) => Generics.Deriving.Enum.GEnum ((GHC.Generics.:*:) f g p)
instance forall k1 k2 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). Generics.Deriving.Enum.GEnum (f (g p)) => Generics.Deriving.Enum.GEnum ((GHC.Generics.:.:) f g p)
instance Generics.Deriving.Enum.GEnum Data.Semigroup.Internal.All
instance forall k (f :: k -> *) (a :: k). Generics.Deriving.Enum.GEnum (f a) => Generics.Deriving.Enum.GEnum (Data.Semigroup.Internal.Alt f a)
instance Generics.Deriving.Enum.GEnum Data.Semigroup.Internal.Any
instance (Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GEnum b) => Generics.Deriving.Enum.GEnum (Data.Semigroup.Arg a b)
instance Generics.Deriving.Enum.GEnum GHC.Generics.Associativity
instance Generics.Deriving.Enum.GEnum GHC.Types.Bool
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CCc
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CChar
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CClock
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CDev
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CDouble
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CFloat
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CGid
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CIno
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CInt
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CIntMax
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CIntPtr
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CLLong
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CLong
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CMode
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CNlink
instance Generics.Deriving.Enum.GEnum System.Posix.Types.COff
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Complex.Complex a)
instance forall k a (b :: k). Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Functor.Const.Const a b)
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CPid
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CPtrdiff
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CRLim
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CSChar
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CSpeed
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CSUSeconds
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CShort
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CSigAtomic
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CSize
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CSsize
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CTcflag
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CTime
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CUChar
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CUid
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CUInt
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CUIntMax
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CUIntPtr
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CULLong
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CULong
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CUSeconds
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CUShort
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CWchar
instance Generics.Deriving.Enum.GEnum GHC.Types.Double
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Semigroup.Internal.Dual a)
instance (Generics.Deriving.Enum.GEnum a, Generics.Deriving.Enum.GEnum b) => Generics.Deriving.Enum.GEnum (Data.Either.Either a b)
instance Generics.Deriving.Enum.GEnum GHC.IO.Exception.ExitCode
instance Generics.Deriving.Enum.GEnum System.Posix.Types.Fd
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Monoid.First a)
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Semigroup.First a)
instance Generics.Deriving.Enum.GEnum GHC.Generics.Fixity
instance Generics.Deriving.Enum.GEnum GHC.Types.Float
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Functor.Identity.Identity a)
instance Generics.Deriving.Enum.GEnum GHC.Types.Int
instance Generics.Deriving.Enum.GEnum GHC.Int.Int8
instance Generics.Deriving.Enum.GEnum GHC.Int.Int16
instance Generics.Deriving.Enum.GEnum GHC.Int.Int32
instance Generics.Deriving.Enum.GEnum GHC.Int.Int64
instance Generics.Deriving.Enum.GEnum GHC.Integer.Type.Integer
instance Generics.Deriving.Enum.GEnum Foreign.Ptr.IntPtr
instance forall k c i (p :: k). Generics.Deriving.Enum.GEnum c => Generics.Deriving.Enum.GEnum (GHC.Generics.K1 i c p)
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Monoid.Last a)
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Semigroup.Last a)
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Generics.Meta). Generics.Deriving.Enum.GEnum (f p) => Generics.Deriving.Enum.GEnum (GHC.Generics.M1 i c f p)
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Semigroup.Max a)
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (GHC.Maybe.Maybe a)
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Semigroup.Min a)
instance Generics.Deriving.Enum.GEnum GHC.Natural.Natural
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (GHC.Base.NonEmpty a)
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Semigroup.Option a)
instance Generics.Deriving.Enum.GEnum GHC.Types.Ordering
instance Generics.Deriving.Enum.GEnum p => Generics.Deriving.Enum.GEnum (GHC.Generics.Par1 p)
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Semigroup.Internal.Product a)
instance forall k (s :: k). Generics.Deriving.Enum.GEnum (Data.Proxy.Proxy s)
instance forall k (f :: k -> *) (p :: k). Generics.Deriving.Enum.GEnum (f p) => Generics.Deriving.Enum.GEnum (GHC.Generics.Rec1 f p)
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Data.Semigroup.Internal.Sum a)
instance forall k (p :: k). Generics.Deriving.Enum.GEnum (GHC.Generics.U1 p)
instance Generics.Deriving.Enum.GEnum GHC.Types.Word
instance Generics.Deriving.Enum.GEnum GHC.Word.Word8
instance Generics.Deriving.Enum.GEnum GHC.Word.Word16
instance Generics.Deriving.Enum.GEnum GHC.Word.Word32
instance Generics.Deriving.Enum.GEnum GHC.Word.Word64
instance Generics.Deriving.Enum.GEnum Foreign.Ptr.WordPtr
instance Generics.Deriving.Enum.GEnum m => Generics.Deriving.Enum.GEnum (Data.Semigroup.WrappedMonoid m)
instance Generics.Deriving.Enum.GEnum a => Generics.Deriving.Enum.GEnum (Control.Applicative.ZipList a)
instance Generics.Deriving.Enum.GEnum Foreign.C.Types.CBool
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CBlkSize
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CBlkCnt
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CClockId
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CFsBlkCnt
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CFsFilCnt
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CId
instance Generics.Deriving.Enum.GEnum System.Posix.Types.CKey
instance Generics.Deriving.Enum.Enum' GHC.Generics.U1
instance forall k (f :: k -> *) i (c :: GHC.Generics.Meta). Generics.Deriving.Enum.Enum' f => Generics.Deriving.Enum.Enum' (GHC.Generics.M1 i c f)
instance forall k (f :: k -> *) (g :: k -> *). (Generics.Deriving.Enum.Enum' f, Generics.Deriving.Enum.Enum' g) => Generics.Deriving.Enum.Enum' (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) (g :: k -> *). (Generics.Deriving.Enum.Enum' f, Generics.Deriving.Enum.Enum' g) => Generics.Deriving.Enum.Enum' (f GHC.Generics.:*: g)

module Generics.Deriving.Copoint
class GCopoint d
gcopoint :: GCopoint d => d a -> a
gcopoint :: (GCopoint d, Generic1 d, GCopoint' (Rep1 d)) => d a -> a
gcopointdefault :: (Generic1 d, GCopoint' (Rep1 d)) => d a -> a
class GCopoint' t
gcopoint' :: GCopoint' t => t a -> Maybe a
instance Generics.Deriving.Copoint.GCopoint f => Generics.Deriving.Copoint.GCopoint' (GHC.Generics.Rec1 f)
instance (Generics.Deriving.Copoint.GCopoint f, Generics.Deriving.Copoint.GCopoint' g) => Generics.Deriving.Copoint.GCopoint' (f GHC.Generics.:.: g)
instance Generics.Deriving.Copoint.GCopoint ((,) a)
instance Generics.Deriving.Copoint.GCopoint ((,,) a b)
instance Generics.Deriving.Copoint.GCopoint ((,,,) a b c)
instance Generics.Deriving.Copoint.GCopoint ((,,,,) a b c d)
instance Generics.Deriving.Copoint.GCopoint ((,,,,,) a b c d e)
instance Generics.Deriving.Copoint.GCopoint ((,,,,,,) a b c d e f)
instance Generics.Deriving.Copoint.GCopoint f => Generics.Deriving.Copoint.GCopoint (Data.Semigroup.Internal.Alt f)
instance Generics.Deriving.Copoint.GCopoint (Data.Semigroup.Arg a)
instance Generics.Deriving.Copoint.GCopoint Data.Ord.Down
instance Generics.Deriving.Copoint.GCopoint Data.Semigroup.Internal.Dual
instance Generics.Deriving.Copoint.GCopoint Data.Semigroup.First
instance Generics.Deriving.Copoint.GCopoint Data.Functor.Identity.Identity
instance Generics.Deriving.Copoint.GCopoint Data.Semigroup.Last
instance Generics.Deriving.Copoint.GCopoint Data.Semigroup.Max
instance Generics.Deriving.Copoint.GCopoint Data.Semigroup.Min
instance (Generics.Deriving.Copoint.GCopoint f, Generics.Deriving.Copoint.GCopoint g) => Generics.Deriving.Copoint.GCopoint (Data.Functor.Sum.Sum f g)
instance Generics.Deriving.Copoint.GCopoint Data.Semigroup.Internal.Sum
instance Generics.Deriving.Copoint.GCopoint m => Generics.Deriving.Copoint.GCopoint (Control.Applicative.WrappedMonad m)
instance Generics.Deriving.Copoint.GCopoint Data.Semigroup.WrappedMonoid
instance Generics.Deriving.Copoint.GCopoint' GHC.Generics.V1
instance Generics.Deriving.Copoint.GCopoint' GHC.Generics.U1
instance Generics.Deriving.Copoint.GCopoint' GHC.Generics.Par1
instance Generics.Deriving.Copoint.GCopoint' (GHC.Generics.K1 i c)
instance Generics.Deriving.Copoint.GCopoint' f => Generics.Deriving.Copoint.GCopoint' (GHC.Generics.M1 i c f)
instance (Generics.Deriving.Copoint.GCopoint' f, Generics.Deriving.Copoint.GCopoint' g) => Generics.Deriving.Copoint.GCopoint' (f GHC.Generics.:+: g)
instance (Generics.Deriving.Copoint.GCopoint' f, Generics.Deriving.Copoint.GCopoint' g) => Generics.Deriving.Copoint.GCopoint' (f GHC.Generics.:*: g)


-- | Summary: Return the name of all the constructors of a type.
module Generics.Deriving.ConNames
class ConNames f
gconNames :: ConNames f => f a -> [String]
gconNameOf :: ConNames f => f a -> String

-- | Return the name of all the constructors of the type of the given term.
conNames :: (Generic a, ConNames (Rep a)) => a -> [String]

-- | Return the name of the constructor of the given term
conNameOf :: (ConNames (Rep a), Generic a) => a -> String
instance forall k (f :: k -> *) (g :: k -> *). (Generics.Deriving.ConNames.ConNames f, Generics.Deriving.ConNames.ConNames g) => Generics.Deriving.ConNames.ConNames (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) (c :: GHC.Generics.Meta). Generics.Deriving.ConNames.ConNames f => Generics.Deriving.ConNames.ConNames (GHC.Generics.D1 c f)
instance forall k (c :: GHC.Generics.Meta) (f :: k -> *). GHC.Generics.Constructor c => Generics.Deriving.ConNames.ConNames (GHC.Generics.C1 c f)


-- | This module provides two main features:
--   
--   <ol>
--   <li><a>GMonoid</a>, a generic version of the <a>Monoid</a> type class,
--   including instances of the types from <a>Data.Monoid</a></li>
--   <li>Default generic definitions for the <a>Monoid</a> methods
--   <a>mempty</a> and <a>mappend</a></li>
--   </ol>
--   
--   The generic defaults only work for types without alternatives (i.e.
--   they have only one constructor). We cannot in general know how to deal
--   with different constructors.
module Generics.Deriving.Monoid
class GMonoid a

-- | Generic <a>mempty</a>
gmempty :: GMonoid a => a

-- | Generic <a>mappend</a>
gmappend :: GMonoid a => a -> a -> a

-- | Generic <a>mconcat</a>
gmconcat :: GMonoid a => [a] -> a

-- | Generic <a>mempty</a>
gmempty :: (GMonoid a, Generic a, GMonoid' (Rep a)) => a

-- | Generic <a>mappend</a>
gmappend :: (GMonoid a, Generic a, GMonoid' (Rep a)) => a -> a -> a
gmemptydefault :: (Generic a, GMonoid' (Rep a)) => a
gmappenddefault :: (Generic a, GMonoid' (Rep a)) => a -> a -> a
class GMonoid' f
gmempty' :: GMonoid' f => f x
gmappend' :: GMonoid' f => f x -> f x -> f x
memptydefault :: (Generic a, Monoid' (Rep a)) => a
mappenddefault :: (Generic a, Monoid' (Rep a)) => a -> a -> a
class Monoid' f
mempty' :: Monoid' f => f x
mappend' :: Monoid' f => f x -> f x -> f x
instance Generics.Deriving.Monoid.GMonoid a => Generics.Deriving.Monoid.GMonoid' (GHC.Generics.K1 i a)
instance Generics.Deriving.Monoid.GMonoid GHC.Types.Ordering
instance Generics.Deriving.Monoid.GMonoid ()
instance Generics.Deriving.Monoid.GMonoid Data.Semigroup.Internal.Any
instance Generics.Deriving.Monoid.GMonoid Data.Semigroup.Internal.All
instance Generics.Deriving.Monoid.GMonoid (Data.Monoid.First a)
instance Generics.Deriving.Monoid.GMonoid (Data.Monoid.Last a)
instance GHC.Num.Num a => Generics.Deriving.Monoid.GMonoid (Data.Semigroup.Internal.Sum a)
instance GHC.Num.Num a => Generics.Deriving.Monoid.GMonoid (Data.Semigroup.Internal.Product a)
instance Generics.Deriving.Monoid.GMonoid [a]
instance Generics.Deriving.Monoid.GMonoid (Data.Semigroup.Internal.Endo a)
instance GHC.Base.Alternative f => Generics.Deriving.Monoid.GMonoid (Data.Semigroup.Internal.Alt f a)
instance Generics.Deriving.Monoid.GMonoid a => Generics.Deriving.Monoid.GMonoid (Data.Semigroup.Internal.Dual a)
instance Generics.Deriving.Monoid.GMonoid a => Generics.Deriving.Monoid.GMonoid (GHC.Maybe.Maybe a)
instance Generics.Deriving.Monoid.GMonoid b => Generics.Deriving.Monoid.GMonoid (a -> b)
instance forall k a (b :: k). Generics.Deriving.Monoid.GMonoid a => Generics.Deriving.Monoid.GMonoid (Data.Functor.Const.Const a b)
instance Generics.Deriving.Monoid.GMonoid a => Generics.Deriving.Monoid.GMonoid (Data.Ord.Down a)
instance forall k (s :: k). Generics.Deriving.Monoid.GMonoid (Data.Proxy.Proxy s)
instance Generics.Deriving.Monoid.GMonoid a => Generics.Deriving.Monoid.GMonoid (Data.Functor.Identity.Identity a)
instance Generics.Deriving.Monoid.GMonoid m => Generics.Deriving.Monoid.GMonoid (Data.Semigroup.WrappedMonoid m)
instance (Generics.Deriving.Monoid.GMonoid a, Generics.Deriving.Monoid.GMonoid b) => Generics.Deriving.Monoid.GMonoid (a, b)
instance (Generics.Deriving.Monoid.GMonoid a, Generics.Deriving.Monoid.GMonoid b, Generics.Deriving.Monoid.GMonoid c) => Generics.Deriving.Monoid.GMonoid (a, b, c)
instance (Generics.Deriving.Monoid.GMonoid a, Generics.Deriving.Monoid.GMonoid b, Generics.Deriving.Monoid.GMonoid c, Generics.Deriving.Monoid.GMonoid d) => Generics.Deriving.Monoid.GMonoid (a, b, c, d)
instance (Generics.Deriving.Monoid.GMonoid a, Generics.Deriving.Monoid.GMonoid b, Generics.Deriving.Monoid.GMonoid c, Generics.Deriving.Monoid.GMonoid d, Generics.Deriving.Monoid.GMonoid e) => Generics.Deriving.Monoid.GMonoid (a, b, c, d, e)
instance (Generics.Deriving.Monoid.GMonoid a, Generics.Deriving.Monoid.GMonoid b, Generics.Deriving.Monoid.GMonoid c, Generics.Deriving.Monoid.GMonoid d, Generics.Deriving.Monoid.GMonoid e, Generics.Deriving.Monoid.GMonoid f) => Generics.Deriving.Monoid.GMonoid (a, b, c, d, e, f)
instance (Generics.Deriving.Monoid.GMonoid a, Generics.Deriving.Monoid.GMonoid b, Generics.Deriving.Monoid.GMonoid c, Generics.Deriving.Monoid.GMonoid d, Generics.Deriving.Monoid.GMonoid e, Generics.Deriving.Monoid.GMonoid f, Generics.Deriving.Monoid.GMonoid g) => Generics.Deriving.Monoid.GMonoid (a, b, c, d, e, f, g)
instance (Generics.Deriving.Monoid.GMonoid a, Generics.Deriving.Monoid.GMonoid b, Generics.Deriving.Monoid.GMonoid c, Generics.Deriving.Monoid.GMonoid d, Generics.Deriving.Monoid.GMonoid e, Generics.Deriving.Monoid.GMonoid f, Generics.Deriving.Monoid.GMonoid g, Generics.Deriving.Monoid.GMonoid h) => Generics.Deriving.Monoid.GMonoid (a, b, c, d, e, f, g, h)
instance Generics.Deriving.Monoid.Monoid' GHC.Generics.U1
instance GHC.Base.Monoid a => Generics.Deriving.Monoid.Monoid' (GHC.Generics.K1 i a)
instance forall k (f :: k -> *) i (c :: GHC.Generics.Meta). Generics.Deriving.Monoid.Monoid' f => Generics.Deriving.Monoid.Monoid' (GHC.Generics.M1 i c f)
instance forall k (f :: k -> *) (h :: k -> *). (Generics.Deriving.Monoid.Monoid' f, Generics.Deriving.Monoid.Monoid' h) => Generics.Deriving.Monoid.Monoid' (f GHC.Generics.:*: h)
instance Generics.Deriving.Monoid.GMonoid' GHC.Generics.U1
instance forall k (f :: k -> *) i (c :: GHC.Generics.Meta). Generics.Deriving.Monoid.GMonoid' f => Generics.Deriving.Monoid.GMonoid' (GHC.Generics.M1 i c f)
instance forall k (f :: k -> *) (h :: k -> *). (Generics.Deriving.Monoid.GMonoid' f, Generics.Deriving.Monoid.GMonoid' h) => Generics.Deriving.Monoid.GMonoid' (f GHC.Generics.:*: h)

module Generics.Deriving.Semigroup
class GSemigroup a
gsappend :: GSemigroup a => a -> a -> a
gsappend :: (GSemigroup a, Generic a, GSemigroup' (Rep a)) => a -> a -> a
gstimes :: (GSemigroup a, Integral b) => b -> a -> a

-- | Only available with <tt>base-4.9</tt> or later
gsconcat :: GSemigroup a => NonEmpty a -> a
infixr 6 `gsappend`
gsappenddefault :: (Generic a, GSemigroup' (Rep a)) => a -> a -> a
infixr 6 `gsappenddefault`
class GSemigroup' f
gsappend' :: GSemigroup' f => f x -> f x -> f x
infixr 6 `gsappend'`
instance Generics.Deriving.Semigroup.GSemigroup a => Generics.Deriving.Semigroup.GSemigroup' (GHC.Generics.K1 i a)
instance Generics.Deriving.Semigroup.GSemigroup GHC.Types.Ordering
instance Generics.Deriving.Semigroup.GSemigroup ()
instance Generics.Deriving.Semigroup.GSemigroup Data.Semigroup.Internal.Any
instance Generics.Deriving.Semigroup.GSemigroup Data.Semigroup.Internal.All
instance Generics.Deriving.Semigroup.GSemigroup (Data.Monoid.First a)
instance Generics.Deriving.Semigroup.GSemigroup (Data.Monoid.Last a)
instance GHC.Num.Num a => Generics.Deriving.Semigroup.GSemigroup (Data.Semigroup.Internal.Sum a)
instance GHC.Num.Num a => Generics.Deriving.Semigroup.GSemigroup (Data.Semigroup.Internal.Product a)
instance Generics.Deriving.Semigroup.GSemigroup [a]
instance Generics.Deriving.Semigroup.GSemigroup (Data.Semigroup.Internal.Endo a)
instance GHC.Base.Alternative f => Generics.Deriving.Semigroup.GSemigroup (Data.Semigroup.Internal.Alt f a)
instance Generics.Deriving.Semigroup.GSemigroup a => Generics.Deriving.Semigroup.GSemigroup (Data.Semigroup.Internal.Dual a)
instance Generics.Deriving.Semigroup.GSemigroup a => Generics.Deriving.Semigroup.GSemigroup (GHC.Maybe.Maybe a)
instance Generics.Deriving.Semigroup.GSemigroup b => Generics.Deriving.Semigroup.GSemigroup (a -> b)
instance forall k a (b :: k). Generics.Deriving.Semigroup.GSemigroup a => Generics.Deriving.Semigroup.GSemigroup (Data.Functor.Const.Const a b)
instance Generics.Deriving.Semigroup.GSemigroup a => Generics.Deriving.Semigroup.GSemigroup (Data.Ord.Down a)
instance Generics.Deriving.Semigroup.GSemigroup (Data.Either.Either a b)
instance forall k (s :: k). Generics.Deriving.Semigroup.GSemigroup (Data.Proxy.Proxy s)
instance Generics.Deriving.Semigroup.GSemigroup a => Generics.Deriving.Semigroup.GSemigroup (Data.Functor.Identity.Identity a)
instance Generics.Deriving.Semigroup.GSemigroup Data.Void.Void
instance Generics.Deriving.Semigroup.GSemigroup (Data.Semigroup.First a)
instance Generics.Deriving.Semigroup.GSemigroup (Data.Semigroup.Last a)
instance GHC.Classes.Ord a => Generics.Deriving.Semigroup.GSemigroup (Data.Semigroup.Max a)
instance GHC.Classes.Ord a => Generics.Deriving.Semigroup.GSemigroup (Data.Semigroup.Min a)
instance Generics.Deriving.Semigroup.GSemigroup (GHC.Base.NonEmpty a)
instance Generics.Deriving.Semigroup.GSemigroup a => Generics.Deriving.Semigroup.GSemigroup (Data.Semigroup.Option a)
instance Generics.Deriving.Monoid.GMonoid m => Generics.Deriving.Semigroup.GSemigroup (Data.Semigroup.WrappedMonoid m)
instance (Generics.Deriving.Semigroup.GSemigroup a, Generics.Deriving.Semigroup.GSemigroup b) => Generics.Deriving.Semigroup.GSemigroup (a, b)
instance (Generics.Deriving.Semigroup.GSemigroup a, Generics.Deriving.Semigroup.GSemigroup b, Generics.Deriving.Semigroup.GSemigroup c) => Generics.Deriving.Semigroup.GSemigroup (a, b, c)
instance (Generics.Deriving.Semigroup.GSemigroup a, Generics.Deriving.Semigroup.GSemigroup b, Generics.Deriving.Semigroup.GSemigroup c, Generics.Deriving.Semigroup.GSemigroup d) => Generics.Deriving.Semigroup.GSemigroup (a, b, c, d)
instance (Generics.Deriving.Semigroup.GSemigroup a, Generics.Deriving.Semigroup.GSemigroup b, Generics.Deriving.Semigroup.GSemigroup c, Generics.Deriving.Semigroup.GSemigroup d, Generics.Deriving.Semigroup.GSemigroup e) => Generics.Deriving.Semigroup.GSemigroup (a, b, c, d, e)
instance (Generics.Deriving.Semigroup.GSemigroup a, Generics.Deriving.Semigroup.GSemigroup b, Generics.Deriving.Semigroup.GSemigroup c, Generics.Deriving.Semigroup.GSemigroup d, Generics.Deriving.Semigroup.GSemigroup e, Generics.Deriving.Semigroup.GSemigroup f) => Generics.Deriving.Semigroup.GSemigroup (a, b, c, d, e, f)
instance (Generics.Deriving.Semigroup.GSemigroup a, Generics.Deriving.Semigroup.GSemigroup b, Generics.Deriving.Semigroup.GSemigroup c, Generics.Deriving.Semigroup.GSemigroup d, Generics.Deriving.Semigroup.GSemigroup e, Generics.Deriving.Semigroup.GSemigroup f, Generics.Deriving.Semigroup.GSemigroup g) => Generics.Deriving.Semigroup.GSemigroup (a, b, c, d, e, f, g)
instance (Generics.Deriving.Semigroup.GSemigroup a, Generics.Deriving.Semigroup.GSemigroup b, Generics.Deriving.Semigroup.GSemigroup c, Generics.Deriving.Semigroup.GSemigroup d, Generics.Deriving.Semigroup.GSemigroup e, Generics.Deriving.Semigroup.GSemigroup f, Generics.Deriving.Semigroup.GSemigroup g, Generics.Deriving.Semigroup.GSemigroup h) => Generics.Deriving.Semigroup.GSemigroup (a, b, c, d, e, f, g, h)
instance Generics.Deriving.Semigroup.GSemigroup' GHC.Generics.U1
instance forall k (f :: k -> *) i (c :: GHC.Generics.Meta). Generics.Deriving.Semigroup.GSemigroup' f => Generics.Deriving.Semigroup.GSemigroup' (GHC.Generics.M1 i c f)
instance forall k (f :: k -> *) (g :: k -> *). (Generics.Deriving.Semigroup.GSemigroup' f, Generics.Deriving.Semigroup.GSemigroup' g) => Generics.Deriving.Semigroup.GSemigroup' (f GHC.Generics.:*: g)

module Generics.Deriving.Show
class GShow a
gshowsPrec :: GShow a => Int -> a -> ShowS
gshowsPrec :: (GShow a, Generic a, GShow' (Rep a)) => Int -> a -> ShowS
gshows :: GShow a => a -> ShowS
gshow :: GShow a => a -> String
gshowList :: GShow a => [a] -> ShowS
gshowsPrecdefault :: (Generic a, GShow' (Rep a)) => Int -> a -> ShowS
class GShow' f
gshowsPrec' :: GShow' f => Type -> Int -> f a -> ShowS
isNullary :: GShow' f => f a -> Bool
instance Generics.Deriving.Show.GShow c => Generics.Deriving.Show.GShow' (GHC.Generics.K1 i c)
instance Generics.Deriving.Show.GShow ()
instance (Generics.Deriving.Show.GShow a, Generics.Deriving.Show.GShow b) => Generics.Deriving.Show.GShow (a, b)
instance (Generics.Deriving.Show.GShow a, Generics.Deriving.Show.GShow b, Generics.Deriving.Show.GShow c) => Generics.Deriving.Show.GShow (a, b, c)
instance (Generics.Deriving.Show.GShow a, Generics.Deriving.Show.GShow b, Generics.Deriving.Show.GShow c, Generics.Deriving.Show.GShow d) => Generics.Deriving.Show.GShow (a, b, c, d)
instance (Generics.Deriving.Show.GShow a, Generics.Deriving.Show.GShow b, Generics.Deriving.Show.GShow c, Generics.Deriving.Show.GShow d, Generics.Deriving.Show.GShow e) => Generics.Deriving.Show.GShow (a, b, c, d, e)
instance (Generics.Deriving.Show.GShow a, Generics.Deriving.Show.GShow b, Generics.Deriving.Show.GShow c, Generics.Deriving.Show.GShow d, Generics.Deriving.Show.GShow e, Generics.Deriving.Show.GShow f) => Generics.Deriving.Show.GShow (a, b, c, d, e, f)
instance (Generics.Deriving.Show.GShow a, Generics.Deriving.Show.GShow b, Generics.Deriving.Show.GShow c, Generics.Deriving.Show.GShow d, Generics.Deriving.Show.GShow e, Generics.Deriving.Show.GShow f, Generics.Deriving.Show.GShow g) => Generics.Deriving.Show.GShow (a, b, c, d, e, f, g)
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow [a]
instance (Generics.Deriving.Show.GShow (f p), Generics.Deriving.Show.GShow (g p)) => Generics.Deriving.Show.GShow ((GHC.Generics.:+:) f g p)
instance (Generics.Deriving.Show.GShow (f p), Generics.Deriving.Show.GShow (g p)) => Generics.Deriving.Show.GShow ((GHC.Generics.:*:) f g p)
instance Generics.Deriving.Show.GShow (f (g p)) => Generics.Deriving.Show.GShow ((GHC.Generics.:.:) f g p)
instance Generics.Deriving.Show.GShow Data.Semigroup.Internal.All
instance Generics.Deriving.Show.GShow (f a) => Generics.Deriving.Show.GShow (Data.Semigroup.Internal.Alt f a)
instance Generics.Deriving.Show.GShow Data.Semigroup.Internal.Any
instance (Generics.Deriving.Show.GShow a, Generics.Deriving.Show.GShow b) => Generics.Deriving.Show.GShow (Data.Semigroup.Arg a b)
instance Generics.Deriving.Show.GShow GHC.Generics.Associativity
instance Generics.Deriving.Show.GShow GHC.Types.Bool
instance Generics.Deriving.Show.GShow GHC.IO.Handle.Types.BufferMode
instance Generics.Deriving.Show.GShow Foreign.C.Types.CChar
instance Generics.Deriving.Show.GShow Foreign.C.Types.CClock
instance Generics.Deriving.Show.GShow Foreign.C.Types.CDouble
instance Generics.Deriving.Show.GShow Foreign.C.Types.CFloat
instance Generics.Deriving.Show.GShow GHC.Types.Char
instance Generics.Deriving.Show.GShow Foreign.C.Types.CInt
instance Generics.Deriving.Show.GShow Foreign.C.Types.CIntMax
instance Generics.Deriving.Show.GShow Foreign.C.Types.CIntPtr
instance Generics.Deriving.Show.GShow Foreign.C.Types.CLLong
instance Generics.Deriving.Show.GShow Foreign.C.Types.CLong
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Complex.Complex a)
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Functor.Const.Const a b)
instance Generics.Deriving.Show.GShow Foreign.C.Types.CPtrdiff
instance Generics.Deriving.Show.GShow Foreign.C.Types.CSChar
instance Generics.Deriving.Show.GShow Foreign.C.Types.CSUSeconds
instance Generics.Deriving.Show.GShow Foreign.C.Types.CShort
instance Generics.Deriving.Show.GShow Foreign.C.Types.CSigAtomic
instance Generics.Deriving.Show.GShow Foreign.C.Types.CSize
instance Generics.Deriving.Show.GShow Foreign.C.Types.CTime
instance Generics.Deriving.Show.GShow Foreign.C.Types.CUChar
instance Generics.Deriving.Show.GShow Foreign.C.Types.CUInt
instance Generics.Deriving.Show.GShow Foreign.C.Types.CUIntMax
instance Generics.Deriving.Show.GShow Foreign.C.Types.CUIntPtr
instance Generics.Deriving.Show.GShow Foreign.C.Types.CULLong
instance Generics.Deriving.Show.GShow Foreign.C.Types.CULong
instance Generics.Deriving.Show.GShow Foreign.C.Types.CUSeconds
instance Generics.Deriving.Show.GShow Foreign.C.Types.CUShort
instance Generics.Deriving.Show.GShow Foreign.C.Types.CWchar
instance Generics.Deriving.Show.GShow GHC.Types.Double
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Ord.Down a)
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Semigroup.Internal.Dual a)
instance (Generics.Deriving.Show.GShow a, Generics.Deriving.Show.GShow b) => Generics.Deriving.Show.GShow (Data.Either.Either a b)
instance Generics.Deriving.Show.GShow GHC.IO.Exception.ExitCode
instance Generics.Deriving.Show.GShow System.Posix.Types.Fd
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Monoid.First a)
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Semigroup.First a)
instance Generics.Deriving.Show.GShow GHC.Generics.Fixity
instance Generics.Deriving.Show.GShow GHC.Types.Float
instance Generics.Deriving.Show.GShow (GHC.ForeignPtr.ForeignPtr a)
instance Generics.Deriving.Show.GShow (GHC.Ptr.FunPtr a)
instance Generics.Deriving.Show.GShow GHC.Unicode.GeneralCategory
instance Generics.Deriving.Show.GShow GHC.IO.Handle.Types.Handle
instance Generics.Deriving.Show.GShow GHC.IO.Handle.HandlePosn
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Functor.Identity.Identity a)
instance Generics.Deriving.Show.GShow GHC.Types.Int
instance Generics.Deriving.Show.GShow GHC.Int.Int8
instance Generics.Deriving.Show.GShow GHC.Int.Int16
instance Generics.Deriving.Show.GShow GHC.Int.Int32
instance Generics.Deriving.Show.GShow GHC.Int.Int64
instance Generics.Deriving.Show.GShow GHC.Integer.Type.Integer
instance Generics.Deriving.Show.GShow Foreign.Ptr.IntPtr
instance Generics.Deriving.Show.GShow GHC.IO.Exception.IOError
instance Generics.Deriving.Show.GShow GHC.IO.Exception.IOErrorType
instance Generics.Deriving.Show.GShow GHC.IO.IOMode.IOMode
instance Generics.Deriving.Show.GShow c => Generics.Deriving.Show.GShow (GHC.Generics.K1 i c p)
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Monoid.Last a)
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Semigroup.Last a)
instance Generics.Deriving.Show.GShow (f p) => Generics.Deriving.Show.GShow (GHC.Generics.M1 i c f p)
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Semigroup.Max a)
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (GHC.Maybe.Maybe a)
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Semigroup.Min a)
instance Generics.Deriving.Show.GShow GHC.Natural.Natural
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (GHC.Base.NonEmpty a)
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Semigroup.Option a)
instance Generics.Deriving.Show.GShow GHC.Types.Ordering
instance Generics.Deriving.Show.GShow p => Generics.Deriving.Show.GShow (GHC.Generics.Par1 p)
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Semigroup.Internal.Product a)
instance Generics.Deriving.Show.GShow (Data.Proxy.Proxy s)
instance Generics.Deriving.Show.GShow (GHC.Ptr.Ptr a)
instance Generics.Deriving.Show.GShow (f p) => Generics.Deriving.Show.GShow (GHC.Generics.Rec1 f p)
instance Generics.Deriving.Show.GShow GHC.IO.Device.SeekMode
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Data.Semigroup.Internal.Sum a)
instance Generics.Deriving.Show.GShow (GHC.Generics.U1 p)
instance Generics.Deriving.Show.GShow (GHC.Generics.UChar p)
instance Generics.Deriving.Show.GShow (GHC.Generics.UDouble p)
instance Generics.Deriving.Show.GShow (GHC.Generics.UFloat p)
instance Generics.Deriving.Show.GShow (GHC.Generics.UInt p)
instance Generics.Deriving.Show.GShow (GHC.Generics.UWord p)
instance Generics.Deriving.Show.GShow Data.Version.Version
instance Generics.Deriving.Show.GShow Data.Void.Void
instance Generics.Deriving.Show.GShow GHC.Types.Word
instance Generics.Deriving.Show.GShow GHC.Word.Word8
instance Generics.Deriving.Show.GShow GHC.Word.Word16
instance Generics.Deriving.Show.GShow GHC.Word.Word32
instance Generics.Deriving.Show.GShow GHC.Word.Word64
instance Generics.Deriving.Show.GShow Foreign.Ptr.WordPtr
instance Generics.Deriving.Show.GShow m => Generics.Deriving.Show.GShow (Data.Semigroup.WrappedMonoid m)
instance Generics.Deriving.Show.GShow a => Generics.Deriving.Show.GShow (Control.Applicative.ZipList a)
instance Generics.Deriving.Show.GShow Foreign.C.Types.CBool
instance Generics.Deriving.Show.GShow' GHC.Generics.V1
instance Generics.Deriving.Show.GShow' GHC.Generics.U1
instance (Generics.Deriving.Show.GShow' a, GHC.Generics.Constructor c) => Generics.Deriving.Show.GShow' (GHC.Generics.M1 GHC.Generics.C c a)
instance (GHC.Generics.Selector s, Generics.Deriving.Show.GShow' a) => Generics.Deriving.Show.GShow' (GHC.Generics.M1 GHC.Generics.S s a)
instance Generics.Deriving.Show.GShow' a => Generics.Deriving.Show.GShow' (GHC.Generics.M1 GHC.Generics.D d a)
instance (Generics.Deriving.Show.GShow' a, Generics.Deriving.Show.GShow' b) => Generics.Deriving.Show.GShow' (a GHC.Generics.:+: b)
instance (Generics.Deriving.Show.GShow' a, Generics.Deriving.Show.GShow' b) => Generics.Deriving.Show.GShow' (a GHC.Generics.:*: b)
instance Generics.Deriving.Show.GShow' GHC.Generics.UChar
instance Generics.Deriving.Show.GShow' GHC.Generics.UDouble
instance Generics.Deriving.Show.GShow' GHC.Generics.UFloat
instance Generics.Deriving.Show.GShow' GHC.Generics.UInt
instance Generics.Deriving.Show.GShow' GHC.Generics.UWord


-- | This module contains Template Haskell code that can be used to
--   automatically generate the boilerplate code for the generic deriving
--   library.
--   
--   To use these functions, pass the name of a data type as an argument:
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell #-}
--   
--   data Example a = Example Int Char a
--   $(<a>deriveAll0</a>     ''Example) -- Derives Generic instance
--   $(<a>deriveAll1</a>     ''Example) -- Derives Generic1 instance
--   $(<a>deriveAll0And1</a> ''Example) -- Derives Generic and Generic1 instances
--   </pre>
--   
--   On GHC 7.4 or later, this code can also be used with data families. To
--   derive for a data family instance, pass the name of one of the
--   instance's constructors:
--   
--   <pre>
--   {-# LANGUAGE FlexibleInstances, TemplateHaskell, TypeFamilies #-}
--   
--   data family Family a b
--   newtype instance Family Char x = FamilyChar Char
--   data    instance Family Bool x = FamilyTrue | FamilyFalse
--   
--   $(<a>deriveAll0</a> 'FamilyChar) -- instance Generic (Family Char b) where ...
--   $(<a>deriveAll1</a> 'FamilyTrue) -- instance Generic1 (Family Bool) where ...
--   -- Alternatively, one could type $(deriveAll1 'FamilyFalse)
--   </pre>
module Generics.Deriving.TH

-- | Given the type and the name (as string) for the type to derive,
--   generate the <tt>Data</tt> instance, the <tt>Constructor</tt>
--   instances, and the <tt>Selector</tt> instances.
--   
--   On GHC 7.11 and up, this functionality is no longer used in GHC
--   generics, so this function generates no declarations.
deriveMeta :: Name -> Q [Dec]

-- | Given a datatype name, derive a datatype and instance of class
--   <a>Datatype</a>.
--   
--   On GHC 7.11 and up, this functionality is no longer used in GHC
--   generics, so this function generates no declarations.
deriveData :: Name -> Q [Dec]

-- | Given a datatype name, derive datatypes and instances of class
--   <tt>Constructor</tt>.
--   
--   On GHC 7.11 and up, this functionality is no longer used in GHC
--   generics, so this function generates no declarations.
deriveConstructors :: Name -> Q [Dec]

-- | Given a datatype name, derive datatypes and instances of class
--   <tt>Selector</tt>.
--   
--   On GHC 7.11 and up, this functionality is no longer used in GHC
--   generics, so this function generates no declarations.
deriveSelectors :: Name -> Q [Dec]

-- | A backwards-compatible synonym for <a>deriveAll0</a>.
deriveAll :: Name -> Q [Dec]

-- | Given the type and the name (as string) for the type to derive,
--   generate the <tt>Data</tt> instance, the <tt>Constructor</tt>
--   instances, the <tt>Selector</tt> instances, and the
--   <tt>Representable0</tt> instance.
deriveAll0 :: Name -> Q [Dec]

-- | Given the type and the name (as string) for the type to derive,
--   generate the <tt>Data</tt> instance, the <tt>Constructor</tt>
--   instances, the <tt>Selector</tt> instances, and the
--   <tt>Representable1</tt> instance.
deriveAll1 :: Name -> Q [Dec]

-- | Given the type and the name (as string) for the type to derive,
--   generate the <tt>Data</tt> instance, the <tt>Constructor</tt>
--   instances, the <tt>Selector</tt> instances, the
--   <tt>Representable0</tt> instance, and the <tt>Representable1</tt>
--   instance.
deriveAll0And1 :: Name -> Q [Dec]

-- | Given the type and the name (as string) for the Representable0 type
--   synonym to derive, generate the <tt>Representable0</tt> instance.
deriveRepresentable0 :: Name -> Q [Dec]

-- | Given the type and the name (as string) for the Representable1 type
--   synonym to derive, generate the <tt>Representable1</tt> instance.
deriveRepresentable1 :: Name -> Q [Dec]

-- | Derive only the <tt>Rep0</tt> type synonym. Not needed if
--   <a>deriveRepresentable0</a> is used.
deriveRep0 :: Name -> Q [Dec]

-- | Derive only the <tt>Rep1</tt> type synonym. Not needed if
--   <a>deriveRepresentable1</a> is used.
deriveRep1 :: Name -> Q [Dec]

-- | Generates the full <tt>Rep</tt> type inline. Since this type can be
--   quite large, it is recommended you only use this to define
--   <tt>Rep</tt>, e.g.,
--   
--   <pre>
--   type Rep (Foo (a :: k) b) = $(<a>makeRep0Inline</a> ''Foo [t| Foo (a :: k) b |])
--   </pre>
--   
--   You can then simply refer to <tt>Rep (Foo a b)</tt> elsewhere.
--   
--   Note that the type passed as an argument to <a>makeRep0Inline</a> must
--   match the type argument of <tt>Rep</tt> exactly, even up to including
--   the explicit kind signature on <tt>a</tt>. This is due to a limitation
--   of Template Haskell—without the kind signature, <a>makeRep0Inline</a>
--   has no way of figuring out the kind of <tt>a</tt>, and the generated
--   type might be completely wrong as a result!
makeRep0Inline :: Name -> Q Type -> Q Type

-- | Generates the <tt>Rep</tt> type synonym constructor (as opposed to
--   <a>deriveRep0</a>, which generates the type synonym declaration).
--   After splicing it into Haskell source, it expects types as arguments.
--   For example:
--   
--   <pre>
--   type Rep (Foo a b) = $(<a>makeRep0</a> ''Foo) a b
--   </pre>
--   
--   The use of <a>makeRep0</a> is generally discouraged, as it can
--   sometimes be difficult to predict the order in which you are expected
--   to pass type variables. As a result, <a>makeRep0Inline</a> is
--   recommended instead. However, <a>makeRep0Inline</a> is not usable on
--   GHC 7.0, 7.2, or 7.4 due to a GHC bug, so <a>makeRep0</a> still exists
--   for GHC 7.0, 7.2, and 7.4 users.
makeRep0 :: Name -> Q Type

-- | Generates the <tt>Rep</tt> type synonym constructor (as opposed to
--   <a>deriveRep0</a>, which generates the type synonym declaration)
--   applied to its type arguments. Unlike <a>makeRep0</a>, this also takes
--   a quoted <a>Type</a> as an argument, e.g.,
--   
--   <pre>
--   type Rep (Foo (a :: k) b) = $(<a>makeRep0FromType</a> ''Foo [t| Foo (a :: k) b |])
--   </pre>
--   
--   Note that the type passed as an argument to <a>makeRep0FromType</a>
--   must match the type argument of <tt>Rep</tt> exactly, even up to
--   including the explicit kind signature on <tt>a</tt>. This is due to a
--   limitation of Template Haskell—without the kind signature,
--   <a>makeRep0FromType</a> has no way of figuring out the kind of
--   <tt>a</tt>, and the generated type might be completely wrong as a
--   result!
--   
--   The use of <a>makeRep0FromType</a> is generally discouraged, since
--   <a>makeRep0Inline</a> does exactly the same thing but without having
--   to go through an intermediate type synonym, and as a result,
--   <a>makeRep0Inline</a> tends to be less buggy.
makeRep0FromType :: Name -> Q Type -> Q Type

-- | A backwards-compatible synonym for <a>makeFrom0</a>.
makeFrom :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>from</tt>.
makeFrom0 :: Name -> Q Exp

-- | A backwards-compatible synonym for <a>makeTo0</a>.
makeTo :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>to</tt>.
makeTo0 :: Name -> Q Exp

-- | Generates the full <tt>Rep1</tt> type inline. Since this type can be
--   quite large, it is recommended you only use this to define
--   <tt>Rep1</tt>, e.g.,
--   
--   <pre>
--   type Rep1 (Foo (a :: k)) = $(<a>makeRep0Inline</a> ''Foo [t| Foo (a :: k) |])
--   </pre>
--   
--   You can then simply refer to <tt>Rep1 (Foo a)</tt> elsewhere.
--   
--   Note that the type passed as an argument to <a>makeRep1Inline</a> must
--   match the type argument of <tt>Rep1</tt> exactly, even up to including
--   the explicit kind signature on <tt>a</tt>. This is due to a limitation
--   of Template Haskell—without the kind signature, <a>makeRep1Inline</a>
--   has no way of figuring out the kind of <tt>a</tt>, and the generated
--   type might be completely wrong as a result!
makeRep1Inline :: Name -> Q Type -> Q Type

-- | Generates the <tt>Rep1</tt> type synonym constructor (as opposed to
--   <a>deriveRep1</a>, which generates the type synonym declaration).
--   After splicing it into Haskell source, it expects types as arguments.
--   For example:
--   
--   <pre>
--   type Rep1 (Foo a) = $(<a>makeRep1</a> ''Foo) a
--   </pre>
--   
--   The use of <a>makeRep1</a> is generally discouraged, as it can
--   sometimes be difficult to predict the order in which you are expected
--   to pass type variables. As a result, <a>makeRep1Inline</a> is
--   recommended instead. However, <a>makeRep1Inline</a> is not usable on
--   GHC 7.0, 7.2, or 7.4 due to a GHC bug, so <a>makeRep1</a> still exists
--   for GHC 7.0, 7.2, and 7.4 users.
makeRep1 :: Name -> Q Type

-- | Generates the <tt>Rep1</tt> type synonym constructor (as opposed to
--   <a>deriveRep1</a>, which generates the type synonym declaration)
--   applied to its type arguments. Unlike <a>makeRep1</a>, this also takes
--   a quoted <a>Type</a> as an argument, e.g.,
--   
--   <pre>
--   type Rep1 (Foo (a :: k)) = $(<a>makeRep1FromType</a> ''Foo [t| Foo (a :: k) |])
--   </pre>
--   
--   Note that the type passed as an argument to <a>makeRep1FromType</a>
--   must match the type argument of <tt>Rep</tt> exactly, even up to
--   including the explicit kind signature on <tt>a</tt>. This is due to a
--   limitation of Template Haskell—without the kind signature,
--   <a>makeRep1FromType</a> has no way of figuring out the kind of
--   <tt>a</tt>, and the generated type might be completely wrong as a
--   result!
--   
--   The use of <a>makeRep1FromType</a> is generally discouraged, since
--   <a>makeRep1Inline</a> does exactly the same thing but without having
--   to go through an intermediate type synonym, and as a result,
--   <a>makeRep1Inline</a> tends to be less buggy.
makeRep1FromType :: Name -> Q Type -> Q Type

-- | Generates a lambda expression which behaves like <tt>from1</tt>.
makeFrom1 :: Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>to1</tt>.
makeTo1 :: Name -> Q Exp

-- | Additional options for configuring derived 'Generic'/'Generic1'
--   instances using Template Haskell.
data Options
Options :: RepOptions -> KindSigOptions -> EmptyCaseOptions -> Options
[repOptions] :: Options -> RepOptions
[kindSigOptions] :: Options -> KindSigOptions
[emptyCaseOptions] :: Options -> EmptyCaseOptions

-- | Sensible default <a>Options</a>.
defaultOptions :: Options

-- | Configures whether 'Rep'/'Rep1' type instances should be defined
--   inline in a derived 'Generic'/'Generic1' instance (<a>InlineRep</a>)
--   or defined in terms of a type synonym (<a>TypeSynonymRep</a>).
data RepOptions
InlineRep :: RepOptions
TypeSynonymRep :: RepOptions

-- | <a>InlineRep</a>, a sensible default <a>RepOptions</a>.
defaultRepOptions :: RepOptions

-- | <a>True</a> if explicit kind signatures should be used in derived
--   'Generic'/'Generic1' instances, <a>False</a> otherwise.
type KindSigOptions = Bool

-- | <a>True</a>, a sensible default <a>KindSigOptions</a>.
defaultKindSigOptions :: KindSigOptions

-- | <a>True</a> if generated code for empty data types should use the
--   <tt>EmptyCase</tt> extension, <a>False</a> otherwise. This has no
--   effect on GHCs before 7.8, since <tt>EmptyCase</tt> is only available
--   in 7.8 or later.
type EmptyCaseOptions = Bool

-- | Sensible default <a>EmptyCaseOptions</a>.
defaultEmptyCaseOptions :: EmptyCaseOptions

-- | Like <a>deriveAll0</a>, but takes an <a>Options</a> argument.
deriveAll0Options :: Options -> Name -> Q [Dec]

-- | Like <a>deriveAll1</a>, but takes an <a>Options</a> argument.
deriveAll1Options :: Options -> Name -> Q [Dec]

-- | Like <a>deriveAll0And1</a>, but takes an <a>Options</a> argument.
deriveAll0And1Options :: Options -> Name -> Q [Dec]

-- | Like <a>deriveRepresentable0</a>, but takes an <a>Options</a>
--   argument.
deriveRepresentable0Options :: Options -> Name -> Q [Dec]

-- | Like <a>deriveRepresentable1</a>, but takes an <a>Options</a>
--   argument.
deriveRepresentable1Options :: Options -> Name -> Q [Dec]

-- | Like <a>deriveRep0</a>, but takes an <a>KindSigOptions</a> argument.
deriveRep0Options :: KindSigOptions -> Name -> Q [Dec]

-- | Like <a>deriveRep1</a>, but takes an <a>KindSigOptions</a> argument.
deriveRep1Options :: KindSigOptions -> Name -> Q [Dec]

-- | Like <a>makeFrom0Options</a>, but takes an <a>EmptyCaseOptions</a>
--   argument.
makeFrom0Options :: EmptyCaseOptions -> Name -> Q Exp

-- | Like <a>makeTo0Options</a>, but takes an <a>EmptyCaseOptions</a>
--   argument.
makeTo0Options :: EmptyCaseOptions -> Name -> Q Exp

-- | Like <a>makeFrom1Options</a>, but takes an <a>EmptyCaseOptions</a>
--   argument.
makeFrom1Options :: EmptyCaseOptions -> Name -> Q Exp

-- | Like <a>makeTo1Options</a>, but takes an <a>EmptyCaseOptions</a>
--   argument.
makeTo1Options :: EmptyCaseOptions -> Name -> Q Exp
instance GHC.Show.Show Generics.Deriving.TH.Options
instance GHC.Read.Read Generics.Deriving.TH.Options
instance GHC.Classes.Ord Generics.Deriving.TH.Options
instance GHC.Classes.Eq Generics.Deriving.TH.Options
instance GHC.Show.Show Generics.Deriving.TH.RepOptions
instance GHC.Read.Read Generics.Deriving.TH.RepOptions
instance GHC.Classes.Ord Generics.Deriving.TH.RepOptions
instance GHC.Classes.Eq Generics.Deriving.TH.RepOptions

module Generics.Deriving.Traversable
class (GFunctor t, GFoldable t) => GTraversable t
gtraverse :: (GTraversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
gtraverse :: (GTraversable t, Generic1 t, GTraversable' (Rep1 t), Applicative f) => (a -> f b) -> t a -> f (t b)
gsequenceA :: (GTraversable t, Applicative f) => t (f a) -> f (t a)
gmapM :: (GTraversable t, Monad m) => (a -> m b) -> t a -> m (t b)
gsequence :: (GTraversable t, Monad m) => t (m a) -> m (t a)
gtraversedefault :: (Generic1 t, GTraversable' (Rep1 t), Applicative f) => (a -> f b) -> t a -> f (t b)
class GTraversable' t
gtraverse' :: (GTraversable' t, Applicative f) => (a -> f b) -> t a -> f (t b)
instance Generics.Deriving.Traversable.GTraversable f => Generics.Deriving.Traversable.GTraversable' (GHC.Generics.Rec1 f)
instance (Generics.Deriving.Traversable.GTraversable f, Generics.Deriving.Traversable.GTraversable' g) => Generics.Deriving.Traversable.GTraversable' (f GHC.Generics.:.: g)
instance Generics.Deriving.Traversable.GTraversable ((,) a)
instance Generics.Deriving.Traversable.GTraversable []
instance Generics.Deriving.Traversable.GTraversable (Data.Semigroup.Arg a)
instance Generics.Deriving.Traversable.GTraversable Data.Complex.Complex
instance Generics.Deriving.Traversable.GTraversable (Data.Functor.Const.Const m)
instance Generics.Deriving.Traversable.GTraversable Data.Ord.Down
instance Generics.Deriving.Traversable.GTraversable Data.Semigroup.Internal.Dual
instance Generics.Deriving.Traversable.GTraversable (Data.Either.Either a)
instance Generics.Deriving.Traversable.GTraversable Data.Monoid.First
instance Generics.Deriving.Traversable.GTraversable Data.Semigroup.First
instance Generics.Deriving.Traversable.GTraversable Data.Functor.Identity.Identity
instance Generics.Deriving.Traversable.GTraversable Data.Monoid.Last
instance Generics.Deriving.Traversable.GTraversable Data.Semigroup.Last
instance Generics.Deriving.Traversable.GTraversable Data.Semigroup.Max
instance Generics.Deriving.Traversable.GTraversable GHC.Maybe.Maybe
instance Generics.Deriving.Traversable.GTraversable Data.Semigroup.Min
instance Generics.Deriving.Traversable.GTraversable GHC.Base.NonEmpty
instance Generics.Deriving.Traversable.GTraversable Data.Semigroup.Option
instance Generics.Deriving.Traversable.GTraversable Data.Semigroup.Internal.Product
instance (Generics.Deriving.Traversable.GTraversable f, Generics.Deriving.Traversable.GTraversable g) => Generics.Deriving.Traversable.GTraversable (Data.Functor.Product.Product f g)
instance Generics.Deriving.Traversable.GTraversable Data.Proxy.Proxy
instance Generics.Deriving.Traversable.GTraversable Data.Semigroup.Internal.Sum
instance (Generics.Deriving.Traversable.GTraversable f, Generics.Deriving.Traversable.GTraversable g) => Generics.Deriving.Traversable.GTraversable (Data.Functor.Sum.Sum f g)
instance Generics.Deriving.Traversable.GTraversable Data.Semigroup.WrappedMonoid
instance Generics.Deriving.Traversable.GTraversable Control.Applicative.ZipList
instance Generics.Deriving.Traversable.GTraversable' GHC.Generics.V1
instance Generics.Deriving.Traversable.GTraversable' GHC.Generics.U1
instance Generics.Deriving.Traversable.GTraversable' GHC.Generics.Par1
instance Generics.Deriving.Traversable.GTraversable' (GHC.Generics.K1 i c)
instance Generics.Deriving.Traversable.GTraversable' f => Generics.Deriving.Traversable.GTraversable' (GHC.Generics.M1 i c f)
instance (Generics.Deriving.Traversable.GTraversable' f, Generics.Deriving.Traversable.GTraversable' g) => Generics.Deriving.Traversable.GTraversable' (f GHC.Generics.:+: g)
instance (Generics.Deriving.Traversable.GTraversable' f, Generics.Deriving.Traversable.GTraversable' g) => Generics.Deriving.Traversable.GTraversable' (f GHC.Generics.:*: g)
instance Generics.Deriving.Traversable.GTraversable' GHC.Generics.UAddr
instance Generics.Deriving.Traversable.GTraversable' GHC.Generics.UChar
instance Generics.Deriving.Traversable.GTraversable' GHC.Generics.UDouble
instance Generics.Deriving.Traversable.GTraversable' GHC.Generics.UFloat
instance Generics.Deriving.Traversable.GTraversable' GHC.Generics.UInt
instance Generics.Deriving.Traversable.GTraversable' GHC.Generics.UWord


-- | Summary: Functions inspired by the Uniplate generic programming
--   library, mostly implemented by Sean Leather.
module Generics.Deriving.Uniplate
class Uniplate a
children :: Uniplate a => a -> [a]
children :: (Uniplate a, Generic a, Uniplate' (Rep a) a) => a -> [a]
context :: Uniplate a => a -> [a] -> a
context :: (Uniplate a, Generic a, Context' (Rep a) a) => a -> [a] -> a
descend :: Uniplate a => (a -> a) -> a -> a
descend :: (Uniplate a, Generic a, Uniplate' (Rep a) a) => (a -> a) -> a -> a
descendM :: (Uniplate a, Monad m) => (a -> m a) -> a -> m a
descendM :: (Uniplate a, Generic a, Uniplate' (Rep a) a, Monad m) => (a -> m a) -> a -> m a
transform :: Uniplate a => (a -> a) -> a -> a
transform :: (Uniplate a, Generic a, Uniplate' (Rep a) a) => (a -> a) -> a -> a
transformM :: (Uniplate a, Monad m) => (a -> m a) -> a -> m a
transformM :: (Uniplate a, Generic a, Uniplate' (Rep a) a, Monad m) => (a -> m a) -> a -> m a
uniplate :: Uniplate a => a -> ([a], [a] -> a)
universe :: Uniplate a => a -> [a]
rewrite :: Uniplate a => (a -> Maybe a) -> a -> a
rewriteM :: (Monad m, Uniplate a) => (a -> m (Maybe a)) -> a -> m a
contexts :: Uniplate a => a -> [(a, a -> a)]
holes :: Uniplate a => a -> [(a, a -> a)]
para :: Uniplate a => (a -> [r] -> r) -> a -> r
childrendefault :: (Generic a, Uniplate' (Rep a) a) => a -> [a]
contextdefault :: (Generic a, Context' (Rep a) a) => a -> [a] -> a
descenddefault :: (Generic a, Uniplate' (Rep a) a) => (a -> a) -> a -> a
descendMdefault :: (Generic a, Uniplate' (Rep a) a, Monad m) => (a -> m a) -> a -> m a
transformdefault :: (Generic a, Uniplate' (Rep a) a) => (a -> a) -> a -> a
transformMdefault :: (Generic a, Uniplate' (Rep a) a, Monad m) => (a -> m a) -> a -> m a
class Uniplate' f b
children' :: Uniplate' f b => f a -> [b]
descend' :: Uniplate' f b => (b -> b) -> f a -> f a
descendM' :: (Uniplate' f b, Monad m) => (b -> m b) -> f a -> m (f a)
transform' :: Uniplate' f b => (b -> b) -> f a -> f a
transformM' :: (Uniplate' f b, Monad m) => (b -> m b) -> f a -> m (f a)
class Context' f b
context' :: Context' f b => f a -> [b] -> f a
instance Generics.Deriving.Uniplate.Uniplate a => Generics.Deriving.Uniplate.Uniplate' (GHC.Generics.K1 i a) a
instance Generics.Deriving.Uniplate.Uniplate GHC.Types.Bool
instance Generics.Deriving.Uniplate.Uniplate GHC.Types.Char
instance Generics.Deriving.Uniplate.Uniplate GHC.Types.Double
instance Generics.Deriving.Uniplate.Uniplate GHC.Types.Float
instance Generics.Deriving.Uniplate.Uniplate GHC.Types.Int
instance Generics.Deriving.Uniplate.Uniplate ()
instance Generics.Deriving.Uniplate.Uniplate (b, c)
instance Generics.Deriving.Uniplate.Uniplate (b, c, d)
instance Generics.Deriving.Uniplate.Uniplate (b, c, d, e)
instance Generics.Deriving.Uniplate.Uniplate (b, c, d, e, f)
instance Generics.Deriving.Uniplate.Uniplate (b, c, d, e, f, g)
instance Generics.Deriving.Uniplate.Uniplate (b, c, d, e, f, g, h)
instance Generics.Deriving.Uniplate.Uniplate (GHC.Maybe.Maybe a)
instance Generics.Deriving.Uniplate.Uniplate (Data.Either.Either a b)
instance Generics.Deriving.Uniplate.Uniplate [a]
instance Generics.Deriving.Uniplate.Context' GHC.Generics.U1 b
instance Generics.Deriving.Uniplate.Context' (GHC.Generics.K1 i a) a
instance Generics.Deriving.Uniplate.Context' (GHC.Generics.K1 i a) b
instance forall k (f :: k -> *) b i (c :: GHC.Generics.Meta). Generics.Deriving.Uniplate.Context' f b => Generics.Deriving.Uniplate.Context' (GHC.Generics.M1 i c f) b
instance forall k (f :: k -> *) b (g :: k -> *). (Generics.Deriving.Uniplate.Context' f b, Generics.Deriving.Uniplate.Context' g b) => Generics.Deriving.Uniplate.Context' (f GHC.Generics.:+: g) b
instance forall k (g :: k -> *) a i (c :: GHC.Generics.Meta) j. Generics.Deriving.Uniplate.Context' g a => Generics.Deriving.Uniplate.Context' (GHC.Generics.M1 i c (GHC.Generics.K1 j a) GHC.Generics.:*: g) a
instance forall k (g :: k -> *) b (f :: k -> *). Generics.Deriving.Uniplate.Context' g b => Generics.Deriving.Uniplate.Context' (f GHC.Generics.:*: g) b
instance Generics.Deriving.Uniplate.Uniplate' GHC.Generics.U1 a
instance Generics.Deriving.Uniplate.Uniplate' (GHC.Generics.K1 i a) b
instance forall k (f :: k -> *) b i (c :: GHC.Generics.Meta). Generics.Deriving.Uniplate.Uniplate' f b => Generics.Deriving.Uniplate.Uniplate' (GHC.Generics.M1 i c f) b
instance forall k (f :: k -> *) b (g :: k -> *). (Generics.Deriving.Uniplate.Uniplate' f b, Generics.Deriving.Uniplate.Uniplate' g b) => Generics.Deriving.Uniplate.Uniplate' (f GHC.Generics.:+: g) b
instance forall k (f :: k -> *) b (g :: k -> *). (Generics.Deriving.Uniplate.Uniplate' f b, Generics.Deriving.Uniplate.Uniplate' g b) => Generics.Deriving.Uniplate.Uniplate' (f GHC.Generics.:*: g) b


-- | GHC 8.6 introduced the <tt><a>DerivingVia</a></tt> language extension,
--   which means a typeclass instance can be derived from an existing
--   instance for an isomorphic type. Any newtype is isomorphic to the
--   underlying type. By implementing a typeclass once for the newtype, it
--   is possible to derive any typeclass for any type with a <a>Generic</a>
--   instance.
--   
--   For a number of classes, there are sensible default instantiations. In
--   older GHCs, these can be supplied in the class definition, using the
--   <tt><a>DefaultSignatures</a></tt> extension. However, only one default
--   can be provided! With <tt><a>DerivingVia</a></tt> it is now possible
--   to choose from many default instantiations.
--   
--   This package contains a number of such classes. This module
--   demonstrates how one might create a family of newtypes
--   (<a>Default</a>, <a>Default1</a>) for which such instances are
--   defined.
--   
--   One might then use <tt><a>DerivingVia</a></tt> as follows. The
--   implementations of the data types are elided here (they are
--   irrelevant). For most cases, either the deriving clause with the data
--   type definition or the standalone clause will work (for some types it
--   is necessary to supply the context explicitly using the latter form).
--   See the source of this module for the implementations of instances for
--   the <a>Default</a> family of newtypes and the source of the test suite
--   for some types which derive instances via these wrappers.
module Generics.Deriving.Default

-- | This newtype wrapper can be used to derive default instances for
--   classes taking an argument of kind <a>Type</a>.
newtype Default a
Default :: a -> Default a
[unDefault] :: Default a -> a

-- | This newtype wrapper can be used to derive default instances for
--   classes taking an argument of kind <tt><a>Type</a> -&gt;
--   <a>Type</a></tt>.
newtype Default1 f a
Default1 :: f a -> Default1 f a
[unDefault1] :: Default1 f a -> f a
instance (GHC.Generics.Generic1 f, Generics.Deriving.Functor.GFunctor' (GHC.Generics.Rep1 f)) => Generics.Deriving.Functor.GFunctor (Generics.Deriving.Default.Default1 f)
instance (GHC.Generics.Generic1 f, Generics.Deriving.Copoint.GCopoint' (GHC.Generics.Rep1 f)) => Generics.Deriving.Copoint.GCopoint (Generics.Deriving.Default.Default1 f)
instance (GHC.Generics.Generic1 t, Generics.Deriving.Foldable.GFoldable' (GHC.Generics.Rep1 t)) => Generics.Deriving.Foldable.GFoldable (Generics.Deriving.Default.Default1 t)
instance (GHC.Generics.Generic1 t, Generics.Deriving.Functor.GFunctor' (GHC.Generics.Rep1 t), Generics.Deriving.Foldable.GFoldable' (GHC.Generics.Rep1 t), Generics.Deriving.Traversable.GTraversable' (GHC.Generics.Rep1 t)) => Generics.Deriving.Traversable.GTraversable (Generics.Deriving.Default.Default1 t)
instance (GHC.Generics.Generic a, Generics.Deriving.Eq.GEq' (GHC.Generics.Rep a)) => Generics.Deriving.Eq.GEq (Generics.Deriving.Default.Default a)
instance (GHC.Generics.Generic a, Generics.Deriving.Eq.GEq a, Generics.Deriving.Enum.Enum' (GHC.Generics.Rep a)) => Generics.Deriving.Enum.GEnum (Generics.Deriving.Default.Default a)
instance (GHC.Generics.Generic a, Generics.Deriving.Show.GShow' (GHC.Generics.Rep a)) => Generics.Deriving.Show.GShow (Generics.Deriving.Default.Default a)
instance (GHC.Generics.Generic a, Generics.Deriving.Semigroup.GSemigroup' (GHC.Generics.Rep a)) => Generics.Deriving.Semigroup.GSemigroup (Generics.Deriving.Default.Default a)
instance (GHC.Generics.Generic a, Generics.Deriving.Monoid.GMonoid' (GHC.Generics.Rep a)) => Generics.Deriving.Monoid.GMonoid (Generics.Deriving.Default.Default a)
instance (GHC.Generics.Generic a, Generics.Deriving.Uniplate.Uniplate' (GHC.Generics.Rep a) a, Generics.Deriving.Uniplate.Context' (GHC.Generics.Rep a) a) => Generics.Deriving.Uniplate.Uniplate (Generics.Deriving.Default.Default a)

module Generics.Deriving
