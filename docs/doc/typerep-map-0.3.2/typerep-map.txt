-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient implementation of a dependent map with types as keys
--   
--   A dependent map from type representations to values of these types.
--   
--   Here is an illustration of such a map:
--   
--   <pre>
--       TMap
--   ---------------
--    Int  -&gt; 5
--    Bool -&gt; True
--    Char -&gt; 'x'
--   </pre>
--   
--   In addition to <tt>TMap</tt>, we provide <tt>TypeRepMap</tt>
--   parametrized by a <tt>vinyl</tt>-style interpretation. This data
--   structure is equivalent to <tt>DMap TypeRep</tt>, but with
--   significantly more efficient lookups.
@package typerep-map
@version 0.3.2


-- | Internal API for <a>TypeRepMap</a> and operations on it. The functions
--   here do not have any stability guarantees and can change between minor
--   versions.
--   
--   If you need to use this module for purposes other than tests, create
--   an issue.
module Data.TypeRepMap.Internal

-- | <a>TypeRepMap</a> is a heterogeneous data structure similar in its
--   essence to <a>Map</a> with types as keys, where each value has the
--   type of its key. In addition to that, each value is wrapped in an
--   interpretation <tt>f</tt>.
--   
--   Here is an example of using <a>Maybe</a> as an interpretation, with a
--   comparison to <a>Map</a>:
--   
--   <pre>
--    <a>Map</a> <a>String</a> (<a>Maybe</a> <a>String</a>)          <a>TypeRepMap</a> <a>Maybe</a>
--   ---------------------------       ---------------------
--    "Int"  -&gt; Just "5"                 <a>Int</a>  -&gt; Just 5
--    "Bool" -&gt; Just "True"              <a>Bool</a> -&gt; Just <a>True</a>
--    "Char" -&gt; Nothing                  <a>Char</a> -&gt; Nothing
--   </pre>
--   
--   The runtime representation of <a>TypeRepMap</a> is an array, not a
--   tree. This makes <a>lookup</a> significantly more efficient.
data TypeRepMap (f :: k -> Type)

-- | an unsafe constructor for <a>TypeRepMap</a>
TypeRepMap :: {-# UNPACK #-} !PrimArray Word64 -> {-# UNPACK #-} !PrimArray Word64 -> {-# UNPACK #-} !Array Any -> {-# UNPACK #-} !Array Any -> TypeRepMap

-- | first components of key fingerprints
[fingerprintAs] :: TypeRepMap -> {-# UNPACK #-} !PrimArray Word64

-- | second components of key fingerprints
[fingerprintBs] :: TypeRepMap -> {-# UNPACK #-} !PrimArray Word64

-- | values stored in the map
[trAnys] :: TypeRepMap -> {-# UNPACK #-} !Array Any

-- | typerep keys
[trKeys] :: TypeRepMap -> {-# UNPACK #-} !Array Any

-- | Returns the list of <a>Fingerprint</a>s from <a>TypeRepMap</a>.
toFingerprints :: TypeRepMap f -> [Fingerprint]

-- | A <a>TypeRepMap</a> with no values stored in it.
--   
--   <pre>
--   size empty == 0
--   </pre>
--   
--   <pre>
--   member @a empty == False
--   </pre>
empty :: TypeRepMap f

-- | Construct a <a>TypeRepMap</a> with a single element.
--   
--   <pre>
--   size (one x) == 1
--   </pre>
--   
--   <pre>
--   member @a (one (x :: f a)) == True
--   </pre>
one :: forall a f. Typeable a => f a -> TypeRepMap f

-- | Insert a value into a <a>TypeRepMap</a>.
--   
--   <pre>
--   size (insert v tm) &gt;= size tm
--   </pre>
--   
--   <pre>
--   member @a (insert (x :: f a) tm) == True
--   </pre>
insert :: forall a f. Typeable a => f a -> TypeRepMap f -> TypeRepMap f
type KindOf (a :: k) = k

-- | Delete a value from a <a>TypeRepMap</a>.
--   
--   <pre>
--   size (delete @a tm) &lt;= size tm
--   </pre>
--   
--   <pre>
--   member @a (delete @a tm) == False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tm = delete @Bool $ insert (Just True) $ one (Just 'a')
--   
--   &gt;&gt;&gt; size tm
--   1
--   
--   &gt;&gt;&gt; member @Bool tm
--   False
--   
--   &gt;&gt;&gt; member @Char tm
--   True
--   </pre>
delete :: forall a (f :: KindOf a -> Type). Typeable a => TypeRepMap f -> TypeRepMap f

-- | Update a value at a specific key with the result of the provided
--   function. When the key is not a member of the map, the original map is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; trmap = fromList @(TypeRepMap Identity) [WrapTypeable $ Identity "a"]
--   
--   &gt;&gt;&gt; lookup @String $ adjust (fmap (++ "ww")) trmap
--   Just (Identity "aww")
--   </pre>
adjust :: forall a f. Typeable a => (f a -> f a) -> TypeRepMap f -> TypeRepMap f

-- | Map over the elements of a <a>TypeRepMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; tm = insert (Identity True) $ one (Identity 'a')
--   
--   &gt;&gt;&gt; lookup @Bool tm
--   Just (Identity True)
--   
--   &gt;&gt;&gt; lookup @Char tm
--   Just (Identity 'a')
--   
--   &gt;&gt;&gt; tm2 = hoist ((:[]) . runIdentity) tm
--   
--   &gt;&gt;&gt; lookup @Bool tm2
--   Just [True]
--   
--   &gt;&gt;&gt; lookup @Char tm2
--   Just "a"
--   </pre>
hoist :: (forall x. f x -> g x) -> TypeRepMap f -> TypeRepMap g
hoistA :: Applicative t => (forall x. f x -> t (g x)) -> TypeRepMap f -> t (TypeRepMap g)
hoistWithKey :: forall f g. (forall x. Typeable x => f x -> g x) -> TypeRepMap f -> TypeRepMap g

-- | The union of two <a>TypeRepMap</a>s using a combining function.
unionWith :: forall f. (forall x. Typeable x => f x -> f x -> f x) -> TypeRepMap f -> TypeRepMap f -> TypeRepMap f

-- | The (left-biased) union of two <a>TypeRepMap</a>s. It prefers the
--   first map when duplicate keys are encountered, i.e. <tt><a>union</a>
--   == <a>unionWith</a> const</tt>.
union :: TypeRepMap f -> TypeRepMap f -> TypeRepMap f

-- | Check if a value of the given type is present in a <a>TypeRepMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; member @Char $ one (Identity 'a')
--   True
--   
--   &gt;&gt;&gt; member @Bool $ one (Identity 'a')
--   False
--   </pre>
member :: forall a (f :: KindOf a -> Type). Typeable a => TypeRepMap f -> Bool

-- | Lookup a value of the given type in a <a>TypeRepMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; x = lookup $ insert (Identity (11 :: Int)) empty
--   
--   &gt;&gt;&gt; x :: Maybe (Identity Int)
--   Just (Identity 11)
--   
--   &gt;&gt;&gt; x :: Maybe (Identity ())
--   Nothing
--   </pre>
lookup :: forall a f. Typeable a => TypeRepMap f -> Maybe (f a)

-- | Get the amount of elements in a <a>TypeRepMap</a>.
size :: TypeRepMap f -> Int

-- | Return the list of <a>SomeTypeRep</a> from the keys.
keys :: TypeRepMap f -> [SomeTypeRep]

-- | Binary searched based on this article
--   <a>http://bannalia.blogspot.com/2015/06/cache-friendly-binary-search.html</a>
--   with modification for our two-vector search case.
cachedBinarySearch :: Fingerprint -> PrimArray Word64 -> PrimArray Word64 -> Maybe Int
toAny :: f a -> Any
fromAny :: Any -> f a
anyToTypeRep :: Any -> TypeRep f
typeFp :: forall a. Typeable a => Fingerprint
toTriples :: TypeRepMap f -> [(Fingerprint, Any, Any)]
deleteByFst :: Eq a => a -> [(a, b, c)] -> [(a, b, c)]
nubByFst :: Eq a => [(a, b, c)] -> [(a, b, c)]
fst3 :: (a, b, c) -> a

-- | Existential wrapper around <a>Typeable</a> indexed by <tt>f</tt> type
--   parameter. Useful for <a>TypeRepMap</a> structure creation form list
--   of <a>WrapTypeable</a>s.
data WrapTypeable f
[WrapTypeable] :: Typeable a => f a -> WrapTypeable f
wrapTypeable :: TypeRep a -> f a -> WrapTypeable f
calcFp :: forall a. Typeable a => Fingerprint
fromTriples :: [(Fingerprint, Any, Any)] -> TypeRepMap f
fromSortedList :: forall a. [a] -> [a]
instance forall k (f :: k -> *). GHC.Show.Show (Data.TypeRepMap.Internal.WrapTypeable f)
instance forall k (f :: k -> *). GHC.Exts.IsList (Data.TypeRepMap.Internal.TypeRepMap f)
instance forall k (f :: k -> *). Control.DeepSeq.NFData (Data.TypeRepMap.Internal.TypeRepMap f)
instance forall k (f :: k -> *). GHC.Show.Show (Data.TypeRepMap.Internal.TypeRepMap f)
instance forall k (f :: k -> *). GHC.Base.Semigroup (Data.TypeRepMap.Internal.TypeRepMap f)
instance forall k (f :: k -> *). GHC.Base.Monoid (Data.TypeRepMap.Internal.TypeRepMap f)
instance forall k (f :: k -> *). (forall (a :: k). Data.Typeable.Internal.Typeable a => GHC.Classes.Eq (f a)) => GHC.Classes.Eq (Data.TypeRepMap.Internal.TypeRepMap f)


-- | A version of <a>TMap</a> parametrized by an interpretation <tt>f</tt>.
--   This sort of parametrization may be familiar to users of
--   <tt>vinyl</tt> records.
--   
--   <tt><a>TypeRepMap</a> f</tt> is a more efficient replacement for
--   <tt>DMap <a>TypeRep</a> f</tt> (where <tt>DMap</tt> is from the
--   <tt>dependent-map</tt> package).
--   
--   Here is an example of using <a>Maybe</a> as an interpretation, with a
--   comparison to <a>TMap</a>:
--   
--   <pre>
--        <a>TMap</a>              <a>TypeRepMap</a> <a>Maybe</a>
--   --------------       -------------------
--    Int  -&gt; 5             Int  -&gt; Just 5
--    Bool -&gt; True          Bool -&gt; Nothing
--    Char -&gt; 'x'           Char -&gt; Just 'x'
--   </pre>
--   
--   In fact, a <a>TMap</a> is defined as <a>TypeRepMap</a>
--   <a>Identity</a>.
--   
--   Since <a>TypeRep</a> is poly-kinded, the interpretation can use any
--   kind for the keys. For instance, we can use the <a>Symbol</a> kind to
--   use <a>TypeRepMap</a> as an extensible record:
--   
--   <pre>
--   newtype Field name = F (FType name)
--   
--   type family FType (name :: Symbol) :: Type
--   type instance FType "radius" = Double
--   type instance FType "border-color" = RGB
--   type instance FType "border-width" = Double
--   
--          <a>TypeRepMap</a> Field
--   --------------------------------------
--    "radius"       -&gt; F 5.7
--    "border-color" -&gt; F (rgb 148 0 211)
--    "border-width" -&gt; F 0.5
--   </pre>
module Data.TypeRepMap

-- | <a>TypeRepMap</a> is a heterogeneous data structure similar in its
--   essence to <a>Map</a> with types as keys, where each value has the
--   type of its key. In addition to that, each value is wrapped in an
--   interpretation <tt>f</tt>.
--   
--   Here is an example of using <a>Maybe</a> as an interpretation, with a
--   comparison to <a>Map</a>:
--   
--   <pre>
--    <a>Map</a> <a>String</a> (<a>Maybe</a> <a>String</a>)          <a>TypeRepMap</a> <a>Maybe</a>
--   ---------------------------       ---------------------
--    "Int"  -&gt; Just "5"                 <a>Int</a>  -&gt; Just 5
--    "Bool" -&gt; Just "True"              <a>Bool</a> -&gt; Just <a>True</a>
--    "Char" -&gt; Nothing                  <a>Char</a> -&gt; Nothing
--   </pre>
--   
--   The runtime representation of <a>TypeRepMap</a> is an array, not a
--   tree. This makes <a>lookup</a> significantly more efficient.
data TypeRepMap (f :: k -> Type)

-- | A <a>TypeRepMap</a> with no values stored in it.
--   
--   <pre>
--   size empty == 0
--   </pre>
--   
--   <pre>
--   member @a empty == False
--   </pre>
empty :: TypeRepMap f

-- | Construct a <a>TypeRepMap</a> with a single element.
--   
--   <pre>
--   size (one x) == 1
--   </pre>
--   
--   <pre>
--   member @a (one (x :: f a)) == True
--   </pre>
one :: forall a f. Typeable a => f a -> TypeRepMap f

-- | Insert a value into a <a>TypeRepMap</a>.
--   
--   <pre>
--   size (insert v tm) &gt;= size tm
--   </pre>
--   
--   <pre>
--   member @a (insert (x :: f a) tm) == True
--   </pre>
insert :: forall a f. Typeable a => f a -> TypeRepMap f -> TypeRepMap f

-- | Delete a value from a <a>TypeRepMap</a>.
--   
--   <pre>
--   size (delete @a tm) &lt;= size tm
--   </pre>
--   
--   <pre>
--   member @a (delete @a tm) == False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tm = delete @Bool $ insert (Just True) $ one (Just 'a')
--   
--   &gt;&gt;&gt; size tm
--   1
--   
--   &gt;&gt;&gt; member @Bool tm
--   False
--   
--   &gt;&gt;&gt; member @Char tm
--   True
--   </pre>
delete :: forall a (f :: KindOf a -> Type). Typeable a => TypeRepMap f -> TypeRepMap f

-- | Update a value at a specific key with the result of the provided
--   function. When the key is not a member of the map, the original map is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; trmap = fromList @(TypeRepMap Identity) [WrapTypeable $ Identity "a"]
--   
--   &gt;&gt;&gt; lookup @String $ adjust (fmap (++ "ww")) trmap
--   Just (Identity "aww")
--   </pre>
adjust :: forall a f. Typeable a => (f a -> f a) -> TypeRepMap f -> TypeRepMap f

-- | Map over the elements of a <a>TypeRepMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; tm = insert (Identity True) $ one (Identity 'a')
--   
--   &gt;&gt;&gt; lookup @Bool tm
--   Just (Identity True)
--   
--   &gt;&gt;&gt; lookup @Char tm
--   Just (Identity 'a')
--   
--   &gt;&gt;&gt; tm2 = hoist ((:[]) . runIdentity) tm
--   
--   &gt;&gt;&gt; lookup @Bool tm2
--   Just [True]
--   
--   &gt;&gt;&gt; lookup @Char tm2
--   Just "a"
--   </pre>
hoist :: (forall x. f x -> g x) -> TypeRepMap f -> TypeRepMap g
hoistA :: Applicative t => (forall x. f x -> t (g x)) -> TypeRepMap f -> t (TypeRepMap g)
hoistWithKey :: forall f g. (forall x. Typeable x => f x -> g x) -> TypeRepMap f -> TypeRepMap g

-- | The union of two <a>TypeRepMap</a>s using a combining function.
unionWith :: forall f. (forall x. Typeable x => f x -> f x -> f x) -> TypeRepMap f -> TypeRepMap f -> TypeRepMap f

-- | The (left-biased) union of two <a>TypeRepMap</a>s. It prefers the
--   first map when duplicate keys are encountered, i.e. <tt><a>union</a>
--   == <a>unionWith</a> const</tt>.
union :: TypeRepMap f -> TypeRepMap f -> TypeRepMap f

-- | Lookup a value of the given type in a <a>TypeRepMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; x = lookup $ insert (Identity (11 :: Int)) empty
--   
--   &gt;&gt;&gt; x :: Maybe (Identity Int)
--   Just (Identity 11)
--   
--   &gt;&gt;&gt; x :: Maybe (Identity ())
--   Nothing
--   </pre>
lookup :: forall a f. Typeable a => TypeRepMap f -> Maybe (f a)

-- | Check if a value of the given type is present in a <a>TypeRepMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; member @Char $ one (Identity 'a')
--   True
--   
--   &gt;&gt;&gt; member @Bool $ one (Identity 'a')
--   False
--   </pre>
member :: forall a (f :: KindOf a -> Type). Typeable a => TypeRepMap f -> Bool

-- | Get the amount of elements in a <a>TypeRepMap</a>.
size :: TypeRepMap f -> Int

-- | Return the list of <a>SomeTypeRep</a> from the keys.
keys :: TypeRepMap f -> [SomeTypeRep]

-- | Existential wrapper around <a>Typeable</a> indexed by <tt>f</tt> type
--   parameter. Useful for <a>TypeRepMap</a> structure creation form list
--   of <a>WrapTypeable</a>s.
data WrapTypeable f
[WrapTypeable] :: Typeable a => f a -> WrapTypeable f


-- | <a>TMap</a> is a heterogeneous data structure similar in its essence
--   to <a>Map</a> with types as keys, where each value has the type of its
--   key.
--   
--   Here is an example of a <a>TMap</a> with a comparison to <a>Map</a>:
--   
--   <pre>
--    <a>Map</a> <a>String</a> <a>String</a>             <a>TMap</a>
--   --------------------     -----------------
--    "Int"  -&gt; "5"             <a>Int</a>  -&gt; 5
--    "Bool" -&gt; "True"          <a>Bool</a> -&gt; <a>True</a>
--    "Char" -&gt; "'x'"           <a>Char</a> -&gt; 'x'
--   </pre>
--   
--   The runtime representation of <a>TMap</a> is an array, not a tree.
--   This makes <a>lookup</a> significantly more efficient.
module Data.TMap

-- | <a>TMap</a> is a special case of <a>TypeRepMap</a> when the
--   interpretation is <a>Identity</a>.
type TMap = TypeRepMap Identity

-- | A <a>TMap</a> with no values stored in it.
--   
--   <pre>
--   size empty == 0
--   </pre>
--   
--   <pre>
--   member @a empty == False
--   </pre>
empty :: TMap

-- | Construct a <a>TMap</a> with a single element.
--   
--   <pre>
--   size (one x) == 1
--   </pre>
--   
--   <pre>
--   member @a (one (x :: a)) == True
--   </pre>
one :: forall a. Typeable a => a -> TMap

-- | Insert a value into a <a>TMap</a>.
--   
--   <pre>
--   size (insert v tm) &gt;= size tm
--   </pre>
--   
--   <pre>
--   member @a (insert (x :: a) tm) == True
--   </pre>
insert :: forall a. Typeable a => a -> TMap -> TMap

-- | Delete a value from a <a>TMap</a>.
--   
--   <pre>
--   size (delete @a tm) &lt;= size tm
--   </pre>
--   
--   <pre>
--   member @a (delete @a tm) == False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tm = delete @Bool $ insert True $ one 'a'
--   
--   &gt;&gt;&gt; size tm
--   1
--   
--   &gt;&gt;&gt; member @Bool tm
--   False
--   
--   &gt;&gt;&gt; member @Char tm
--   True
--   </pre>
delete :: forall a. Typeable a => TMap -> TMap

-- | The union of two <a>TMap</a>s using a combining function.
unionWith :: (forall x. Typeable x => x -> x -> x) -> TMap -> TMap -> TMap

-- | The (left-biased) union of two <a>TMap</a>s. It prefers the first map
--   when duplicate keys are encountered, i.e. <tt><a>union</a> ==
--   <a>unionWith</a> const</tt>.
union :: TMap -> TMap -> TMap

-- | Map a function over the values.
map :: (forall a. Typeable a => a -> a) -> TMap -> TMap

-- | Update a value with the result of the provided function.
adjust :: Typeable a => (a -> a) -> TMap -> TMap

-- | Lookup a value of the given type in a <a>TMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; x = lookup $ insert (11 :: Int) empty
--   
--   &gt;&gt;&gt; x :: Maybe Int
--   Just 11
--   
--   &gt;&gt;&gt; x :: Maybe ()
--   Nothing
--   </pre>
lookup :: forall a. Typeable a => TMap -> Maybe a

-- | Check if a value of the given type is present in a <a>TMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; member @Char $ one 'a'
--   True
--   
--   &gt;&gt;&gt; member @Bool $ one 'a'
--   False
--   </pre>
member :: forall a. Typeable a => TMap -> Bool

-- | Get the amount of elements in a <a>TMap</a>.
size :: TMap -> Int

-- | Returns the list of <a>SomeTypeRep</a>s from keys.
keys :: TMap -> [SomeTypeRep]
