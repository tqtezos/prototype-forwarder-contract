-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Upgradeability infrastructure based on Morley.
--   
--   Basic infrastructure for writing upgradeable contracts in Morley-based
--   eDSL.
@package morley-upgradeable
@version 0.2.0.1

module Lorentz.Contracts.Upgradeable.Common.Base

-- | Version of a contract.
--   
--   Our current versioning suggests that this type is a term-level
--   reflection of types which have <a>KnownContractVersion</a> instance,
--   so this version item should uniquely identify storage structure and
--   entrypoints set for a given contract for all of its instances.
--   
--   The old semantics of this type was that it counts number of given
--   contract instance upgrades, so different contract instances, being
--   upgraded to the recent version, could have different <a>Version</a>s.
--   For old contracts we have to follow this behaviour.
newtype Version
Version :: Natural -> Version
[unVersion] :: Version -> Natural

-- | Kind of type-level contract version.
type VersionKind = ContractVersionTag -> Type

-- | Declare given type as contract version identifier.
--   
--   Instances of this typeclass (versions) uniquely identify contract
--   storage scheme and code. Normally the opposite should also hold, i.e.
--   <tt>contract version <a>-</a> (contract storage scheme, code)</tt>
--   relation is a bijection.
--   
--   If as part of migration you need to update contract storage without
--   modifying its structure, then contract version should not change, and
--   you should perform an upgrade to the same version as the current one.
--   
--   We allow upgrades between arbitrary two versions, so one can not only
--   upgrade to the next adjacent version, but also upgrade a new contract
--   from V0 to the recent version immediately, or leave version the same
--   (as a versatile way to change storage).
class KnownContractVersion (v :: VersionKind) where {
    
    -- | List of entrypoints of given contract version.
    type family VerInterface v :: [EntryPointKind];
    
    -- | Storage template of given contract version.
    type family VerUStoreTemplate v :: Type;
    
    -- | Set of permanent entrypoints (as a sum type).
    --   
    --   We tie this type to contract version for convenience, in order not to
    --   carry one more type argument everywhere. We do not ensure right here
    --   that all versions of a contract have the same permanent entrypoints,
    --   but if this does not hold, then (ideally) it will not be possible to
    --   construct migration between such contract versions.
    type family VerPermanent v :: Type;
    type VerPermanent v = Empty;
}

-- | Get term-level contract version. Returned value will be stored within
--   the contract designating the current contract version.
contractVersion :: KnownContractVersion v => Proxy v -> Version

-- | Get term-level contract version. Returned value will be stored within
--   the contract designating the current contract version.
contractVersion :: (KnownContractVersion v, v ~ cid ver, KnownNat ver) => Proxy v -> Version
type VerParam v = UParam (VerInterface v)
type VerUStore v = UStore (VerUStoreTemplate v)

-- | Contract with empty interface and storage.
data EmptyContractVersion (perm :: Type) :: VersionKind

-- | Version which forgets about particular interface/storage.
data SomeContractVersion (perm :: Type) :: VersionKind

-- | UStore with hidden template.
type UStore_ = UStore SomeUTemplate

-- | Code of migration for <a>UStore</a>.
--   
--   Invariant: preferably should fit into op size / gas limits (quite
--   obvious). Often this stands for exactly one stage of migration (one
--   Tezos transaction).
newtype MigrationScript oldStore newStore
MigrationScript :: Lambda UStore_ UStore_ -> MigrationScript oldStore newStore
[unMigrationScript] :: MigrationScript oldStore newStore -> Lambda UStore_ UStore_

-- | Corner case of <a>MigrationScript</a> with some type argument unknown.
--   
--   You can turn this into <a>MigrationScript</a> using
--   <a>checkedCoerce</a>.
type MigrationScriptFrom oldStore = MigrationScript oldStore SomeUTemplate
type MigrationScriptTo newStore = MigrationScript SomeUTemplate newStore

-- | Keeps parameter dispatching logic.
data UContractRouter (ver :: VersionKind)
UContractRouter :: Lambda (VerParam ver, VerUStore ver) ([Operation], VerUStore ver) -> UContractRouter
[unUContractRouter] :: UContractRouter -> Lambda (VerParam ver, VerUStore ver) ([Operation], VerUStore ver)
type SomeUContractRouter = UContractRouter (SomeContractVersion ())

-- | Common marker for upgradeable, or <i>virtual</i>, entrypoints. Can be
--   used when each upgradeable entrypoint is simple, i.e. does not itself
--   consist of multiple entrypoints.
data UpgradeableEntryPointsKind

-- | Implementation of permanent entrypoints.
--   
--   This will be injected into contract storage as one of fields, so make
--   sure that code within does not exceed several instructions; an actual
--   entrypoint logic can be put into <a>UStore</a> and called from within
--   <tt>PermanentImpl</tt> only when necessary.
--   
--   Regarding documentation - this have to provide code pieces wrapped
--   into <a>DEntryPoint</a> with <a>PermanentEntryPointsKind</a>, so
--   always use <a>entryCase</a> as implementation of this type <i>or</i>
--   inject documentation of code which does so unless you know what you
--   are doing.
newtype PermanentImpl ver
PermanentImpl :: Entrypoint (VerPermanent ver) (VerUStore ver) -> PermanentImpl ver
[unPermanentImpl] :: PermanentImpl ver -> Entrypoint (VerPermanent ver) (VerUStore ver)
type SomePermanentImpl perm = PermanentImpl (SomeContractVersion perm)

-- | Common marker for permanent entrypoints. Can be used when parameter
--   for permanent entrypoints is flat, i.e. does not have nested
--   subparameters with multiple entrypoints.
data PermanentEntryPointsKind
mkUContractRouter :: ([VerParam ver, VerUStore ver] :-> '[([Operation], VerUStore ver)]) -> UContractRouter ver
coerceUContractRouter :: (Coercible_ (VerParam s1) (VerParam s2), Coercible_ (VerUStore s1) (VerUStore s2)) => UContractRouter s1 -> UContractRouter s2

-- | Common implementation of permanent part in case contract has no such.
emptyPermanentImpl :: VerPermanent ver ~ Empty => PermanentImpl ver

-- | Construct implementation of permanent part in a common case; this
--   works similarly to <a>entryCase</a>.
--   
--   Use this function only for very small implementations.
mkSmallPermanentImpl :: forall ver dt out inp clauses. (CaseTC dt out inp clauses, DocumentEntryPoints PermanentEntryPointsKind dt, dt ~ VerPermanent ver, inp ~ '[VerUStore ver], out ~ ContractOut (VerUStore ver)) => IsoRecTuple clauses -> PermanentImpl ver

-- | (Kind) This is the kind of type-level natural numbers.
data Nat

-- | Replacement for uninhabited type.
data Empty

-- | Witness of that this code is unreachable.
absurd_ :: () => (Empty : s) :-> s'
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Contracts.Upgradeable.Common.Base.PermanentImpl ver)
instance GHC.Show.Show (Lorentz.Contracts.Upgradeable.Common.Base.PermanentImpl ver)
instance GHC.Generics.Generic (Lorentz.Contracts.Upgradeable.Common.Base.PermanentImpl ver)
instance Lorentz.TypeAnns.HasTypeAnn (Lorentz.Contracts.Upgradeable.Common.Base.UContractRouter ver)
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Contracts.Upgradeable.Common.Base.UContractRouter ver)
instance GHC.Show.Show (Lorentz.Contracts.Upgradeable.Common.Base.UContractRouter ver)
instance GHC.Generics.Generic (Lorentz.Contracts.Upgradeable.Common.Base.UContractRouter ver)
instance Lorentz.TypeAnns.HasTypeAnn Lorentz.Contracts.Upgradeable.Common.Base.Version
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.Upgradeable.Common.Base.Version
instance Michelson.Typed.Haskell.Value.IsoCValue Lorentz.Contracts.Upgradeable.Common.Base.Version
instance GHC.Num.Num Lorentz.Contracts.Upgradeable.Common.Base.Version
instance GHC.Generics.Generic Lorentz.Contracts.Upgradeable.Common.Base.Version
instance GHC.Classes.Ord Lorentz.Contracts.Upgradeable.Common.Base.Version
instance GHC.Classes.Eq Lorentz.Contracts.Upgradeable.Common.Base.Version
instance GHC.Show.Show Lorentz.Contracts.Upgradeable.Common.Base.Version
instance Michelson.Doc.DocItem (Lorentz.EntryPoints.Doc.DEntryPoint Lorentz.Contracts.Upgradeable.Common.Base.PermanentEntryPointsKind)
instance Lorentz.TypeAnns.HasTypeAnn (Lorentz.Contracts.Upgradeable.Common.Base.VerPermanent ver) => Lorentz.TypeAnns.HasTypeAnn (Lorentz.Contracts.Upgradeable.Common.Base.PermanentImpl ver)
instance Control.Lens.Wrapped.Wrapped (Lorentz.Contracts.Upgradeable.Common.Base.PermanentImpl ver)
instance (Data.Typeable.Internal.Typeable ver, Data.Typeable.Internal.Typeable (Lorentz.Contracts.Upgradeable.Common.Base.VerUStoreTemplate ver), Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Contracts.Upgradeable.Common.Base.VerPermanent ver), Lorentz.Constraints.Scopes.KnownValue (Lorentz.Contracts.Upgradeable.Common.Base.VerPermanent ver)) => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Contracts.Upgradeable.Common.Base.PermanentImpl ver)
instance (Lorentz.Coercions.CanCastTo (Lorentz.Contracts.Upgradeable.Common.Base.VerPermanent ver1) (Lorentz.Contracts.Upgradeable.Common.Base.VerPermanent ver2), Lorentz.Coercions.CanCastTo (Lorentz.Contracts.Upgradeable.Common.Base.VerUStore ver1) (Lorentz.Contracts.Upgradeable.Common.Base.VerUStore ver2)) => Lorentz.Coercions.CanCastTo (Lorentz.Contracts.Upgradeable.Common.Base.PermanentImpl ver1) (Lorentz.Contracts.Upgradeable.Common.Base.PermanentImpl ver2)
instance Michelson.Doc.DocItem (Lorentz.EntryPoints.Doc.DEntryPoint Lorentz.Contracts.Upgradeable.Common.Base.UpgradeableEntryPointsKind)
instance Control.Lens.Wrapped.Wrapped (Lorentz.Contracts.Upgradeable.Common.Base.UContractRouter ver)
instance (Data.Typeable.Internal.Typeable ver, Data.Typeable.Internal.Typeable (Lorentz.Contracts.Upgradeable.Common.Base.VerInterface ver), Data.Typeable.Internal.Typeable (Lorentz.Contracts.Upgradeable.Common.Base.VerUStoreTemplate ver)) => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Contracts.Upgradeable.Common.Base.UContractRouter ver)
instance (Lorentz.Coercions.CanCastTo (Lorentz.Contracts.Upgradeable.Common.Base.VerParam ver1) (Lorentz.Contracts.Upgradeable.Common.Base.VerParam ver2), Lorentz.Coercions.CanCastTo (Lorentz.Contracts.Upgradeable.Common.Base.VerUStore ver1) (Lorentz.Contracts.Upgradeable.Common.Base.VerUStore ver2)) => Lorentz.Coercions.CanCastTo (Lorentz.Contracts.Upgradeable.Common.Base.UContractRouter ver1) (Lorentz.Contracts.Upgradeable.Common.Base.UContractRouter ver2)
instance Lorentz.Contracts.Upgradeable.Common.Base.KnownContractVersion (Lorentz.Contracts.Upgradeable.Common.Base.SomeContractVersion perm)
instance Lorentz.Contracts.Upgradeable.Common.Base.KnownContractVersion (Lorentz.Contracts.Upgradeable.Common.Base.EmptyContractVersion perm)
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add GHC.Natural.Natural Lorentz.Contracts.Upgradeable.Common.Base.Version
instance Formatting.Buildable.Buildable Lorentz.Contracts.Upgradeable.Common.Base.Version
instance Michelson.Typed.Haskell.Doc.TypeHasDoc Lorentz.Contracts.Upgradeable.Common.Base.Version
instance Lorentz.EntryPoints.Core.ParameterHasEntryPoints Lorentz.Contracts.Upgradeable.Common.Base.Version

module Lorentz.Contracts.Upgradeable.Common.Doc
data DUpgradeability
DUpgradeability :: Markdown -> DUpgradeability
contractDoc :: Markdown
runDoc :: Markdown
runPermDoc :: Markdown
upgradeDoc :: Markdown
getVersionDoc :: Markdown
setAdministratorDoc :: Markdown
epwBeginUpgradeDoc :: Markdown
epwApplyMigrationDoc :: Markdown
epwSetCodeDoc :: Markdown
epwSetPermCodeDoc :: Markdown
epwFinishUpgradeDoc :: Markdown
instance Michelson.Doc.DocItem Lorentz.Contracts.Upgradeable.Common.Doc.DUpgradeability


-- | Template for upgradeable contract.
--   
--   It provides the following features: 1. Contract with upgradeable
--   storage format and entrypoints set. 2. Two way to upgrade the contract
--   - one shot and entrypoint-wise.
module Lorentz.Contracts.Upgradeable.Common.Contract

-- | Parameter of upgradeable contract. It contains, among others:
--   
--   <ol>
--   <li>Entrypoint for running one of upgradeable entrypoints.</li>
--   <li>Entrypoint for running one of permanent entrypoints, suitable e.g.
--   for implementing interfaces. 3a. Entrypoint for upgrade in a single
--   call. 3b. Entrypoints for entrypoint-wise upgrade.</li>
--   </ol>
data Parameter (ver :: VersionKind)
Run :: VerParam ver -> Parameter
RunPerm :: VerPermanent ver -> Parameter
Upgrade :: OneShotUpgradeParameters ver -> Parameter
GetVersion :: View () Version -> Parameter
SetAdministrator :: Address -> Parameter
EpwBeginUpgrade :: ("current" :! Version, "new" :! Version) -> Parameter
EpwApplyMigration :: MigrationScriptFrom (VerUStoreTemplate ver) -> Parameter
EpwSetCode :: SomeUContractRouter -> Parameter
EpwSetPermCode :: SomePermanentImpl (VerPermanent ver) -> Parameter
EpwFinishUpgrade :: Parameter
type UTAddress ver = TAddress (Parameter ver)
type UContractRef ver = ContractRef (Parameter ver)

-- | Constraint on abstract set of permanent entrypoints.
type PermConstraint ver = (NiceParameterFull (VerPermanent ver), NoExplicitDefaultEntryPoint (VerPermanent ver), HasTypeAnn (VerPermanent ver), RequireAllUniqueEntryPoints (Parameter ver))
data Storage (ver :: VersionKind)
type UpgradeableContract ver = ContractCode (Parameter ver) (Storage ver)

-- | Implementation of permanent entrypoints.
--   
--   This will be injected into contract storage as one of fields, so make
--   sure that code within does not exceed several instructions; an actual
--   entrypoint logic can be put into <a>UStore</a> and called from within
--   <tt>PermanentImpl</tt> only when necessary.
--   
--   Regarding documentation - this have to provide code pieces wrapped
--   into <a>DEntryPoint</a> with <a>PermanentEntryPointsKind</a>, so
--   always use <a>entryCase</a> as implementation of this type <i>or</i>
--   inject documentation of code which does so unless you know what you
--   are doing.
data PermanentImpl ver
type InitUpgradeableContract perm = UpgradeableContract (EmptyContractVersion perm)

-- | Parameters of one-shot upgrade.
--   
--   Do not construct this value manually, consider using
--   <tt>makeOneShotUpgradeParameters</tt>.
type OneShotUpgradeParameters ver = ("currentVersion" :! Version, "newVersion" :! Version, "migrationScript" :! MigrationScriptFrom (VerUStoreTemplate ver), "newCode" :! Maybe SomeUContractRouter, "newPermCode" :! Maybe (SomePermanentImpl (VerPermanent ver)))

-- | Specify version if given contract.
data DVersion
DVersion :: Version -> DVersion
upgradeableContract :: forall ver. NiceVersion ver => UpgradeableContract ver
mkEmptyStorage :: (VerInterface ver ~ '[], VerUStoreTemplate ver ~ ()) => Address -> Storage ver

-- | Mentions that parameter should be wrapped into <a>Run</a> entry point.
pbsContainedInRun :: ParamBuildingStep

-- | Mentions that parameter should be wrapped into <a>Run</a> entry point.
pbsContainedInRunPerm :: ParamBuildingStep
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Contracts.Upgradeable.Common.Contract.Storage ver)
instance GHC.Generics.Generic (Lorentz.Contracts.Upgradeable.Common.Contract.Storage ver)
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Contracts.Upgradeable.Common.Contract.StorageFields ver)
instance GHC.Generics.Generic (Lorentz.Contracts.Upgradeable.Common.Contract.StorageFields ver)
instance GHC.Generics.Generic (Lorentz.Contracts.Upgradeable.Common.Contract.Parameter ver)
instance (GHC.Show.Show (Lorentz.Contracts.Upgradeable.Common.Base.VerParam ver), GHC.Show.Show (Lorentz.Contracts.Upgradeable.Common.Base.VerPermanent ver)) => GHC.Show.Show (Lorentz.Contracts.Upgradeable.Common.Contract.Parameter ver)
instance Michelson.Doc.DocItem (Lorentz.EntryPoints.Doc.DEntryPoint Lorentz.Contracts.Upgradeable.Common.Contract.UpgradeableEntryPointKind)
instance Michelson.Doc.DocItem Lorentz.Contracts.Upgradeable.Common.Contract.DVersion
instance Lorentz.Contracts.Upgradeable.Common.Contract.NiceVersion ver => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Contracts.Upgradeable.Common.Contract.Storage ver)
instance Lorentz.Contracts.Upgradeable.Common.Contract.NiceVersion ver => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Contracts.Upgradeable.Common.Contract.StorageFields ver)
instance Lorentz.Contracts.Upgradeable.Common.Contract.PermConstraint ver => Lorentz.EntryPoints.Core.ParameterHasEntryPoints (Lorentz.Contracts.Upgradeable.Common.Contract.Parameter ver)
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Contracts.Upgradeable.Common.Base.VerPermanent ver) => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Contracts.Upgradeable.Common.Contract.Parameter ver)
instance (interface Data.Type.Equality.~ Lorentz.Contracts.Upgradeable.Common.Base.VerInterface ver, Lorentz.UParam.UnpackUParam Formatting.Buildable.Buildable interface, Formatting.Buildable.Buildable (Lorentz.Contracts.Upgradeable.Common.Base.VerPermanent ver)) => Formatting.Buildable.Buildable (Lorentz.Contracts.Upgradeable.Common.Contract.Parameter ver)
instance Lorentz.Contracts.Upgradeable.Common.Contract.NiceVersion ver => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Contracts.Upgradeable.Common.Contract.Parameter ver)
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "upgContractIsPaused")
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "upgContractIsNotPaused")
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "upgVersionMismatch")
instance Lorentz.Errors.CustomErrorHasDoc "upgContractIsPaused"
instance Lorentz.Errors.CustomErrorHasDoc "upgContractIsNotPaused"
instance Lorentz.Errors.CustomErrorHasDoc "upgVersionMismatch"


-- | Type-safe interface for constructing contract upgrades.
--   
--   Use this module as follows: 1. Construct <a>EpwUpgradeParameters</a>;
--   2. Use one of the respective functions to convert it to an actual
--   upgrade, one-shot or entrypoint-wise, for tests or production.
module Lorentz.Contracts.Upgradeable.Common.Interface

-- | Type-safe upgrade construction.
data EpwUpgradeParameters (t :: Type -> Type) (curVer :: VersionKind) (newVer :: VersionKind)
EpwUpgradeParameters :: t (MigrationScript (VerUStoreTemplate curVer) (VerUStoreTemplate newVer)) -> code -> codePerm -> EpwUpgradeParameters

-- | Storage migration script. Supply this field with result of
--   <a>migrationToScriptI</a> or <tt>migrationToScripts</tt> call.
[upMigrationScripts] :: EpwUpgradeParameters -> t (MigrationScript (VerUStoreTemplate curVer) (VerUStoreTemplate newVer))

-- | Updated parameter dispatching logic. Pass <a>UContractRouter</a> or
--   <a>Nothing</a>.
[upNewCode] :: EpwUpgradeParameters -> code

-- | Updates implementation of permanent part. Pass <a>PermanentImpl</a> or
--   <a>Nothing</a>.
[upNewPermCode] :: EpwUpgradeParameters -> codePerm

-- | Make up a "fixed version" upgrade. As argument you supply result of
--   <a>migrationToScriptI</a> or <tt>migrationToScripts</tt> and
--   entrypoint-wise migration will be used inside.
--   
--   Use this method in case you need to authoritatively perform arbitrary
--   modifications of contract storage.
fvUpgrade :: forall ver t. (KnownContractVersion ver, Traversable t) => t (MigrationScript (VerUStoreTemplate ver) (VerUStoreTemplate ver)) -> EpwUpgradeParameters t ver ver

-- | Construct <a>OneShotUpgradeParameters</a>.
--   
--   Naturally, you can construct this kind of upgrade only if your
--   migration has exactly one stage; for batched migrations use
--   <a>makeEpwUpgrade</a>.
makeOneShotUpgradeParameters :: forall curVer newVer. EpwUpgradeParameters Identity curVer newVer -> OneShotUpgradeParameters curVer

-- | Construct a call which should be performed in order to perform
--   migration.
makeOneShotUpgrade :: forall oldVer newVer. EpwUpgradeParameters Identity oldVer newVer -> Parameter oldVer

-- | Construct calls which should be performed in order to perform full
--   entrypoint-wise migration.
makeEpwUpgrade :: forall curVer newVer t. EpwUpgradeParameters t curVer newVer -> [Parameter curVer]

-- | Way of performing an upgrade.
data UpgradeWay (t :: Type -> Type)

-- | Perform upgrade in a single transaction. This, naturally, cannot be
--   used with batched migrations.
[UpgOneShot] :: UpgradeWay Identity

-- | Perform upgrade calling one entrypoint per transaction.
[UpgEntryPointWise] :: UpgradeWay t

-- | <a>UpgradeWay</a> which can be used with simple (non-batched)
--   migrations.
type SimpleUpgradeWay = UpgradeWay Identity

-- | Perform a contract upgrade in an integrational test scenario.
integrationalTestUpgrade :: PermConstraint curVer => EpwUpgradeParameters t curVer newVer -> UpgradeWay t -> UTAddress curVer -> IntegrationalScenarioM (UTAddress newVer)
instance GHC.Show.Show (Lorentz.Contracts.Upgradeable.Common.Interface.UpgradeWay t)
instance (Lorentz.Contracts.Upgradeable.Common.Interface.RequireSameVersionStorageParts curVer newVer "permanent part implementation", Lorentz.Contracts.Upgradeable.Common.Interface.RequireSameVersionPermanents curVer newVer, x Data.Type.Equality.~ Data.Void.Void) => Lorentz.Contracts.Upgradeable.Common.Interface.RecognizeUpgPiece (Lorentz.Contracts.Upgradeable.Common.Interface.PermanentImplUpdate curVer newVer) (GHC.Maybe.Maybe x)
instance (Lorentz.Contracts.Upgradeable.Common.Interface.RequireSameVersionStorageParts curVer newVer "upgradeable part implementation", Lorentz.Contracts.Upgradeable.Common.Interface.RequireSameVersionInterfaces curVer newVer, x Data.Type.Equality.~ Data.Void.Void) => Lorentz.Contracts.Upgradeable.Common.Interface.RecognizeUpgPiece (Lorentz.Contracts.Upgradeable.Common.Interface.UContractRouterUpdate curVer newVer) (GHC.Maybe.Maybe x)
instance forall k (newVerE :: Lorentz.Contracts.Upgradeable.Common.Base.VersionKind) (newVerG :: Lorentz.Contracts.Upgradeable.Common.Base.VersionKind) (curVerE :: k). (newVerE Data.Type.Equality.~ newVerG) => Lorentz.Contracts.Upgradeable.Common.Interface.RecognizeUpgPiece (Lorentz.Contracts.Upgradeable.Common.Interface.UContractRouterUpdate curVerE newVerE) (Lorentz.Contracts.Upgradeable.Common.Base.UContractRouter newVerG)
instance forall k (newVerE :: Lorentz.Contracts.Upgradeable.Common.Base.VersionKind) (newVerG :: Lorentz.Contracts.Upgradeable.Common.Base.VersionKind) (curVerE :: k). (newVerE Data.Type.Equality.~ newVerG) => Lorentz.Contracts.Upgradeable.Common.Interface.RecognizeUpgPiece (Lorentz.Contracts.Upgradeable.Common.Interface.PermanentImplUpdate curVerE newVerE) (Lorentz.Contracts.Upgradeable.Common.Base.PermanentImpl newVerG)

module Lorentz.Contracts.Upgradeable.Common

module Lorentz.Contracts.Upgradeable.EntryPointWise

-- | A helper type that defines an entrypoint that receives a packed
--   argument, i.e. it's basically an unpack instruction followed by a
--   TypedEntryPoint code
type EntryPointImpl store = Lambda (ByteString, UStore store) ([Operation], UStore store)

-- | A helper type that defines a function being called in case no
--   implementation matches the requested entrypoint
type EpwFallback store = Lambda ((MText, ByteString), UStore store) ([Operation], UStore store)

-- | This data type represents the new contract code and migrations
--   necessary to upgrade the contract endpoints to the new version.
data EpwContract ver
EpwContract :: UContractRouter ver -> (forall oldStore. [MigrationScript oldStore (VerUStoreTemplate ver)]) -> EpwContract ver

-- | <a>epwServe</a> does the dispatching logic and is assumed to be used
--   for the <tt>code</tt> lambda of the upgradeable contract.
[epwServe] :: EpwContract ver -> UContractRouter ver

-- | <a>epwCodeMigrations</a> is a list of packed migrations the client
--   ought to pass to the <tt>EpwUpgrade</tt> method in order to upgrade
--   the implementation.
[epwCodeMigrations] :: EpwContract ver -> forall oldStore. [MigrationScript oldStore (VerUStoreTemplate ver)]

-- | A data type representing a full case clause with the name and
--   implementation of an entrypoint.
data EpwCaseClause store (entry :: EntryPointKind)
[EpwCaseClause] :: TypedEntryPointImpl arg store -> EpwCaseClause store '(name, arg)

-- | Creates the EpwContract data structure from a Rec of case clauses
mkEpwContract :: forall (ver :: VersionKind) (interface :: [EntryPointKind]) store. (interface ~ VerInterface ver, store ~ VerUStoreTemplate ver, CodeMigrations interface, HasUStore "code" MText (EntryPointImpl store) store, HasUField "fallback" (EpwFallback store) store) => Rec (EpwCaseClause store) interface -> EpwFallback store -> EpwContract ver

-- | Like <a>mkEpwContract</a>, but accepts a tuple of clauses, not a
--   <a>Rec</a>.
mkEpwContractT :: forall clauses ver (interface :: [EntryPointKind]) store. (interface ~ VerInterface ver, store ~ VerUStoreTemplate ver, clauses ~ Rec (EpwCaseClause store) interface, RecFromTuple clauses, CodeMigrations interface, HasUStore "code" MText (EntryPointImpl store) store, HasUField "fallback" (EpwFallback store) store) => IsoRecTuple clauses -> EpwFallback store -> EpwContract ver

-- | Default implementation for <a>EpwFallback</a> reports an error just
--   like its UParam counterpart
epwFallbackFail :: EpwFallback store
(/==>) :: Label name -> Lambda (arg, UStore store) ([Operation], UStore store) -> EpwCaseClause store '(name, arg)
infixr 0 /==>

-- | Removes an endpoint from the #code submap
removeEndpoint :: forall store name s. GetUStoreKey store "code" ~ MText => Label name -> (UStore store : s) :-> (UStore store : s)

-- | Helper for documenting entrypoints with EPW interface.
class EpwDocumented (entries :: [EntryPointKind])

-- | Make up documentation for given entry points.
--   
--   As result you get a fake contract from which you can later build
--   desired documentation. Although, you may want to add contract name and
--   description first.
epwDocument :: EpwDocumented entries => Rec (EpwCaseClause store) entries -> Lambda () ()

-- | By given list of entrypoints make up a fake contract which contains
--   documentation for the body of given upgradeable contract.
epwContractDoc :: forall ver. (KnownContractVersion ver, EpwDocumented (VerInterface ver), TypeHasDoc (VerPermanent ver), HasTypeAnn (VerPermanent ver), KnownValue (VerPermanent ver), PermConstraint ver, Typeable ver) => Rec (EpwCaseClause (VerUStoreTemplate ver)) (VerInterface ver) -> PermanentImpl ver -> Lambda () ()
instance Lorentz.Contracts.Upgradeable.EntryPointWise.EpwDocumented '[]
instance (GHC.TypeLits.KnownSymbol name, Lorentz.Contracts.Upgradeable.EntryPointWise.EpwDocumented es) => Lorentz.Contracts.Upgradeable.EntryPointWise.EpwDocumented ('(name, a) : es)
instance (Lorentz.Contracts.Upgradeable.EntryPointWise.CodeMigrations entries, GHC.TypeLits.KnownSymbol name, Lorentz.Constraints.Scopes.NiceUnpackedValue arg) => Lorentz.Contracts.Upgradeable.EntryPointWise.CodeMigrations ((name Lorentz.UParam.?: arg) : entries)
instance Lorentz.Contracts.Upgradeable.EntryPointWise.CodeMigrations '[]


-- | Contracts based on storage-driven upgrages.
--   
--   Here entrypoints are declared as part of UStore template, then we
--   automatically derive public API of the contract from it.
--   
--   Migration mechanism for storage (see <a>Migration</a>) also applies to
--   these entrypoints.
--   
--   This approach differs from one in
--   <a>Lorentz.Contracts.Upgradeable.EntryPointWise</a> in the following
--   points: 1. Storage migrations are not handled here, only
--   <a>UContractRouter</a> creation. The former is comprehensively handled
--   by <a>Migration</a>. 2. Contract interface is declared via storage -
--   <a>UStoreEntryPoint</a> entries in storage define which public
--   entrypoints (those which are callable via passing <a>UParam</a>) the
--   contract will have. 3. Parameter dispatch fallback is made part of
--   <a>UContractRouter</a>, not storing it in storage here for simplicity.
--   The user can still decide to keep fallback implementation in storage
--   if it is big and then refer to it in <a>SduFallback</a>.
module Lorentz.Contracts.Upgradeable.StorageDriven

-- | Public entrypoint of a contract kept in <a>UStore</a>.
--   
--   These are mere <a>UStore</a> fields but treated specially by
--   <a>mkSduContract</a> function which produces <a>UContractRouter</a>
--   capable of calling these entrypoints.
--   
--   This type is not intended for keeping internal code, in such case
--   consider using <a>UStoreField</a> instead.
type UStoreEntryPoint arg store = UStoreFieldExt UMarkerEntryPoint (SduEntryPoint arg store)
data UMarkerEntryPoint :: UStoreMarkerType

-- | An entrypoint which is assumed to be kept in <a>UStore</a>. It accepts
--   a packed argument.
data SduEntryPoint (store :: Type) (arg :: Type)

-- | Construct public entrypoint.
mkSduEntryPoint :: NiceUnpackedValue arg => Entrypoint arg (UStore store) -> SduEntryPoint store arg

-- | Construct public entrypoint for <a>UStore</a>.
mkUStoreEntryPoint :: NiceUnpackedValue arg => Entrypoint arg (UStore store) -> UStoreEntryPoint store arg

-- | A helper type that defines a function being called in case no
--   implementation matches the requested entrypoint
type SduFallback store = Lambda ((MText, ByteString), UStore store) ([Operation], UStore store)

-- | Get the set of entrypoints (i.e. <a>UStoreEntryPoint</a> entries)
--   stored in UStore with given template.
type UStoreEpInterface utemplate = ExtractInterface utemplate (PickMarkedFields UMarkerEntryPoint utemplate)

-- | Construct <a>UContractRouter</a> which allows calling all entrypoints
--   stored as <a>UStoreEntryPoint</a> entries of <a>UStore</a>.
mkSduContract :: SduFallback (VerUStoreTemplate ver) -> UContractRouter ver

-- | Call an entrypoint stored under the given field.
callUStoreEntryPoint :: (NicePackedValue arg, HasUField field (SduEntryPoint store arg) store) => Label field -> (arg : (UStore store : s)) :-> (([Operation], UStore store) : s)

-- | Default implementation for <a>SduFallback</a> reports an error just
--   like its UParam counterpart.
sduFallbackFail :: SduFallback store

-- | Gather documentation of entrypoints kept in given storage.
--   Unfortunatelly, this seems to be the only place where we can pick the
--   code for documenting it.
--   
--   Note: in most cases you want to use this function is couple with
--   <a>sduAddEntrypointDoc</a>.
sduDocument :: UStoreEpTraversal '[Typeable] template => template -> Lambda () ()

-- | Mark all public code kept in given storage as atomic entrypoints.
--   
--   Sometimes you want your <a>SduEntryPoint</a>s to contain multiple
--   sub-entrypoints inside, in this case using <a>entryCase</a> function
--   you get documentation for each of sub-entrypoints automatically and
--   calling this function is not necessary. In case when this <b>does
--   not</b> hold and <a>SduEntryPoint</a> keeps exactly one entrypoint,
--   you still need to mark it as such in order for <a>sduDocument</a> to
--   handle it properly. This function does exactly that - it finds all
--   UStore entrypoints and marks them for documentation.
sduAddEntrypointDoc :: (UStoreEpTraversal [KnownValue, TypeHasDoc, HasTypeAnn] template, DocItem (DEntryPoint epKind)) => Proxy epKind -> template -> template

-- | By given storage make up a fake contract which contains documentation
--   of all entrypoints declared by this storage.
--   
--   Note: in most cases you want to use this function in couple with
--   <a>sduAddEntrypointDoc</a>.
--   
--   Note: we intentionally allow accepted <tt>UStore</tt> template not to
--   correspond to the contract version storage, this is useful when one
--   does not want to provide the full storage (construction of which may
--   require passing some parameters), rather only part of storage with
--   entrypoints.
sduContractDoc :: forall utemplate ver. (KnownContractVersion ver, UStoreEpTraversal '[Typeable] utemplate, TypeHasDoc (VerPermanent ver), KnownValue (VerPermanent ver), HasTypeAnn (VerPermanent ver), PermConstraint ver, Typeable ver) => utemplate -> PermanentImpl ver -> Lambda () ()
type UStoreEpTraversal c a = (Generic a, GUStoreEpTraversal c (Rep a))
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Contracts.Upgradeable.StorageDriven.SduEntryPoint store arg)
instance GHC.Generics.Generic (Lorentz.Contracts.Upgradeable.StorageDriven.SduEntryPoint store arg)
instance GHC.Classes.Eq (Lorentz.Contracts.Upgradeable.StorageDriven.SduEntryPoint store arg)
instance Lorentz.Contracts.Upgradeable.StorageDriven.UStoreEpTraversal c a => Lorentz.Contracts.Upgradeable.StorageDriven.GUStoreEpTraversal c (GHC.Generics.S1 i (GHC.Generics.Rec0 a))
instance Lorentz.Contracts.Upgradeable.StorageDriven.GUStoreEpTraversal c x => Lorentz.Contracts.Upgradeable.StorageDriven.GUStoreEpTraversal c (GHC.Generics.D1 i x)
instance Lorentz.Contracts.Upgradeable.StorageDriven.GUStoreEpTraversal c x => Lorentz.Contracts.Upgradeable.StorageDriven.GUStoreEpTraversal c (GHC.Generics.C1 i x)
instance (Lorentz.Contracts.Upgradeable.StorageDriven.GUStoreEpTraversal c x, Lorentz.Contracts.Upgradeable.StorageDriven.GUStoreEpTraversal c y) => Lorentz.Contracts.Upgradeable.StorageDriven.GUStoreEpTraversal c (x GHC.Generics.:*: y)
instance Lorentz.Contracts.Upgradeable.StorageDriven.GUStoreEpTraversal c (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just fieldName) _1 _2 _3) (GHC.Generics.Rec0 (k Lorentz.UStore.Types.|~> v)))
instance Lorentz.Contracts.Upgradeable.StorageDriven.GUStoreEpTraversal c (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just fieldName) _1 _2 _3) (GHC.Generics.Rec0 (Lorentz.UStore.Types.UStoreFieldExt m v)))
instance (GHC.TypeLits.KnownSymbol fieldName, Fcf.Core.Eval (Util.Fcf.ApplyConstraints c arg)) => Lorentz.Contracts.Upgradeable.StorageDriven.GUStoreEpTraversal c (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just fieldName) _1 _2 _3) (GHC.Generics.Rec0 (Lorentz.UStore.Types.UStoreFieldExt Lorentz.Contracts.Upgradeable.StorageDriven.UMarkerEntryPoint (Lorentz.Contracts.Upgradeable.StorageDriven.SduEntryPoint store arg))))
instance Lorentz.UStore.Types.KnownUStoreMarker Lorentz.Contracts.Upgradeable.StorageDriven.UMarkerEntryPoint
instance Control.Lens.Wrapped.Wrapped (Lorentz.Contracts.Upgradeable.StorageDriven.SduEntryPoint arg store)


-- | Operations related to upgradeable contracts.
module Lorentz.Contracts.Upgradeable.Client

-- | Failed to code UStore value to given type.
data UStoreValueUnpackFailed
UStoreValueUnpackFailed :: ByteString -> Text -> UStoreValueUnpackFailed
data UStoreElemRef
UrField :: MText -> UStoreElemRef
UrSubmap :: MText -> SomeConstrainedValue PackedValScope' -> UStoreElemRef

-- | Read <tt>UStore</tt> value of given contract.
--   
--   This essentially requires contract having only one <tt>big_map bytes
--   bytes</tt> in storage.
readContractUStore :: forall v m. (UnpackedValScope v, HasTezosNodeRpc m) => Address -> UStoreElemRef -> m (Value v)

-- | Read an <tt>UStore</tt> entrypoint. For contracts which are filled
--   with storage-driven approach.
--   
--   Unlike <a>readContractUStore</a>, here we don't need to know exact
--   type of value (lambda) in order to unpack it, thus returning code in
--   untyped representation.
readContractUStoreEntrypoint :: HasTezosNodeRpc m => Address -> MText -> m [ExpandedOp]
instance (Data.Typeable.Internal.Typeable a, Michelson.Typed.Scope.PackedValScope a) => Lorentz.Contracts.Upgradeable.Client.PackedValScope' a
instance GHC.Exception.Type.Exception Lorentz.Contracts.Upgradeable.Client.UStoreValueUnpackFailed
instance GHC.Show.Show Lorentz.Contracts.Upgradeable.Client.UStoreValueUnpackFailed
instance Formatting.Buildable.Buildable Lorentz.Contracts.Upgradeable.Client.UStoreValueUnpackFailed

module Lorentz.Contracts.Upgradeable.Test

-- | Test all properties of upgradeable contract.
testUpgradeableContractDoc :: [DocTest]

-- | Check that contract documentation mentions version only once.
testSingleVersion :: DocTest


-- | UpgradeableCounter demonstrates the implementation of a simple
--   contract that has upgradeable storage, interface, and implementation.
--   
--   In the first version it stores a Natural and allows to add some value
--   to it or multiply the current value by a certain natural number.
--   
--   The second version changes the type of the stored value to Integer,
--   and instead of providing Mul Natural and Add Natural endpoints, it
--   just allows to increment or decrement the current value.
--   
--   While the contract does not have any advanced functionality, it
--   provides a birds-eye view on all the aspects of the upgradeable
--   contracts concept and serves as an example on how to apply this
--   concept.
module Lorentz.Contracts.UpgradeableCounter

-- | Parameter of upgradeable contract. It contains, among others:
--   
--   <ol>
--   <li>Entrypoint for running one of upgradeable entrypoints.</li>
--   <li>Entrypoint for running one of permanent entrypoints, suitable e.g.
--   for implementing interfaces. 3a. Entrypoint for upgrade in a single
--   call. 3b. Entrypoints for entrypoint-wise upgrade.</li>
--   </ol>
data Parameter (ver :: VersionKind)
Run :: VerParam ver -> Parameter
RunPerm :: VerPermanent ver -> Parameter
Upgrade :: OneShotUpgradeParameters ver -> Parameter
GetVersion :: View () Version -> Parameter
SetAdministrator :: Address -> Parameter
EpwBeginUpgrade :: ("current" :! Version, "new" :! Version) -> Parameter
EpwApplyMigration :: MigrationScriptFrom (VerUStoreTemplate ver) -> Parameter
EpwSetCode :: SomeUContractRouter -> Parameter
EpwSetPermCode :: SomePermanentImpl (VerPermanent ver) -> Parameter
EpwFinishUpgrade :: Parameter
data Storage (ver :: VersionKind)
type CounterV0 = EmptyContractVersion Empty
upgradeableCounterContract :: UpgradeableContract CounterV0
mkEmptyStorage :: (VerInterface ver ~ '[], VerUStoreTemplate ver ~ ()) => Address -> Storage ver

module Lorentz.Contracts.UpgradeableCounter.V1
data CounterV1 :: VersionKind
migrate :: MigrationScript () UStoreTemplateV1

-- | Migrations represent entrypoint-wise upgrades. Each migration puts an
--   implementation of a method to UStore. The contract code itself
--   (<a>epwServe</a>) does not do anything special except for taking these
--   lambdas out of the big map.
migrations :: [MigrationScript () UStoreTemplateV1]
counterContract :: UContractRouter CounterV1
counterUpgradeParameters :: EpwUpgradeParameters [] CounterV0 CounterV1
type UStoreV1 = UStore UStoreTemplateV1
data UStoreTemplateV1
instance GHC.Generics.Generic Lorentz.Contracts.UpgradeableCounter.V1.UStoreTemplateV1
instance GHC.Classes.Eq Lorentz.Contracts.UpgradeableCounter.V1.UStoreTemplateV1
instance Lorentz.Contracts.Upgradeable.Common.Base.KnownContractVersion Lorentz.Contracts.UpgradeableCounter.V1.CounterV1

module Lorentz.Contracts.UpgradeableCounter.V2
type Interface = ["inc" ?: (), "dec" ?: (), "getCounterValue" ?: Void_ () Integer]
type UStoreV2 = UStore UStoreTemplateV2
data CounterV2 :: VersionKind
migrate :: MigrationScript UStoreTemplateV1 UStoreTemplateV2
migrations :: [MigrationScript UStoreTemplateV1 UStoreTemplateV2]
counterContract :: UContractRouter CounterV2
counterUpgradeParameters :: EpwUpgradeParameters [] CounterV1 CounterV2
instance GHC.Generics.Generic Lorentz.Contracts.UpgradeableCounter.V2.UStoreTemplateV2
instance GHC.Classes.Eq Lorentz.Contracts.UpgradeableCounter.V2.UStoreTemplateV2
instance Lorentz.Contracts.Upgradeable.Common.Base.KnownContractVersion Lorentz.Contracts.UpgradeableCounter.V2.CounterV2


-- | UpgradeableCounterSdu demonstrates the implementation of a simple
--   contract that has upgradeable storage, interface, and implementation
--   and uses storage-driven upgrades. Aside from the latter, this contract
--   is similar to <a>UpgradeableCounter</a>.
--   
--   In the first version it stores a Natural and allows to add some value
--   to it.
--   
--   The second version changes the type of the stored value to Integer,
--   and instead of providing Add Natural and Inc () endpoints, it just
--   allows to increment or decrement the current value.
--   
--   While the contract does not have any advanced functionality, it
--   provides a birds-eye view on all the aspects of the upgradeable
--   contracts concept and serves as an example on how to apply this
--   concept.
module Lorentz.Contracts.UpgradeableCounterSdu

-- | Version identifier for this contract.
--   
--   It a bit differs from how we do in other contracts - this type is
--   supposed to be used in all versions of the contract, but it has type
--   parameter which is supposed to designate contract version.
data CounterSduV (v :: Nat) :: VersionKind

-- | Parameter of upgradeable contract. It contains, among others:
--   
--   <ol>
--   <li>Entrypoint for running one of upgradeable entrypoints.</li>
--   <li>Entrypoint for running one of permanent entrypoints, suitable e.g.
--   for implementing interfaces. 3a. Entrypoint for upgrade in a single
--   call. 3b. Entrypoints for entrypoint-wise upgrade.</li>
--   </ol>
data Parameter (ver :: VersionKind)
Run :: VerParam ver -> Parameter
RunPerm :: VerPermanent ver -> Parameter
Upgrade :: OneShotUpgradeParameters ver -> Parameter
GetVersion :: View () Version -> Parameter
SetAdministrator :: Address -> Parameter
EpwBeginUpgrade :: ("current" :! Version, "new" :! Version) -> Parameter
EpwApplyMigration :: MigrationScriptFrom (VerUStoreTemplate ver) -> Parameter
EpwSetCode :: SomeUContractRouter -> Parameter
EpwSetPermCode :: SomePermanentImpl (VerPermanent ver) -> Parameter
EpwFinishUpgrade :: Parameter
data Storage (ver :: VersionKind)
data Permanent
GetCounter :: Void_ () Integer -> Permanent
GetNothing :: Empty -> Permanent
upgradeableCounterContractSdu :: UpgradeableContract (CounterSduV 0)
mkEmptyStorage :: (VerInterface ver ~ '[], VerUStoreTemplate ver ~ ()) => Address -> Storage ver
instance Lorentz.TypeAnns.HasTypeAnn Lorentz.Contracts.UpgradeableCounterSdu.Permanent
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.UpgradeableCounterSdu.Permanent
instance GHC.Generics.Generic Lorentz.Contracts.UpgradeableCounterSdu.Permanent
instance Lorentz.Contracts.Upgradeable.Common.Base.KnownContractVersion (Lorentz.Contracts.UpgradeableCounterSdu.CounterSduV 0)
instance Lorentz.EntryPoints.Core.ParameterHasEntryPoints Lorentz.Contracts.UpgradeableCounterSdu.Permanent
instance Michelson.Typed.Haskell.Doc.TypeHasDoc Lorentz.Contracts.UpgradeableCounterSdu.Permanent

module Lorentz.Contracts.UpgradeableCounterSdu.V1
counterContract :: UContractRouter (CounterSduV 1)

-- | This function migrates the storage from an empty one to UStorage, i.e.
--   it populates the empty BigMap with initial values for each field and
--   entrypoints. The result is expected to adhere to V1.UStoreTemplate.
migration :: UStoreMigration () UStoreTemplate
counterUpgradeParameters :: EpwUpgradeParameters Identity (CounterSduV 0) (CounterSduV 1)
counterDoc :: ContractDoc
counterDocRendered :: LText
runGetCounterValue :: Entrypoint (Void_ () Natural) UStorage
runAdd :: Entrypoint Natural UStorage
permImpl :: PermanentImpl (CounterSduV 1)
instance GHC.Generics.Generic Lorentz.Contracts.UpgradeableCounterSdu.V1.UStoreTemplate
instance GHC.Classes.Eq Lorentz.Contracts.UpgradeableCounterSdu.V1.UStoreTemplate
instance Lorentz.Contracts.Upgradeable.Common.Base.KnownContractVersion (Lorentz.Contracts.UpgradeableCounterSdu.CounterSduV 1)

module Lorentz.Contracts.UpgradeableCounterSdu.V2

-- | Version identifier for this contract.
--   
--   It a bit differs from how we do in other contracts - this type is
--   supposed to be used in all versions of the contract, but it has type
--   parameter which is supposed to designate contract version.
data CounterSduV (v :: Nat) :: VersionKind
counterContract :: UContractRouter (CounterSduV 2)
migration :: UStoreMigration (VerUStoreTemplate (CounterSduV 1)) UStoreTemplate
counterUpgradeParameters :: EpwUpgradeParameters Identity (CounterSduV 1) (CounterSduV 2)
counterUpgradeParametersFromV0 :: EpwUpgradeParameters Identity (CounterSduV 0) (CounterSduV 2)
counterRollbackParameters :: EpwUpgradeParameters Identity (CounterSduV 2) (CounterSduV 1)
instance GHC.Generics.Generic Lorentz.Contracts.UpgradeableCounterSdu.V2.UStoreTemplate
instance GHC.Classes.Eq Lorentz.Contracts.UpgradeableCounterSdu.V2.UStoreTemplate
instance GHC.Generics.Generic (Lorentz.Contracts.UpgradeableCounterSdu.V2.UStoreEntrypoints store)
instance GHC.Classes.Eq (Lorentz.Contracts.UpgradeableCounterSdu.V2.UStoreEntrypoints store)
instance Lorentz.Contracts.Upgradeable.Common.Base.KnownContractVersion (Lorentz.Contracts.UpgradeableCounterSdu.CounterSduV 2)


-- | UpgradeableUnsafeLedger demonstrates a real-world use case of an
--   upgradeable contract. Its V1 contains a bug that makes it return an
--   incorrect totalSupply. Fortunately, we can upgrade the contract and
--   fix the bug. This contract does not use entrypoint-wise upgrades.
--   Instead, it upgrades atomically in one transaction. For non-atomic
--   upgrades please see the UpgradeableCounter example.
module Lorentz.Contracts.UpgradeableUnsafeLedger

-- | Parameter of upgradeable contract. It contains, among others:
--   
--   <ol>
--   <li>Entrypoint for running one of upgradeable entrypoints.</li>
--   <li>Entrypoint for running one of permanent entrypoints, suitable e.g.
--   for implementing interfaces. 3a. Entrypoint for upgrade in a single
--   call. 3b. Entrypoints for entrypoint-wise upgrade.</li>
--   </ol>
data Parameter (ver :: VersionKind)
Run :: VerParam ver -> Parameter
RunPerm :: VerPermanent ver -> Parameter
Upgrade :: OneShotUpgradeParameters ver -> Parameter
GetVersion :: View () Version -> Parameter
SetAdministrator :: Address -> Parameter
EpwBeginUpgrade :: ("current" :! Version, "new" :! Version) -> Parameter
EpwApplyMigration :: MigrationScriptFrom (VerUStoreTemplate ver) -> Parameter
EpwSetCode :: SomeUContractRouter -> Parameter
EpwSetPermCode :: SomePermanentImpl (VerPermanent ver) -> Parameter
EpwFinishUpgrade :: Parameter
data Storage (ver :: VersionKind)
upgradeableUnsafeLedgerContract :: InitUpgradeableContract Permanent
mkEmptyStorage :: (VerInterface ver ~ '[], VerUStoreTemplate ver ~ ()) => Address -> Storage ver


-- | A buggy implementation of Unsafe ledger, returns balances multiplied
--   by 2
module Lorentz.Contracts.UpgradeableUnsafeLedger.V1
data UnsafeLedgerV1 :: VersionKind
type Interface = ["transfer" ?: TransferParams, "getTotalSupply" ?: Void_ () Natural, "getBalance" ?: Void_ Address (Maybe Natural)]

-- | Like in UpgradeableCounter, this function populates the empty UStore_
--   with entries and initial values for each field. The result is expected
--   to adhere to V1.UStoreTemplate
migrate :: '[UStore_] :-> '[UStore_]
unsafeLedgerContract :: UContractRouter UnsafeLedgerV1
data UStoreTemplate
type UStoreV1 = UStore UStoreTemplate
type TransferParams = (Address, Natural)
transfer :: '[TransferParams, UStoreV1] :-> '[([Operation], UStoreV1)]
getTotalSupply :: '[Void_ () Natural, UStoreV1] :-> '[([Operation], UStoreV1)]
instance GHC.Generics.Generic Lorentz.Contracts.UpgradeableUnsafeLedger.V1.UStoreTemplate
instance GHC.Classes.Eq Lorentz.Contracts.UpgradeableUnsafeLedger.V1.UStoreTemplate
instance Lorentz.Contracts.Upgradeable.Common.Base.KnownContractVersion Lorentz.Contracts.UpgradeableUnsafeLedger.V1.UnsafeLedgerV1


-- | The implementation of Unsafe ledger with V1 balance bug fixed
module Lorentz.Contracts.UpgradeableUnsafeLedger.V2
data UnsafeLedgerV2 :: VersionKind

-- | Storage migration function. Since the storage is the same, there's
--   nothing to migrate
migrate :: '[UStore_] :-> '[UStore_]

-- | The second version of the UpgradeableUnsafeLedger. Most of the
--   functions are from V1 except for getBalance.
unsafeLedgerContract :: UContractRouter UnsafeLedgerV2
instance Lorentz.Contracts.Upgradeable.Common.Base.KnownContractVersion Lorentz.Contracts.UpgradeableUnsafeLedger.V2.UnsafeLedgerV2


-- | This module contains common functions and types related to
--   user-defined upgrades. It intentionally does not include mint- and
--   burn-related functionality because these should be handled by
--   particular token implementations (V2 and V1 correspondingly).
--   
--   Note that the naming in this module is different from
--   Lorentz.Contracts.Upgradeable: by "migration" here we mean the process
--   of transferring the value from an old contract to the new one rather
--   than applying a transformation to storage.
module Lorentz.Contracts.UserUpgradeable.Migrations
type MigrationTarget = FutureContract (Address, Natural)

-- | Forges a call to the new version; the forged operation contans the
--   address of the sender, and the amount of tokens to mint.
callMigrationTarget :: forall storage. HasMigrationTarget storage => '[Natural, storage] :-> '[([Operation], storage)]

-- | Starts a migration from an old version of a contract to a new one.
initiateMigration :: forall storage. (HasAdmin storage, HasMigrationTarget storage) => '[MigrationTarget, storage] :-> '[([Operation], storage)]
instance Lorentz.Errors.CustomErrorHasDoc "alreadyMigrating"
instance Lorentz.Errors.CustomErrorHasDoc "nowhereToMigrate"
instance Lorentz.Errors.CustomErrorHasDoc "migrationTargetDoesNotExist"


-- | The first version of a minimal user-upgradeable ledger. It does not
--   offer common ledger functions like Transfer<i>GetTotalSupply</i>etc.
--   to demonstrate a concept and keep the code consise.
--   
--   Note that the naming in this module is different from
--   Lorentz.Contracts.Upgradeable: by "migration" here we mean the process
--   of transferring the value from an old contract to the new one rather
--   than applying a transformation to storage. Thus, MigrationScript here
--   is a lambda that forges an operation to migrate user's funds rather
--   than a function that upgrades storage in-place.
module Lorentz.Contracts.UserUpgradeable.V1
data Parameter

-- | Token admin calls this entrypoint and provides a lambda to forge
--   V2.MigrateFrom operation.
InitiateMigration :: MigrationTarget -> Parameter

-- | Users are supposed to call this entrypoint if they want to upgrade
--   their tokens.
MigrateMyTokens :: Natural -> Parameter

-- | Returns the balance of a holder.
GetBalance :: View Address Natural -> Parameter
data Storage
Storage :: BigMap Address Natural -> Address -> Maybe MigrationTarget -> Storage
[ledger] :: Storage -> BigMap Address Natural
[admin] :: Storage -> Address
[migrationTarget] :: Storage -> Maybe MigrationTarget
mkStorage :: BigMap Address Natural -> Address -> Storage
userUpgradeableContract :: '[(Parameter, Storage)] :-> '[([Operation], Storage)]
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.UserUpgradeable.V1.Parameter
instance GHC.Generics.Generic Lorentz.Contracts.UserUpgradeable.V1.Parameter
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.UserUpgradeable.V1.Storage
instance GHC.Generics.Generic Lorentz.Contracts.UserUpgradeable.V1.Storage
instance Lorentz.EntryPoints.Core.ParameterHasEntryPoints Lorentz.Contracts.UserUpgradeable.V1.Parameter
instance Lorentz.Errors.CustomErrorHasDoc "userUpgradable'notEnoughTokens"


-- | The second version of a minimal user-upgradeable ledger. This version
--   is not designed to be upgraded further  it lacks InitiateMigration
--   and MigrateMyTokens entrypoints. However, it has MigrateFrom (callable
--   from V1), and mints new tokens when a user calls V1.MigrateMyTokens.
--   Other functions (either upgradeability-related or standard
--   Transfer/GetTotalSupply may be added if deemed desirable).
--   
--   Note that the naming in this module is different from
--   Lorentz.Contracts.Upgradeable: by "migration" here we mean the process
--   of transferring the value from an old contract to the new one rather
--   than applying a transformation to storage. Thus, MigrationScript here
--   is a lambda that forges an operation to migrate user's funds rather
--   than a function that upgrades storage in-place.
module Lorentz.Contracts.UserUpgradeable.V2
data Parameter

-- | When called by V1, mints new tokens to Address
MigrateFrom :: (Address, Natural) -> Parameter

-- | Returns the balance of a holder.
GetBalance :: View Address Natural -> Parameter
data Storage
Storage :: Map Address Natural -> Maybe (TAddress Parameter) -> Maybe MigrationTarget -> Storage

-- | We use a Map instead of a BigMap to simplify the implementation a bit.
[ledger] :: Storage -> Map Address Natural
[previousVersion] :: Storage -> Maybe (TAddress Parameter)
[migrationTarget] :: Storage -> Maybe MigrationTarget
mkStorage :: TAddress Parameter -> Storage
userUpgradeableContract :: '[(Parameter, Storage)] :-> '[([Operation], Storage)]
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.UserUpgradeable.V2.Parameter
instance GHC.Generics.Generic Lorentz.Contracts.UserUpgradeable.V2.Parameter
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.UserUpgradeable.V2.Storage
instance GHC.Generics.Generic Lorentz.Contracts.UserUpgradeable.V2.Storage
instance Lorentz.EntryPoints.Core.ParameterHasEntryPoints Lorentz.Contracts.UserUpgradeable.V2.Parameter
instance Lorentz.Errors.CustomErrorHasDoc "userUpgradable'unauthorizedMigrateFrom"
