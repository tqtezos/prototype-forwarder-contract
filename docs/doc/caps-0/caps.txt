-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monadic capabilities with late binding
--   
--   Monadic capabilities with late binding
@package caps
@version 0


-- | Monadic capabilities are additional methods for a base monad. For
--   instance, when our base monad is <a>IO</a>, our capabilities might
--   include logging, networking, database access, and so on.
--   
--   This framework allows mutually recursive late-bound capabilities with
--   runtime dispatch and a type-safe interface.
--   
--   A capability is defined as a record type with methods parametrized
--   over a base monad:
--   
--   <pre>
--   data Logging m =
--     Logging
--       { _logError :: String -&gt; m (),
--         _logDebug :: String -&gt; m ()
--       }
--   </pre>
--   
--   We can define implementations as values of this record type:
--   
--   <pre>
--   loggingDummy :: Monad m =&gt; CapImpl Logging '[] m
--   loggingDummy = CapImpl $ Logging (\_ -&gt; return ()) (\_ -&gt; return ())
--   
--   loggingIO :: MonadIO m =&gt; CapImpl Logging '[] m
--   loggingIO = CapImpl $
--     Logging
--       { _logError = \msg -&gt; liftIO . putStrLn $ "[Error] " ++ msg
--         _logDebug = \msg -&gt; liftIO . putStrLn $ "[Debug] " ++ msg
--       }
--   </pre>
--   
--   The dictionary is wrapped in <a>CapImpl</a> to guarantee that it is
--   sufficiently polymorphic (this is required to support simultaneous use
--   of monadic actions in negative position and capability extension).
--   
--   Then we want to use this capability in the <a>CapsT</a> monad (which
--   is nothing more but a synonym for <a>ReaderT</a> of
--   <a>Capabilities</a>), and for this we define a helper per method:
--   
--   <pre>
--   logError :: HasCap Logging caps =&gt; String -&gt; CapsT caps m ()
--   logError message = withCap $ \cap -&gt; _logError cap message
--   
--   logDebug :: HasCap Logging caps =&gt; String -&gt; CapsT caps m ()
--   logDebug message = withCap $ \cap -&gt; _logDebug cap message
--   </pre>
--   
--   We can define other capabilities in a similar manner:
--   
--   <pre>
--   data Networking m =
--     Networking
--       { _sendRequest :: ByteString -&gt; m ByteString }
--   
--   data FileStorage m =
--     FileStorage
--       { _readFile :: FilePath -&gt; m ByteString,
--         _writeFile :: FilePath -&gt; ByteString -&gt; m ()
--       }
--   </pre>
--   
--   Implementations of capabilities may depend on other capabilities,
--   which are listed in their signature. For instance, this is how we can
--   define the <tt>FileStorage</tt> capability using the <tt>Logging</tt>
--   capability:
--   
--   <pre>
--   fileStorageIO :: MonadIO m =&gt; CapImpl FileStorage '[Logging] m
--   fileStorageIO = CapImpl $
--     FileStorage
--       { _readFile = \path -&gt; do
--           logDebug $ "readFile " ++ path
--           lift $ ByteString.readFile path
--         _writeFile = \path content -&gt; do
--           logDebug $
--             "writeFile " ++ path ++
--             " (" ++ show (ByteString.length content) ++
--             " bytes)"
--           lift $ ByteString.writeFile path content
--       }
--   </pre>
--   
--   Here the <tt>fileStorageIO</tt> implementation requires a logging
--   capability, but it's not specified which one.
--   
--   When we decided what set of capabilities our application needs, we can
--   put them together in a <a>Capabilities</a> map and run the application
--   with this map in a <a>ReaderT</a> context:
--   
--   <pre>
--   caps = buildCaps $
--     AddCap loggingIO $
--     AddCap fileStorageIO $
--     BaseCaps emptyCaps
--   
--   flip runReaderT caps $ do
--     config &lt;- readFile "config.yaml"
--     ...
--   </pre>
--   
--   Capabilities passed to <a>buildCaps</a> can depend on each other. The
--   order does not matter (although it is reflected in the types), and
--   duplicate capabilities are disallowed.
--   
--   We can override a capability locally:
--   
--   <pre>
--   do
--     config &lt;- readFile "config.yaml"
--     withReaderT (overrideCap loggingDummy) $ do
--       -- logging is disabled here
--       writeFile "config-backup.yaml" config
--       ...
--   </pre>
--   
--   or we can add more capabilities:
--   
--   <pre>
--   do
--     config &lt;- readFile "config.yaml"
--     networkingImpl &lt;- parseNetworkingConfig config
--     withReaderT (addCap networkingImpl) $ do
--       -- networking capability added
--       resp &lt;- sendRequest req
--       ...
--   </pre>
module Monad.Capabilities

-- | <tt><a>Capabilities</a> caps m</tt> is a map of capabilities
--   <tt>caps</tt> over a base monad <tt>m</tt>. Consider the following
--   capabilities:
--   
--   <pre>
--   data X m = X (String -&gt; m String)
--   data Y m = Y (Int -&gt; m Bool)
--   </pre>
--   
--   We can construct a map of capabilities with the following type:
--   
--   <pre>
--   capsXY :: Capabilities '[X, Y] IO
--   </pre>
--   
--   In this case, <tt>capsXY</tt> would be a map with two elements, one at
--   key <tt>X</tt> and one at key <tt>Y</tt>. The types of capabilities
--   themselves serve as keys.
--   
--   <a>Capabilities</a> is a heterogeneous collection, meaning that its
--   values have different types. The type of a value is determined by the
--   key:
--   
--   <pre>
--    X:   X (\_ -&gt; return "hi") :: X (CapsT '[X, Y] IO)
--    Y:   Y (\_ -&gt; return True) :: Y (CapsT '[X, Y] IO)
--   ----  ---------------------    --------------------
--   keys         values              types of values
--   </pre>
--   
--   Notice that stored dictionaries are parametrized not just by the base
--   monad <tt>IO</tt>, but with the <a>CapsT</a> transformer on top. This
--   means that each capability has access to all other capabilities and
--   itself.
data Capabilities (caps :: [CapK]) (m :: MonadK)

-- | The <a>CapsT</a> transformer adds access to capabilities. This is a
--   convenience synonym for <a>ReaderT</a> of <a>Capabilities</a>, and all
--   <a>ReaderT</a> functions (<a>runReaderT</a>, <a>withReaderT</a>) can
--   be used with it.
type CapsT caps m = ReaderT (Capabilities caps m) m
emptyCaps :: Capabilities '[] m

-- | Build a map of capabilities from individual implementations:
--   
--   <pre>
--   capsXY :: Capabilities '[X, Y] IO
--   capsXY = buildCaps $
--       AddCap xImpl $
--       AddCap yImpl $
--       BaseCaps emptyCaps
--   </pre>
buildCaps :: forall caps m. CapabilitiesBuilder caps caps m -> Capabilities caps m

-- | <a>CapabilitiesBuilder</a> is a type to extend capabilities.
--   
--   The <tt>allCaps</tt> parameter is a list of capabilities that will be
--   provided to <a>buildCaps</a> eventually, when the building process is
--   done. The <tt>caps</tt> parameter is the part of capabilities that was
--   constructed so far. The builder is considered complete when
--   <tt>allCaps ~ caps</tt>, only then it can be passed to
--   <a>buildCaps</a>.
data CapabilitiesBuilder (allCaps :: [CapK]) (caps :: [CapK]) (m :: MonadK)
[AddCap] :: (Typeable cap, HasCaps icaps allCaps, HasNoCap cap caps) => CapImpl cap icaps m -> CapabilitiesBuilder allCaps caps m -> CapabilitiesBuilder allCaps (cap : caps) m
[BaseCaps] :: Capabilities caps m -> CapabilitiesBuilder allCaps caps m

-- | The <a>CapImpl</a> newtype guarantees that the wrapped capability
--   implementation is sufficiently polymorphic so that required subtyping
--   properties hold in methods that take monadic actions as input
--   (negative position).
--   
--   This rules out using <a>addCap</a>, <a>insertCap</a>, and
--   <a>buildCaps</a> inside capability implementations in an unsafe
--   manner.
data CapImpl cap icaps m
[CapImpl] :: WithSpine icaps => {getCapImpl :: forall caps. HasCaps icaps caps => cap (CapsT caps m)} -> CapImpl cap icaps m

-- | Lookup a capability in a <a>Capabilities</a> map. The <a>HasCap</a>
--   constraint guarantees that the lookup does not fail.
getCap :: forall cap m caps. (Typeable cap, HasCap cap caps) => Capabilities caps m -> cap (CapsT caps m)

-- | Override the implementation of an existing capability.
overrideCap :: (Typeable cap, HasCap cap caps, HasCaps icaps caps) => CapImpl cap icaps m -> Capabilities caps m -> Capabilities caps m

-- | Extend the set of capabilities. In case the capability is already
--   present, a type error occurs.
addCap :: (Typeable cap, HasNoCap cap caps, HasCaps icaps (cap : caps)) => CapImpl cap icaps m -> Capabilities caps m -> Capabilities (cap : caps) m

-- | Extend the set of capabilities. In case the capability is already
--   present, it will be overriden (as with <a>overrideCap</a>), but occur
--   twice in the type.
insertCap :: (Typeable cap, HasCaps icaps (cap : caps)) => CapImpl cap icaps m -> Capabilities caps m -> Capabilities (cap : caps) m

-- | Extract a capability from <a>CapsT</a> and provide it to a
--   continuation.
withCap :: (Typeable cap, HasCap cap caps) => (cap (CapsT caps m) -> CapsT caps m a) -> CapsT caps m a

-- | Determine at runtime whether 'HasCap cap caps' or 'HasNoCap cap caps'
--   holds.
checkCap :: forall cap caps m. Typeable cap => Capabilities caps m -> HasCapDecision cap caps

-- | Override the implementation of an existing capability using the
--   previous implementation. This is a more efficient equivalent to
--   extracting a capability with <a>getCap</a>, adjusting it with a
--   function, and putting it back with <a>overrideCap</a>.
adjustCap :: forall cap caps m. (Typeable cap, HasCap cap caps) => (forall caps'. cap (CapsT caps' m) -> cap (CapsT caps' m)) -> Capabilities caps m -> Capabilities caps m

-- | The <a>Context</a> capability is used to model the <tt>Reader</tt>
--   effect within the capabilities framework.
newtype Context x (m :: MonadK)
Context :: x -> Context x

-- | The <a>HasContext</a> constraint is a shorthand for <a>HasCap</a> of
--   <a>Context</a>.
class (Typeable x, HasCap (Context x) caps) => HasContext x caps

-- | Initialize a <a>Context</a> capability.
newContext :: forall x m. x -> CapImpl (Context x) '[] m

-- | Retrieve the context value. Moral equivalent of <a>ask</a>.
askContext :: (HasContext x caps, Applicative m) => CapsT caps m x

-- | Execute a computation with a modified context value. Moral equivalent
--   of <a>local</a>.
localContext :: forall x caps m a. HasContext x caps => (x -> x) -> CapsT caps m a -> CapsT caps m a

-- | Ensure that the <tt>caps</tt> list has an element <tt>cap</tt>.
type family HasCap cap caps :: Constraint

-- | Ensure that the <tt>caps</tt> list subsumes <tt>icaps</tt>. It is
--   equivalent to a <tt>HasCap icap caps</tt> constraint for each
--   <tt>icap</tt> in <tt>icaps</tt>.
type family HasCaps icaps caps :: Constraint

-- | Ensure that the <tt>caps</tt> list does not have an element
--   <tt>cap</tt>.
type family HasNoCap cap caps :: Constraint

-- | Evidence that <tt>cap</tt> is present or absent in <tt>caps</tt>.
data HasCapDecision cap caps
[HasNoCap] :: HasNoCap cap caps => HasCapDecision cap caps
[HasCap] :: HasCap cap caps => HasCapDecision cap caps
makeCap :: Name -> DecsQ
instance GHC.Show.Show (Monad.Capabilities.Capabilities caps m)
instance (Data.Typeable.Internal.Typeable x, Monad.Capabilities.HasCap (Monad.Capabilities.Context x) caps) => Monad.Capabilities.HasContext x caps
instance forall k (cap :: k) (caps :: [k]). GHC.Show.Show (Monad.Capabilities.HasCapDecision cap caps)
instance Monad.Capabilities.WithSpine '[]
instance forall k (xs :: [k]) (x :: k). Monad.Capabilities.WithSpine xs => Monad.Capabilities.WithSpine (x : xs)
