-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinator-based type-safe formatting (like printf() or FORMAT)
--   
--   Combinator-based type-safe formatting (like printf() or FORMAT),
--   modelled from the HoleyMonoids package.
@package formatting
@version 6.3.7


-- | Types that can be rendered to a <a>Builder</a>.
module Formatting.Buildable

-- | The class of types that can be rendered to a <a>Builder</a>.
class Buildable p
build :: Buildable p => p -> Builder
instance Formatting.Buildable.Buildable Data.Text.Internal.Builder.Builder
instance Formatting.Buildable.Buildable Data.Void.Void
instance Formatting.Buildable.Buildable Data.Text.Internal.Lazy.Text
instance Formatting.Buildable.Buildable Data.Text.Internal.Text
instance Formatting.Buildable.Buildable GHC.Types.Char
instance Formatting.Buildable.Buildable [GHC.Types.Char]
instance GHC.Real.Integral a => Formatting.Buildable.Buildable (Data.Text.Format.Types.Hex a)
instance Formatting.Buildable.Buildable GHC.Int.Int8
instance Formatting.Buildable.Buildable GHC.Int.Int16
instance Formatting.Buildable.Buildable GHC.Int.Int32
instance Formatting.Buildable.Buildable GHC.Types.Int
instance Formatting.Buildable.Buildable GHC.Int.Int64
instance Formatting.Buildable.Buildable GHC.Integer.Type.Integer
instance Data.Fixed.HasResolution a => Formatting.Buildable.Buildable (Data.Fixed.Fixed a)
instance Formatting.Buildable.Buildable GHC.Word.Word8
instance Formatting.Buildable.Buildable GHC.Word.Word16
instance Formatting.Buildable.Buildable GHC.Word.Word32
instance Formatting.Buildable.Buildable GHC.Types.Word
instance Formatting.Buildable.Buildable GHC.Word.Word64
instance (GHC.Real.Integral a, Formatting.Buildable.Buildable a) => Formatting.Buildable.Buildable (GHC.Real.Ratio a)
instance Formatting.Buildable.Buildable GHC.Types.Float
instance Formatting.Buildable.Buildable GHC.Types.Double
instance Formatting.Buildable.Buildable Data.Time.Clock.Internal.DiffTime.DiffTime
instance Formatting.Buildable.Buildable Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
instance Formatting.Buildable.Buildable Data.Time.Clock.Internal.UTCTime.UTCTime
instance Formatting.Buildable.Buildable Data.Time.Clock.Internal.UniversalTime.UniversalTime
instance Formatting.Buildable.Buildable Data.Time.Calendar.Days.Day
instance GHC.Show.Show a => Formatting.Buildable.Buildable (Data.Text.Format.Types.Shown a)
instance Formatting.Buildable.Buildable a => Formatting.Buildable.Buildable (GHC.Maybe.Maybe a)
instance Formatting.Buildable.Buildable Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance Formatting.Buildable.Buildable Data.Time.LocalTime.Internal.TimeZone.TimeZone
instance Formatting.Buildable.Buildable Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Formatting.Buildable.Buildable Data.Time.LocalTime.Internal.ZonedTime.ZonedTime
instance Formatting.Buildable.Buildable Foreign.Ptr.IntPtr
instance Formatting.Buildable.Buildable Foreign.Ptr.WordPtr
instance Formatting.Buildable.Buildable (GHC.Ptr.Ptr a)
instance Formatting.Buildable.Buildable GHC.Types.Bool
instance Formatting.Buildable.Buildable a => Formatting.Buildable.Buildable [a]


-- | Internal format starters.
module Formatting.Internal

-- | A formatter. When you construct formatters the first type parameter,
--   <tt>r</tt>, will remain polymorphic. The second type parameter,
--   <tt>a</tt>, will change to reflect the types of the data that will be
--   formatted. For example, in
--   
--   <pre>
--   myFormat :: Formatter r (Text -&gt; Int -&gt; r)
--   myFormat = "Person's name is " % text % ", age is " % hex
--   </pre>
--   
--   the first type parameter remains polymorphic, and the second type
--   parameter is <tt>Text -&gt; Int -&gt; r</tt>, which indicates that it
--   formats a <a>Text</a> and an <a>Int</a>.
--   
--   When you run the <a>Format</a>, for example with <a>format</a>, you
--   provide the arguments and they will be formatted into a string.
--   
--   <pre>
--   &gt; format ("Person's name is " % text % ", age is " % hex) "Dave" 54
--   "Person's name is Dave, age is 36"
--   </pre>
newtype Format r a
Format :: ((Builder -> r) -> a) -> Format r a
[runFormat] :: Format r a -> (Builder -> r) -> a

-- | Concatenate two formatters.
--   
--   <tt>formatter1 % formatter2</tt> is a formatter that accepts arguments
--   for <tt>formatter1</tt> and <tt>formatter2</tt> and concatenates their
--   results. For example
--   
--   <pre>
--   format1 :: Format r (Text -&gt; r)
--   format1 = "Person's name is " % text
--   </pre>
--   
--   <pre>
--   format2 :: Format r r
--   format2 = ", "
--   </pre>
--   
--   <pre>
--   format3 :: Format r (Int -&gt; r)
--   format3 = "age is " % hex
--   </pre>
--   
--   <pre>
--   myFormat :: Formatter r (Text -&gt; Int -&gt; r)
--   myFormat = format1 % format2 % format3
--   </pre>
--   
--   Notice how the argument types of <tt>format1</tt> and <tt>format3</tt>
--   are gathered into the type of <tt>myFormat</tt>.
--   
--   (This is actually the composition operator for <tt>Format'</tt>s
--   <a>Category</a> instance, but that is (at present) inconvenient to use
--   with regular <a>Prelude</a>. So this function is provided as a
--   convenience.)
(%) :: Format r a -> Format r' r -> Format r' a
infixr 9 %

-- | Function compose two formatters. Will feed the result of one formatter
--   into another.
(%.) :: Format r (Builder -> r') -> Format r' a -> Format r a
infixr 8 %.

-- | Don't format any data, just output a constant <a>Builder</a>.
now :: Builder -> Format r r

-- | Monadic indexed bind for holey monoids.
bind :: Format r a -> (Builder -> Format r' r) -> Format r' a

-- | Functorial map over a formatter's input. Example: <tt>format (mapf
--   (drop 1) string) "hello"</tt>
mapf :: (a -> b) -> Format r (b -> t) -> Format r (a -> t)

-- | Format a value of type <tt>a</tt> using a function of type <tt>a -&gt;
--   <a>Builder</a></tt>. For example, <tt>later (f :: Int -&gt;
--   Builder)</tt> produces <tt>Format r (Int -&gt; r)</tt>.
later :: (a -> Builder) -> Format r (a -> r)

-- | Run the formatter and return a lazy <a>Text</a> value.
format :: Format Text a -> a

-- | Run the formatter and return a strict <a>Text</a> value.
sformat :: Format Text a -> a

-- | Run the formatter and return a <a>Builder</a> value.
bprint :: Format Builder a -> a

-- | Run the formatter and print out the text to stdout.
fprint :: Format (IO ()) a -> a

-- | Run the formatter and put the output onto the given <a>Handle</a>.
hprint :: Handle -> Format (IO ()) a -> a

-- | Run the formatter and return a list of characters.
formatToString :: Format [Char] a -> a
instance GHC.Base.Functor (Formatting.Internal.Format r)
instance GHC.Base.Monoid (Formatting.Internal.Format r (a -> r))
instance GHC.Base.Semigroup (Formatting.Internal.Format r (a -> r))
instance (a Data.Type.Equality.~ r) => Data.String.IsString (Formatting.Internal.Format r a)
instance Control.Category.Category Formatting.Internal.Format


-- | Formatting functions.
module Formatting.Formatters

-- | Output a lazy text.
text :: Format r (Text -> r)

-- | Output a strict text.
stext :: Format r (Text -> r)

-- | Output a string.
string :: Format r (String -> r)

-- | Output a showable value (instance of <a>Show</a>) by turning it into
--   <a>Text</a>:
--   
--   <pre>
--   &gt;&gt;&gt; format ("Value number " % shown % " is " % shown % ".") 42 False
--   "Value number 42 is False."
--   </pre>
shown :: Show a => Format r (a -> r)

-- | Output a character.
char :: Format r (Char -> r)

-- | Build a builder.
builder :: Format r (Builder -> r)

-- | Like <a>const</a> but for formatters.
fconst :: Builder -> Format r (a -> r)

-- | Render an integral e.g. 123 -&gt; "123", 0 -&gt; "0".
int :: Integral a => Format r (a -> r)

-- | Render some floating point with the usual notation, e.g. 123.32 =&gt;
--   "123.32"
float :: Real a => Format r (a -> r)

-- | Render a floating point number using normal notation, with the given
--   number of decimal places.
fixed :: Real a => Int -> Format r (a -> r)

-- | Render a scientific number.
sci :: Format r (Scientific -> r)

-- | Render a scientific number with options.
scifmt :: FPFormat -> Maybe Int -> Format r (Scientific -> r)

-- | Render a floating point number using the smallest number of digits
--   that correctly represent it.
shortest :: Real a => Format r (a -> r)

-- | Group integral numbers, e.g. groupInt 2 <a>.</a> on 123456 -&gt;
--   "12.34.56".
groupInt :: (Buildable n, Integral n) => Int -> Char -> Format r (n -> r)

-- | Add commas to an integral, e.g 12000 -&gt; "12,000".
commas :: (Buildable n, Integral n) => Format r (n -> r)

-- | Add a suffix to an integral, e.g. 1st, 2nd, 3rd, 21st.
ords :: Integral n => Format r (n -> r)

-- | English plural suffix for an integral.
plural :: (Num a, Eq a) => Text -> Text -> Format r (a -> r)

-- | Shows the Int value of Enum instances using <a>fromEnum</a>.
--   
--   <pre>
--   &gt;&gt;&gt; format ("Got: " % char % " (" % asInt % ")") 'a' 'a'
--   "Got: a (97)"
--   </pre>
asInt :: Enum a => Format r (a -> r)

-- | Pad the left hand side of a string until it reaches k characters wide,
--   if necessary filling with character c.
left :: Buildable a => Int -> Char -> Format r (a -> r)

-- | Pad the right hand side of a string until it reaches k characters
--   wide, if necessary filling with character c.
right :: Buildable a => Int -> Char -> Format r (a -> r)

-- | Pad the left &amp; right hand side of a string until it reaches k
--   characters wide, if necessary filling with character c.
center :: Buildable a => Int -> Char -> Format r (a -> r)

-- | Fit in the given length, truncating on the left.
fitLeft :: Buildable a => Int -> Format r (a -> r)

-- | Fit in the given length, truncating on the right.
fitRight :: Buildable a => Int -> Format r (a -> r)

-- | Render an integral at base n.
base :: Integral a => Int -> Format r (a -> r)

-- | Render an integer using binary notation. (No leading 0b is added.)
--   Defined as <tt>bin = <a>base</a> 2</tt>.
bin :: Integral a => Format r (a -> r)

-- | Render an integer using octal notation. (No leading 0o is added.)
--   Defined as <tt>oct = <a>base</a> 8</tt>.
oct :: Integral a => Format r (a -> r)

-- | Render an integer using hexadecimal notation. (No leading 0x is
--   added.) Has a specialized implementation.
hex :: Integral a => Format r (a -> r)

-- | Render an integer using binary notation with a leading 0b.
prefixBin :: Integral a => Format r (a -> r)

-- | Render an integer using octal notation with a leading 0o.
prefixOct :: Integral a => Format r (a -> r)

-- | Render an integer using hexadecimal notation with a leading 0x.
prefixHex :: Integral a => Format r (a -> r)

-- | Renders a given byte count using an appropiate decimal binary suffix:
--   
--   <pre>
--   &gt;&gt;&gt; format (bytes shortest) 1024
--   "1KB"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; format (bytes (fixed 2 % " ")) (1024*1024*5)
--   "5.00 MB"
--   </pre>
bytes :: (Ord f, Integral a, Fractional f) => Format Builder (f -> Builder) -> Format r (a -> r)

-- | Build anything that implements the <a>Buildable</a> class.
build :: Buildable a => Format r (a -> r)

-- | The class of types that can be rendered to a <a>Builder</a>.
class Buildable p


-- | Combinator-based type-safe formatting (like printf() or FORMAT) for
--   Text.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; format ("Person's name is " % text % ", age is " % hex) "Dave" 54
--   </pre>
--   
--   See <a>Formatting.Formatters</a> for a complete list of formatting
--   combinators.
module Formatting

-- | A formatter. When you construct formatters the first type parameter,
--   <tt>r</tt>, will remain polymorphic. The second type parameter,
--   <tt>a</tt>, will change to reflect the types of the data that will be
--   formatted. For example, in
--   
--   <pre>
--   myFormat :: Formatter r (Text -&gt; Int -&gt; r)
--   myFormat = "Person's name is " % text % ", age is " % hex
--   </pre>
--   
--   the first type parameter remains polymorphic, and the second type
--   parameter is <tt>Text -&gt; Int -&gt; r</tt>, which indicates that it
--   formats a <a>Text</a> and an <a>Int</a>.
--   
--   When you run the <a>Format</a>, for example with <a>format</a>, you
--   provide the arguments and they will be formatted into a string.
--   
--   <pre>
--   &gt; format ("Person's name is " % text % ", age is " % hex) "Dave" 54
--   "Person's name is Dave, age is 36"
--   </pre>
data Format r a

-- | Concatenate two formatters.
--   
--   <tt>formatter1 % formatter2</tt> is a formatter that accepts arguments
--   for <tt>formatter1</tt> and <tt>formatter2</tt> and concatenates their
--   results. For example
--   
--   <pre>
--   format1 :: Format r (Text -&gt; r)
--   format1 = "Person's name is " % text
--   </pre>
--   
--   <pre>
--   format2 :: Format r r
--   format2 = ", "
--   </pre>
--   
--   <pre>
--   format3 :: Format r (Int -&gt; r)
--   format3 = "age is " % hex
--   </pre>
--   
--   <pre>
--   myFormat :: Formatter r (Text -&gt; Int -&gt; r)
--   myFormat = format1 % format2 % format3
--   </pre>
--   
--   Notice how the argument types of <tt>format1</tt> and <tt>format3</tt>
--   are gathered into the type of <tt>myFormat</tt>.
--   
--   (This is actually the composition operator for <tt>Format'</tt>s
--   <a>Category</a> instance, but that is (at present) inconvenient to use
--   with regular <a>Prelude</a>. So this function is provided as a
--   convenience.)
(%) :: Format r a -> Format r' r -> Format r' a
infixr 9 %

-- | Function compose two formatters. Will feed the result of one formatter
--   into another.
(%.) :: Format r (Builder -> r') -> Format r' a -> Format r a
infixr 8 %.

-- | Don't format any data, just output a constant <a>Builder</a>.
now :: Builder -> Format r r

-- | Format a value of type <tt>a</tt> using a function of type <tt>a -&gt;
--   <a>Builder</a></tt>. For example, <tt>later (f :: Int -&gt;
--   Builder)</tt> produces <tt>Format r (Int -&gt; r)</tt>.
later :: (a -> Builder) -> Format r (a -> r)

-- | Functorial map over a formatter's input. Example: <tt>format (mapf
--   (drop 1) string) "hello"</tt>
mapf :: (a -> b) -> Format r (b -> t) -> Format r (a -> t)
runFormat :: Format r a -> (Builder -> r) -> a

-- | Run the formatter and return a lazy <a>Text</a> value.
format :: Format Text a -> a

-- | Run the formatter and return a strict <a>Text</a> value.
sformat :: Format Text a -> a

-- | Run the formatter and return a <a>Builder</a> value.
bprint :: Format Builder a -> a

-- | Run the formatter and print out the text to stdout.
fprint :: Format (IO ()) a -> a

-- | Run the formatter and put the output onto the given <a>Handle</a>.
hprint :: Handle -> Format (IO ()) a -> a

-- | Run the formatter and return a list of characters.
formatToString :: Format [Char] a -> a


-- | Examples that should always compile. If reading on Haddock, you can
--   view the sources to each of these.
module Formatting.Examples

-- | Simple hello, world!
hello :: Text

-- | Printing strings.
strings :: Text

-- | Printing texts.
texts :: Text

-- | Printing builders.
builders :: Text

-- | Printing integers.
integers :: Text

-- | Printing floating points.
floats :: Text

-- | Printing integrals in hex (base-16).
hexes :: Text

-- | Padding.
padding :: Text


-- | Formatters for high-res, real-time and timer clock values from
--   <a>System.Clock</a>.
module Formatting.Clock

-- | Same as <tt>durationNS</tt> but works on <a>TimeSpec</a> from the
--   clock package.
timeSpecs :: Format r (TimeSpec -> TimeSpec -> r)


-- | Reexports of things that were previously in the <tt>text-format</tt>
--   package.
module Formatting.Internal.Raw

-- | Pad the left hand side of a string until it reaches <tt>k</tt>
--   characters wide, if necessary filling with character <tt>c</tt>.
left :: Buildable a => Int -> Char -> a -> Builder

-- | Pad the right hand side of a string until it reaches <tt>k</tt>
--   characters wide, if necessary filling with character <tt>c</tt>.
right :: Buildable a => Int -> Char -> a -> Builder

-- | Render an integer using hexadecimal notation. (No leading "0x" is
--   added.)
hex :: Integral a => a -> Builder

-- | Render a floating point number using normal notation, with the given
--   number of decimal places.
fixed :: Real a => Int -> a -> Builder

-- | Render a floating point number using the smallest number of digits
--   that correctly represent it.
shortest :: Real a => a -> Builder

-- | The normal <a>mappend</a> function with right associativity instead of
--   left.
(<>) :: Builder -> Builder -> Builder
infixr 4 <>

-- | Unsafe conversion for decimal digits.
i2d :: Int -> Char
decimal :: (Integral a, Bounded a) => a -> Builder
integer :: Int -> Integer -> Builder
hexadecimal :: Integral a => a -> Builder
minus :: Builder

-- | Render a value using its <a>Show</a> instance.
newtype Shown a
Shown :: a -> Shown a
[shown] :: Shown a -> a

-- | Render an integral type in hexadecimal.
newtype Hex a
Hex :: a -> Hex a


-- | Single letters for short formatting.
module Formatting.ShortFormatters

-- | Output a lazy text.
t :: Format r (Text -> r)

-- | Render an integral e.g. 123 -&gt; "123", 0 -&gt; "0".
d :: Integral a => Format r (a -> r)

-- | Render an integer using binary notation. (No leading 0b is added.)
b :: Integral a => Format r (a -> r)

-- | Render an integer using octal notation. (No leading 0o is added.)
o :: Integral a => Format r (a -> r)

-- | Render an integer using hexadecimal notation. (No leading 0x is
--   added.)
x :: Integral a => Format r (a -> r)

-- | Output a strict text.
st :: Format r (Text -> r)

-- | Output a string.
s :: Format r (String -> r)

-- | Output a showable value (instance of <a>Show</a>) by turning it into
--   <a>Text</a>.
sh :: Show a => Format r (a -> r)

-- | Output a character.
c :: Format r (Char -> r)

-- | Render a floating point number using normal notation, with the given
--   number of decimal places.
f :: Real a => Int -> Format r (a -> r)

-- | Render a floating point number using the smallest number of digits
--   that correctly represent it.
sf :: Real a => Format r (a -> r)

-- | Pad the left hand side of a string until it reaches <tt>k</tt>
--   characters wide, if necessary filling with character <tt>ch</tt>.
l :: Buildable a => Int -> Char -> Format r (a -> r)

-- | Pad the right hand side of a string until it reaches <tt>k</tt>
--   characters wide, if necessary filling with character <tt>ch</tt>.
r :: Buildable a => Int -> Char -> Format r (a -> r)


-- | Formatters for time.
module Formatting.Time

-- | Timezone offset on the format <tt>-HHMM</tt>.
tz :: FormatTime a => Format r (a -> r)

-- | Timezone name.
tzName :: FormatTime a => Format r (a -> r)

-- | As <a>TimeLocale</a> <tt>locale</tt> (e.g. <tt>%a %b %e %H:%M:%S %Z
--   %Y</tt>).
datetime :: FormatTime a => Format r (a -> r)

-- | Same as <tt>%H:%M</tt>.
hm :: FormatTime a => Format r (a -> r)

-- | Same as <tt>%H:%M:%S</tt>.
hms :: FormatTime a => Format r (a -> r)

-- | As <a>TimeLocale</a> <tt>locale</tt> (e.g. <tt>%H:%M:%S</tt>).
hmsL :: FormatTime a => Format r (a -> r)

-- | As <a>TimeLocale</a> <tt>locale</tt> (e.g. <tt>%I:%M:%S %p</tt>).
hmsPL :: FormatTime a => Format r (a -> r)

-- | Day half from (<a>TimeLocale</a> <tt>locale</tt>), converted to
--   lowercase, <tt>am</tt>, <tt>pm</tt>.
dayHalf :: FormatTime a => Format r (a -> r)

-- | Day half from (<a>TimeLocale</a> <tt>locale</tt>), <tt>AM</tt>,
--   <tt>PM</tt>.
dayHalfU :: FormatTime a => Format r (a -> r)

-- | Hour, 24-hour, leading 0 as needed, <tt>00</tt> - <tt>23</tt>.
hour24 :: FormatTime a => Format r (a -> r)

-- | Hour, 12-hour, leading 0 as needed, <tt>01</tt> - <tt>12</tt>.
hour12 :: FormatTime a => Format r (a -> r)

-- | Hour, 24-hour, leading space as needed, <tt> 0</tt> - <tt>23</tt>.
hour24S :: FormatTime a => Format r (a -> r)

-- | Hour, 12-hour, leading space as needed, <tt> 1</tt> - <tt>12</tt>.
hour12S :: FormatTime a => Format r (a -> r)

-- | Minute, <tt>00</tt> - <tt>59</tt>.
minute :: FormatTime a => Format r (a -> r)

-- | Second, without decimal part, <tt>00</tt> - <tt>60</tt>.
second :: FormatTime a => Format r (a -> r)

-- | Picosecond, including trailing zeros, <tt>000000000000</tt> -
--   <tt>999999999999</tt>.
pico :: FormatTime a => Format r (a -> r)

-- | Decimal point and up to 12 second decimals, without trailing zeros.
--   For a whole number of seconds, this produces the empty string.
decimals :: FormatTime a => Format r (a -> r)
epoch :: FormatTime a => Format r (a -> r)

-- | Same as <tt>%m/%d/%y</tt>.
dateSlash :: FormatTime a => Format r (a -> r)

-- | Same as <tt>%Y-%m-%d</tt>.
dateDash :: FormatTime a => Format r (a -> r)

-- | As <a>TimeLocale</a> <tt>locale</tt> (e.g. <tt>%m/%d/%y</tt>).
dateSlashL :: FormatTime a => Format r (a -> r)

-- | Year.
year :: FormatTime a => Format r (a -> r)

-- | Last two digits of year, <tt>00</tt> - <tt>99</tt>.
yy :: FormatTime a => Format r (a -> r)

-- | Century (being the first two digits of the year), <tt>00</tt> -
--   <tt>99</tt>.
century :: FormatTime a => Format r (a -> r)

-- | Month name, long form (<a>fst</a> from <a>TimeLocale</a>
--   <tt>locale</tt>), <tt>January</tt> - <tt>December</tt>.
monthName :: FormatTime a => Format r (a -> r)

-- | <tt> %H] month name, short form (<a>snd</a> from <a>TimeLocale</a>
--   </tt>locale<tt>), </tt>Jan<tt> - </tt>Dec@.
monthNameShort :: FormatTime a => Format r (a -> r)

-- | Month of year, leading 0 as needed, <tt>01</tt> - <tt>12</tt>.
month :: FormatTime a => Format r (a -> r)

-- | Day of month, leading 0 as needed, <tt>01</tt> - <tt>31</tt>.
dayOfMonth :: FormatTime a => Format r (a -> r)

-- | Day of month, <tt>1st</tt>, <tt>2nd</tt>, <tt>25th</tt>, etc.
dayOfMonthOrd :: FormatTime a => Format r (a -> r)

-- | Day of month, leading space as needed, <tt> 1</tt> - <tt>31</tt>.
dayOfMonthS :: FormatTime a => Format r (a -> r)

-- | Day of year for Ordinal Date format, <tt>001</tt> - <tt>366</tt>.
day :: FormatTime a => Format r (a -> r)

-- | Year for Week Date format e.g. <tt>2013</tt>.
weekYear :: FormatTime a => Format r (a -> r)

-- | Last two digits of year for Week Date format, <tt>00</tt> -
--   <tt>99</tt>.
weekYY :: FormatTime a => Format r (a -> r)

-- | Century (first two digits of year) for Week Date format, <tt>00</tt> -
--   <tt>99</tt>.
weekCentury :: FormatTime a => Format r (a -> r)

-- | Week for Week Date format, <tt>01</tt> - <tt>53</tt>.
week :: FormatTime a => Format r (a -> r)

-- | Day for Week Date format, <tt>1</tt> - <tt>7</tt>.
dayOfWeek :: FormatTime a => Format r (a -> r)

-- | Day of week, short form (<a>snd</a> from <a>TimeLocale</a>
--   <tt>locale</tt>), <tt>Sun</tt> - <tt>Sat</tt>.
dayNameShort :: FormatTime a => Format r (a -> r)

-- | Day of week, long form (<a>fst</a> from <a>TimeLocale</a>
--   <tt>locale</tt>), <tt>Sunday</tt> - <tt>Saturday</tt>.
dayName :: FormatTime a => Format r (a -> r)

-- | Week number of year, where weeks start on Sunday (as
--   <tt>sundayStartWeek</tt>), <tt>00</tt> - <tt>53</tt>.
weekFromZero :: FormatTime a => Format r (a -> r)

-- | Day of week number, <tt>0</tt> (= Sunday) - <tt>6</tt> (= Saturday).
dayOfWeekFromZero :: FormatTime a => Format r (a -> r)

-- | Week number of year, where weeks start on Monday (as
--   <tt>mondayStartWeek</tt>), <tt>00</tt> - <tt>53</tt>.
weekOfYearMon :: FormatTime a => Format r (a -> r)

-- | Display a time span as one time relative to another. Input is assumed
--   to be seconds. Typical inputs are <a>NominalDiffTime</a> and
--   <a>DiffTime</a>.
diff :: RealFrac n => Bool -> Format r (n -> r)

-- | Display the absolute value time span in years.
years :: RealFrac n => Int -> Format r (n -> r)

-- | Display the absolute value time span in days.
days :: RealFrac n => Int -> Format r (n -> r)

-- | Display the absolute value time span in hours.
hours :: RealFrac n => Int -> Format r (n -> r)

-- | Display the absolute value time span in minutes.
minutes :: RealFrac n => Int -> Format r (n -> r)

-- | Display the absolute value time span in seconds.
seconds :: RealFrac n => Int -> Format r (n -> r)

-- | Formatter call. Probably don't want to use this.
fmt :: FormatTime a => Text -> a -> Text

-- | Helper for creating custom time formatters
customTimeFmt :: FormatTime a => Text -> Format r (a -> r)
