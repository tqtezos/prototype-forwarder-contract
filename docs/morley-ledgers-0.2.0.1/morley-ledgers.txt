-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Michelson contracts which implement Ledger interfaces.
--   
--   Smart contracts that implement Ledger interfaces and can be compiled
--   to Michelson. * AbstractLedger contract provides a trivial
--   implementation of the AbstractLedger interface. * ManagedLedger
--   contract provides a sample implementation of the ApprovableLedger
--   interface.
@package morley-ledgers
@version 0.2.0.1


-- | Documentation for ManagedLedger contract.
module Lorentz.Contracts.ManagedLedger.Doc
contractDoc :: Markdown
transferDoc :: Markdown
approveDoc :: Markdown
approveCASDoc :: Markdown
getAllowanceDoc :: Markdown
getBalanceDoc :: Markdown
getTotalSupplyDoc :: Markdown
setPauseDoc :: Markdown
setAdministratorDoc :: Markdown
getAdministratorDoc :: Markdown
mintDoc :: Markdown
burnDoc :: Markdown

-- | Mention that given action can be executed only when transfer-like
--   operations are not paused.
data DTokenNotPausedOnly
DTokenNotPausedOnly :: DTokenNotPausedOnly

-- | Mention that entrypoint requires sender to have special privileges.
--   
--   You provide textual description of these privileges, e.g.
--   "administrator" or "trusted".
data DRequireRole
DRequireRole :: Text -> DRequireRole
instance Michelson.Doc.DocItem Lorentz.Contracts.ManagedLedger.Doc.DRequireRole
instance Michelson.Doc.DocItem Lorentz.Contracts.ManagedLedger.Doc.DTokenNotPausedOnly

module Lorentz.Contracts.ManagedLedger.Types
type Storage = StorageSkeleton StorageFields
type StorageC store = (LedgerC store, StorageContains store ["admin" := Address, "paused" := Bool])
type LedgerC store = StorageContains store ["totalSupply" := Natural, "ledger" := Address ~> LedgerValue]
type LedgerValue = ("balance" :! Natural, "approvals" :! Map Address Natural)

-- | Create a default storage with ability to set some balances to non-zero
--   values.
mkStorage :: Address -> Map Address Natural -> Storage
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.ManagedLedger.Types.StorageFields
instance GHC.Generics.Generic Lorentz.Contracts.ManagedLedger.Types.StorageFields
instance Michelson.Typed.Haskell.Value.IsoValue fields => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Contracts.ManagedLedger.Types.StorageSkeleton fields)
instance GHC.Generics.Generic (Lorentz.Contracts.ManagedLedger.Types.StorageSkeleton fields)
instance Lorentz.ADT.HasFieldOfType Lorentz.Contracts.ManagedLedger.Types.StorageFields name field => Lorentz.StoreClass.StoreHasField Lorentz.Contracts.ManagedLedger.Types.StorageFields name field
instance (Lorentz.StoreClass.StoreHasField fields fname ftype, Michelson.Typed.Haskell.Value.IsoValue fields) => Lorentz.StoreClass.StoreHasField (Lorentz.Contracts.ManagedLedger.Types.StorageSkeleton fields) fname ftype
instance Michelson.Typed.Haskell.Value.IsoValue fields => Lorentz.StoreClass.StoreHasSubmap (Lorentz.Contracts.ManagedLedger.Types.StorageSkeleton fields) "ledger" Tezos.Address.Address Lorentz.Contracts.ManagedLedger.Types.LedgerValue


-- | AbstractLedger interface specification.
module Lorentz.Contracts.Spec.AbstractLedgerInterface
data Parameter
Transfer :: TransferParams -> Parameter
GetTotalSupply :: View () Natural -> Parameter
GetBalance :: View GetBalanceParams Natural -> Parameter
type TransferParams = ("from" :! Address, "to" :! Address, "value" :! Natural)
type GetBalanceParams = ("owner" :! Address)
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.Spec.AbstractLedgerInterface.Parameter
instance GHC.Generics.Generic Lorentz.Contracts.Spec.AbstractLedgerInterface.Parameter
instance Lorentz.EntryPoints.Core.ParameterHasEntryPoints Lorentz.Contracts.Spec.AbstractLedgerInterface.Parameter
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "notEnoughBalance")
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "nonAcceptableSource")
instance Lorentz.Errors.CustomErrorHasDoc "notEnoughBalance"
instance Lorentz.Errors.CustomErrorHasDoc "nonAcceptableSource"


-- | Abstract ledger implementation as described in TZIP-FA1.
module Indigo.Contracts.AbstractLedger
data Parameter
Transfer :: TransferParams -> Parameter
GetTotalSupply :: View () Natural -> Parameter
GetBalance :: View GetBalanceParams Natural -> Parameter
data Storage
Storage :: BigMap Address Natural -> Natural -> Storage
[ledger] :: Storage -> BigMap Address Natural
[totalSupply] :: Storage -> Natural
abstractLedgerContract :: ContractCode Parameter Storage
instance Michelson.Typed.Haskell.Value.IsoValue Indigo.Contracts.AbstractLedger.Storage
instance GHC.Generics.Generic Indigo.Contracts.AbstractLedger.Storage


-- | FA1.2 interface specification.
module Lorentz.Contracts.Spec.ApprovableLedgerInterface

-- | Provides an FA1.2 interface that is supposed to be used by
--   applications that can work with any FA1.2-compatible contract. This
--   type should be transformed to a concrete contract parameter and is not
--   supposed be used in contract code, thus it doesn't derive an
--   <a>IsoValue</a>.
data Parameter
Transfer :: TransferParams -> Parameter
Approve :: ApproveParams -> Parameter
GetAllowance :: View GetAllowanceParams Natural -> Parameter
GetBalance :: View GetBalanceParams Natural -> Parameter
GetTotalSupply :: View () Natural -> Parameter
type ParameterC param = ParameterContainsEntryPoints param ["Transfer" :> TransferParams, "Approve" :> ApproveParams, "GetAllowance" :> View GetAllowanceParams Natural, "GetBalance" :> View GetBalanceParams Natural, "GetTotalSupply" :> View () Natural]
type TransferParams = ("from" :! Address, "to" :! Address, "value" :! Natural)
type ApproveParams = ("spender" :! Address, "value" :! Natural)
type GetAllowanceParams = ("owner" :! Address, "spender" :! Address)
type GetBalanceParams = ("owner" :! Address)
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.Spec.ApprovableLedgerInterface.Parameter
instance GHC.Generics.Generic Lorentz.Contracts.Spec.ApprovableLedgerInterface.Parameter
instance Lorentz.EntryPoints.Core.ParameterHasEntryPoints Lorentz.Contracts.Spec.ApprovableLedgerInterface.Parameter
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "unsafeAllowanceChange")
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "notEnoughAllowance")
instance Lorentz.Errors.CustomErrorHasDoc "unsafeAllowanceChange"
instance Lorentz.Errors.CustomErrorHasDoc "notEnoughAllowance"


-- | Managed ledger which is compatible with FA1.2 standard and extended
--   with administrator functionality.
module Lorentz.Contracts.Spec.ManagedLedgerInterface
data Parameter
Transfer :: TransferParams -> Parameter
Approve :: ApproveParams -> Parameter
ApproveCAS :: ApproveCasParams -> Parameter
GetAllowance :: View GetAllowanceParams Natural -> Parameter
GetBalance :: View GetBalanceParams Natural -> Parameter
GetTotalSupply :: View () Natural -> Parameter
SetPause :: Bool -> Parameter
SetAdministrator :: Address -> Parameter
GetAdministrator :: View () Address -> Parameter
Mint :: MintParams -> Parameter
Burn :: BurnParams -> Parameter
type TransferParams = ("from" :! Address, "to" :! Address, "value" :! Natural)
type ApproveParams = ("spender" :! Address, "value" :! Natural)
type GetAllowanceParams = ("owner" :! Address, "spender" :! Address)
type GetBalanceParams = ("owner" :! Address)
type ApproveCasParams = ("spender" :! Address, "value" :! Natural, "expected" :! Natural)
type AllowanceParams = ("owner" :! Address, "spender" :! Address, "value" :! Natural)
type MintParams = ("to" :! Address, "value" :! Natural)
type BurnParams = ("from" :! Address, "value" :! Natural)
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.Spec.ManagedLedgerInterface.Parameter
instance GHC.Generics.Generic Lorentz.Contracts.Spec.ManagedLedgerInterface.Parameter
instance Lorentz.EntryPoints.Core.ParameterHasEntryPoints Lorentz.Contracts.Spec.ManagedLedgerInterface.Parameter
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "tokenOperationsArePaused")
instance Formatting.Buildable.Buildable (Lorentz.Errors.CustomError "allowanceMismatch")
instance Lorentz.Errors.CustomErrorHasDoc "tokenOperationsArePaused"
instance Lorentz.Errors.CustomErrorHasDoc "allowanceMismatch"


-- | Implementation of managed ledger which does not require particular
--   storage type.
module Lorentz.Contracts.ManagedLedger.Impl
type StorageC store = (LedgerC store, StorageContains store ["admin" := Address, "paused" := Bool])
managedLedgerContract :: ContractCode Parameter Storage
transfer :: forall store. (LedgerC store, StoreHasField store "paused" Bool) => Entrypoint TransferParams store

-- | Implementation of <tt>approve</tt> entrypoint.
approve :: forall store. (LedgerC store, StoreHasField store "paused" Bool) => Entrypoint ApproveParams store

-- | Implementation of <tt>approveCAS</tt> entrypoint. It adds an
--   additional check to <tt>approve</tt>: current allowance must match the
--   expected one.
approveCAS :: forall store. (LedgerC store, StoreHasField store "paused" Bool) => Entrypoint ApproveCasParams store
getAllowance :: LedgerC store => Entrypoint (View GetAllowanceParams Natural) store
getBalance :: LedgerC store => Entrypoint (View GetBalanceParams Natural) store
getTotalSupply :: LedgerC store => Entrypoint (View () Natural) store
setPause :: StorageC store => Entrypoint Bool store
setAdministrator :: forall store. StorageC store => Entrypoint Address store
getAdministrator :: StorageC store => Entrypoint (View () Address) store
mint :: StorageC store => Entrypoint MintParams store
burn :: StorageC store => Entrypoint BurnParams store
creditTo :: (param `HasFieldsOfType` ["to" := Address, "value" := Natural], LedgerC store) => '[param, store] :-> '[param, store]
debitFrom :: forall param store. (param `HasFieldsOfType` ["from" := Address, "value" := Natural], LedgerC store) => '[param, store] :-> '[param, store]
authorizeAdmin :: StorageC store => (store : s) :-> (store : s)
addTotalSupply :: StoreHasField store "totalSupply" Natural => (Integer : (store : s)) :-> (store : s)
allowance :: (param `HasFieldsOfType` ["owner" := Address, "spender" := Address], LedgerC store) => (param : (store : s)) :-> (Natural : s)
setAllowance :: forall store s. LedgerC store => (AllowanceParams : (store : s)) :-> (store : s)
consumeAllowance :: forall store s. LedgerC store => (TransferParams : (store : s)) :-> (store : s)
ensureNotPaused :: StoreHasField store "paused" Bool => (store : s) :-> (store : s)


-- | Managed ledger which is compatible with FA1.2 standard and extended
--   with administrator functionality.
module Lorentz.Contracts.ManagedLedger
data Parameter
Transfer :: TransferParams -> Parameter
Approve :: ApproveParams -> Parameter
ApproveCAS :: ApproveCasParams -> Parameter
GetAllowance :: View GetAllowanceParams Natural -> Parameter
GetBalance :: View GetBalanceParams Natural -> Parameter
GetTotalSupply :: View () Natural -> Parameter
SetPause :: Bool -> Parameter
SetAdministrator :: Address -> Parameter
GetAdministrator :: View () Address -> Parameter
Mint :: MintParams -> Parameter
Burn :: BurnParams -> Parameter
type Storage = StorageSkeleton StorageFields
type StorageC store = (LedgerC store, StorageContains store ["admin" := Address, "paused" := Bool])
type LedgerValue = ("balance" :! Natural, "approvals" :! Map Address Natural)

-- | Create a default storage with ability to set some balances to non-zero
--   values.
mkStorage :: Address -> Map Address Natural -> Storage
managedLedgerContract :: ContractCode Parameter Storage


-- | Managed ledger contract Indigo variant.
module Indigo.Contracts.ManagedLedger
data Parameter
Transfer :: TransferParams -> Parameter
Approve :: ApproveParams -> Parameter
ApproveCAS :: ApproveCasParams -> Parameter
GetAllowance :: View GetAllowanceParams Natural -> Parameter
GetBalance :: View GetBalanceParams Natural -> Parameter
GetTotalSupply :: View () Natural -> Parameter
SetPause :: Bool -> Parameter
SetAdministrator :: Address -> Parameter
GetAdministrator :: View () Address -> Parameter
Mint :: MintParams -> Parameter
Burn :: BurnParams -> Parameter
type Storage = StorageSkeleton StorageFields
type StorageC store = (LedgerC store, StorageContains store ["admin" := Address, "paused" := Bool])

-- | Create a default storage with ability to set some balances to non-zero
--   values.
mkStorage :: Address -> Map Address Natural -> Storage
type LedgerValue = ("balance" :! Natural, "approvals" :! Map Address Natural)
managedLedgerContract :: ContractCode Parameter Storage
