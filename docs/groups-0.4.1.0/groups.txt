-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell 98 groups
--   
--   Haskell 98 groups. A group is a monoid with invertibility.
@package groups
@version 0.4.1.0

module Data.Group

-- | A <a>Group</a> is a <a>Monoid</a> plus a function, <a>invert</a>, such
--   that:
--   
--   <pre>
--   a &lt;&gt; invert a == mempty
--   </pre>
--   
--   <pre>
--   invert a &lt;&gt; a == mempty
--   </pre>
class Monoid m => Group m
invert :: Group m => m -> m

-- | <pre>
--   <a>pow</a> a n == a &lt;&gt; a &lt;&gt; ... &lt;&gt; a
--   </pre>
--   
--   <pre>
--   (n lots of a)
--   </pre>
--   
--   If n is negative, the result is inverted.
pow :: (Group m, Integral x) => m -> x -> m

-- | An <a>Abelian</a> group is a <a>Group</a> that follows the rule:
--   
--   <pre>
--   a &lt;&gt; b == b &lt;&gt; a
--   </pre>
class Group g => Abelian g
instance Data.Group.Abelian ()
instance GHC.Num.Num a => Data.Group.Abelian (Data.Semigroup.Internal.Sum a)
instance GHC.Real.Fractional a => Data.Group.Abelian (Data.Semigroup.Internal.Product a)
instance Data.Group.Abelian a => Data.Group.Abelian (Data.Semigroup.Internal.Dual a)
instance Data.Group.Abelian b => Data.Group.Abelian (a -> b)
instance (Data.Group.Abelian a, Data.Group.Abelian b) => Data.Group.Abelian (a, b)
instance (Data.Group.Abelian a, Data.Group.Abelian b, Data.Group.Abelian c) => Data.Group.Abelian (a, b, c)
instance (Data.Group.Abelian a, Data.Group.Abelian b, Data.Group.Abelian c, Data.Group.Abelian d) => Data.Group.Abelian (a, b, c, d)
instance (Data.Group.Abelian a, Data.Group.Abelian b, Data.Group.Abelian c, Data.Group.Abelian d, Data.Group.Abelian e) => Data.Group.Abelian (a, b, c, d, e)
instance Data.Group.Group ()
instance GHC.Num.Num a => Data.Group.Group (Data.Semigroup.Internal.Sum a)
instance GHC.Real.Fractional a => Data.Group.Group (Data.Semigroup.Internal.Product a)
instance Data.Group.Group a => Data.Group.Group (Data.Semigroup.Internal.Dual a)
instance Data.Group.Group b => Data.Group.Group (a -> b)
instance (Data.Group.Group a, Data.Group.Group b) => Data.Group.Group (a, b)
instance (Data.Group.Group a, Data.Group.Group b, Data.Group.Group c) => Data.Group.Group (a, b, c)
instance (Data.Group.Group a, Data.Group.Group b, Data.Group.Group c, Data.Group.Group d) => Data.Group.Group (a, b, c, d)
instance (Data.Group.Group a, Data.Group.Group b, Data.Group.Group c, Data.Group.Group d, Data.Group.Group e) => Data.Group.Group (a, b, c, d, e)
