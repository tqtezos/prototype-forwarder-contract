-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Convenient imperative eDSL over Lorentz.
--   
--   Syntax and implementation of Indigo eDSL.
@package indigo
@version 0.1.0.0


-- | This module is intended to be imported instead of <tt>Lorentz</tt> by
--   Indigo modules.
--   
--   The idea is to avoid repeating common <tt>hiding</tt> rules and to not
--   export any of Lorentz's Instructions and Macros.
module Indigo.Lorentz
data Bool
False :: Bool
True :: Bool

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><tt>throw</tt>
--   (<tt>Underflow</tt> :: <tt>ArithException</tt>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a

-- | From a <a>Dict</a>, takes a value in an environment where the instance
--   witnessed by the <a>Dict</a> is in scope, and evaluates it.
--   
--   Essentially a deconstruction of a <a>Dict</a> into its
--   continuation-style form.
--   
--   Can also be used to deconstruct an entailment, <tt>a <a>:-</a> b</tt>,
--   using a context <tt>a</tt>.
--   
--   <pre>
--   withDict :: <a>Dict</a> c -&gt; (c =&gt; r) -&gt; r
--   withDict :: a =&gt; (a <a>:-</a> c) -&gt; (c =&gt; r) -&gt; r
--   </pre>
withDict :: HasDict c e => e -> (c -> r) -> r

-- | A set of values <tt>a</tt>.
data Set a

-- | A class for types with a default value.
class Default a

-- | The default value for this type.
def :: Default a => a

-- | <a>Wrapped</a> provides isomorphisms to wrap and unwrap newtypes or
--   data types with one constructor.
class Wrapped s where {
    type family Unwrapped s :: Type;
}

-- | An isomorphism between <tt>s</tt> and <tt>a</tt>.
--   
--   If your type has a <a>Generic</a> instance, <a>_Wrapped'</a> will
--   default to <a>_GWrapped'</a>, and you can choose to not override it
--   with your own definition.
_Wrapped' :: Wrapped s => Iso' s (Unwrapped s)

-- | Note that calling given entrypoints involves constructing
--   <a>UParam</a>.
pbsUParam :: KnownSymbol ctorName => ParamBuildingStep

-- | Make up <a>UParam</a> from ADT sum.
--   
--   Entry points template will consist of <tt>(constructorName,
--   constructorFieldType)</tt> pairs. Each constructor is expected to have
--   exactly one field.
uparamFromAdt :: UParamLinearize up => up -> UParam (UParamLinearized up)

-- | Like <a>caseUParam</a>, but accepts a tuple of clauses, not a
--   <a>Rec</a>.
caseUParamT :: (clauses ~ Rec (CaseClauseU inp out) entries, RecFromTuple clauses, CaseUParam entries) => IsoRecTuple clauses -> UParamFallback inp out -> (UParam entries : inp) :-> out

-- | Pattern-match on given <tt>UParam entries</tt>.
--   
--   You have to provide all case branches and a fallback action on case
--   when entrypoint is not found.
caseUParam :: (CaseUParam entries, RequireUniqueEntryPoints entries) => Rec (CaseClauseU inp out) entries -> UParamFallback inp out -> (UParam entries : inp) :-> out

-- | Default implementation for <a>UParamFallback</a>, simply reports an
--   error.
uparamFallbackFail :: () => UParamFallback inp out

-- | Helper instruction which extracts content of <a>UParam</a>.
unwrapUParam :: () => (UParam entries : s) :-> ((MText, ByteString) : s)

-- | Construct a <a>UParam</a> safely.
mkUParam :: (NicePackedValue a, LookupEntryPoint name entries ~ a, RequireUniqueEntryPoints entries) => Label name -> a -> UParam entries

-- | An entrypoint is described by two types: its name and type of
--   argument.
type EntryPointKind = (Symbol, Type)

-- | A convenient alias for type-level name-something pair.
type (?:) (n :: Symbol) (a :: k) = (,) n a

-- | Encapsulates parameter for one of entry points. It keeps entrypoint
--   name and corresponding argument serialized.
--   
--   In Haskell world, we keep an invariant of that contained value relates
--   to one of entry points from <tt>entries</tt> list.
newtype UParam (entries :: [EntryPointKind])
UParamUnsafe :: (MText, ByteString) -> UParam

-- | Pseudo value for <a>UParam</a> type variable.
type SomeInterface = (,) "SomeEntrypoints" Void : ([] :: [(Symbol, Type)])

-- | Homomorphic version of <a>UParam</a>, forgets the exact interface.
type UParam_ = UParam SomeInterface

-- | Get type of entrypoint argument by its name.
type family LookupEntryPoint (name :: Symbol) (entries :: [EntryPointKind]) :: Type

-- | Ensure that given entry points do no contain duplicated names.
type family RequireUniqueEntryPoints (entries :: [EntryPointKind]) :: Constraint

-- | This type can store any value that satisfies a certain constraint.
data ConstrainedSome (c :: Type -> Constraint)
[ConstrainedSome] :: forall (c :: Type -> Constraint) a. c a => a -> ConstrainedSome c

-- | This class is needed to implement <a>unpackUParam</a>.
class UnpackUParam (c :: Type -> Constraint) (entries :: [EntryPointKind])

-- | Turn <a>UParam</a> into a Haskell value. Since we don't know its type
--   in compile time, we have to erase it using <a>ConstrainedSome</a>. The
--   user of this function can require arbitrary constraint to hold
--   (depending on how they want to use the result).
unpackUParam :: UnpackUParam c entries => UParam entries -> Either EntryPointLookupError (MText, ConstrainedSome c)
data EntryPointLookupError
NoSuchEntryPoint :: MText -> EntryPointLookupError
ArgumentUnpackFailed :: EntryPointLookupError

-- | Implementations of some entry points.
--   
--   Note that this thing inherits properties of <a>Rec</a>, e.g. you can
--   <tt>Data.Vinyl.Core.rappend</tt> implementations for two entrypoint
--   sets when assembling scattered parts of a contract.
type EntryPointsImpl (inp :: [Type]) (out :: [Type]) (entries :: [EntryPointKind]) = Rec CaseClauseU inp out entries

-- | An action invoked when user-provided entrypoint is not found.
type UParamFallback (inp :: [Type]) (out :: [Type]) = (MText, ByteString) : inp :-> out

-- | Make up a "case" over entry points.
class CaseUParam (entries :: [EntryPointKind])

-- | Constraint required by <a>uparamFromAdt</a>.
type UParamLinearize p = (Generic p, GUParamLinearize Rep p)

-- | Entry points template derived from given ADT sum.
type UParamLinearized p = GUParamLinearized Rep p
entryCaseSimple_ :: (InstrCaseC cp inp out, RMap (CaseClauses cp), DocumentEntryPoints PlainEntryPointsKind cp, NiceParameterFull cp, RequireFlatParamEps cp) => Rec (CaseClauseL inp out) (CaseClauses cp) -> (cp & inp) :-> out

-- | Whether <a>finalizeParamCallingDoc</a> has already been applied to
--   these steps.
areFinalizedParamBuildingSteps :: [ParamBuildingStep] -> Bool

-- | Modify param building steps with respect to entrypoints that given
--   parameter declares.
--   
--   Each contract with entrypoints should eventually call this function,
--   otherwise, in case if contract uses built-in entrypoints feature, the
--   resulting parameter building steps in the generated documentation will
--   not consider entrypoints and thus may be incorrect.
--   
--   Calling this twice over the same code is also prohibited.
finalizeParamCallingDoc :: (NiceParameterFull cp, RequireSumType cp, HasCallStack) => ((cp : inp) :-> out) -> (cp : inp) :-> out

-- | Wrapper for documenting single entrypoint which parameter isn't going
--   to be unwrapped from some datatype.
--   
--   <tt>entryCase</tt> unwraps a datatype, however, sometimes we want to
--   have entrypoint parameter to be not wrapped into some datatype.
documentEntryPoint :: (KnownSymbol epName, DocItem (DEntryPoint kind), TypeHasDoc param, HasTypeAnn param, KnownValue param) => ((param & s) :-> out) -> (param & s) :-> out

-- | Go over contract code and update every occurrence of
--   <a>DEntryPointArg</a> documentation item, adding the given step to its
--   "how to build parameter" description.
clarifyParamBuildingSteps :: () => ParamBuildingStep -> (inp :-> out) -> inp :-> out
mkDEntryPointArgSimple :: (KnownValue t, HasTypeAnn t, TypeHasDoc t) => DEntryPointArg
mkDEpUType :: (KnownValue t, HasTypeAnn t) => Type
emptyDEpArg :: DEntryPointArg
constructDEpArg :: (TypeHasDoc arg, HasTypeAnn arg, KnownValue arg) => DEntryPointArg

-- | Make a <a>ParamBuildingStep</a> that tells about wrapping an argument
--   into a constructor with given name and uses given <a>ParamBuilder</a>
--   as description of Michelson part.
mkPbsWrapIn :: Text -> ParamBuilder -> ParamBuildingStep

-- | Default implementation of <a>docItemToMarkdown</a> for entry points.
diEntryPointToMarkdown :: () => HeaderLevel -> DEntryPoint level -> Markdown

-- | Gathers information about single entrypoint.
--   
--   We assume that entry points might be of different kinds, which is
--   designated by phantom type parameter. For instance, you may want to
--   have several groups of entry points corresponding to various parts of
--   a contract - specifying different <tt>kind</tt> type argument for each
--   of those groups will allow you defining different <a>DocItem</a>
--   instances with appropriate custom descriptions for them.
data DEntryPoint kind
DEntryPoint :: Text -> SubDoc -> DEntryPoint kind
[depName] :: DEntryPoint kind -> Text
[depSub] :: DEntryPoint kind -> SubDoc

-- | Default value for <a>DEntryPoint</a> type argument.
data PlainEntryPointsKind
data DEntryPointReference
DEntryPointReference :: Text -> Anchor -> DEntryPointReference

-- | When describing the way of parameter construction - piece of
--   incremental builder for this description.
newtype ParamBuilder
ParamBuilder :: (Markdown -> Markdown) -> ParamBuilder

-- | Argument stands for previously constructed parameter piece, and
--   returned value - a piece constructed after our step.
[unParamBuilder] :: ParamBuilder -> Markdown -> Markdown
data ParamBuildingDesc
ParamBuildingDesc :: Markdown -> ParamBuilder -> ParamBuilder -> ParamBuildingDesc

-- | Plain english description of this step.
[pbdEnglish] :: ParamBuildingDesc -> Markdown

-- | How to construct parameter in Haskell code.
[pbdHaskell] :: ParamBuildingDesc -> ParamBuilder

-- | How to construct parameter working on raw Michelson.
[pbdMichelson] :: ParamBuildingDesc -> ParamBuilder

-- | Describes a parameter building step.
--   
--   This can be wrapping into (Haskell) constructor, or a more complex
--   transformation.
data ParamBuildingStep

-- | Wraps something into constructor with given name. Constructor should
--   be the one which corresponds to an entrypoint defined via field
--   annotation, for more complex cases use <a>PbsCustom</a>.
PbsWrapIn :: Text -> ParamBuildingDesc -> ParamBuildingStep

-- | Directly call an entrypoint marked with a field annotation.
PbsCallEntrypoint :: EpName -> ParamBuildingStep

-- | Other action.
PbsCustom :: ParamBuildingDesc -> ParamBuildingStep

-- | This entrypoint cannot be called, which is possible when an explicit
--   default entrypoint is present. This is not a true entrypoint but just
--   some intermediate node in <tt>or</tt> tree and neither it nor any of
--   its parents are marked with a field annotation.
--   
--   It contains dummy <a>ParamBuildingStep</a>s which were assigned before
--   entrypoints were taken into account.
PbsUncallable :: [ParamBuildingStep] -> ParamBuildingStep

-- | Describes argument of an entrypoint.
data DEntryPointArg
DEntryPointArg :: Maybe DType -> [ParamBuildingStep] -> Type -> DEntryPointArg

-- | Argument of the entrypoint. Pass <a>Nothing</a> if no argument is
--   required.
[epaArg] :: DEntryPointArg -> Maybe DType

-- | Describes a way to lift an entrypoint argument into full parameter
--   which can be passed to the contract.
--   
--   Steps are supposed to be applied in the order opposite to one in which
--   they are given. E.g. suppose that an entrypoint is called as <tt>Run
--   (Service1 arg)</tt>; then the first step (actual last) should describe
--   wrapping into <tt>Run</tt> constructor, and the second step (actual
--   first) should be about wrapping into <tt>Service1</tt> constructor.
[epaBuilding] :: DEntryPointArg -> [ParamBuildingStep]

-- | Untyped representation of entrypoint, used for printing its michelson
--   type representation.
[epaType] :: DEntryPointArg -> Type

-- | Pick a type documentation from <a>CtorField</a>.
class KnownSymbol con => DeriveCtorFieldDoc (con :: Symbol) (cf :: CtorField)
deriveCtorFieldDoc :: DeriveCtorFieldDoc con cf => DEntryPointArg

-- | Constraint for <a>documentEntryPoints</a>.
type DocumentEntryPoints kind a = (Generic a, GDocumentEntryPoints kind Rep a)

-- | Provides arror for convenient entrypoint documentation
class EntryArrow (kind :: k) (name :: Symbol) body

-- | Lift entrypoint implementation.
--   
--   Entrypoint names should go with "e" prefix.
(#->) :: EntryArrow kind name body => (Label name, Proxy kind) -> body -> body
type family RequireFlatParamEps cp :: Constraint
type family RequireFlatEpDerivation (cp :: t) deriv :: Constraint

-- | Chain implementations of field and submap operations.
composeStoreSubmapOps :: () => Label nameInStore -> StoreFieldOps store nameInStore substore -> StoreSubmapOps substore mname key value -> StoreSubmapOps store mname key value

-- | Chain two implementations of field operations.
--   
--   Suits for a case when your store does not contain its fields directly
--   rather has a nested structure.
composeStoreFieldOps :: () => Label nameInStore -> StoreFieldOps store nameInStore substore -> StoreFieldOps substore nameInSubstore field -> StoreFieldOps store nameInSubstore field

-- | Pretend that given <a>StoreSubmapOps</a> implementation is made up for
--   submap with name <tt>desiredName</tt>, not its actual name. Logic of
--   the implementation remains the same.
--   
--   See also <a>storeSubmapOpsReferTo</a>.
storeFieldOpsReferTo :: () => Label name -> StoreFieldOps storage name field -> StoreFieldOps storage desiredName field

-- | Pretend that given <a>StoreSubmapOps</a> implementation is made up for
--   submap with name <tt>desiredName</tt>, not its actual name. Logic of
--   the implementation remains the same.
--   
--   Use case: imagine that your code requires access to submap named
--   <tt>X</tt>, but in your storage that submap is called <tt>Y</tt>. Then
--   you implement the instance which makes <tt>X</tt> refer to <tt>Y</tt>:
--   
--   <pre>
--   instance StoreHasSubmap Store X Key Value where
--     storeSubmapOps = storeSubmapOpsReferTo #Y storeSubmapOpsForY
--   </pre>
storeSubmapOpsReferTo :: () => Label name -> StoreSubmapOps storage name key value -> StoreSubmapOps storage desiredName key value

-- | Implementation of <a>StoreHasSubmap</a> for a data type which has an
--   instance of <a>StoreHasSubmap</a> inside. For instance, it can be used
--   for top-level storage.
storeSubmapOpsDeeper :: (HasFieldOfType storage bigMapPartName fields, StoreHasSubmap fields mname key value) => Label bigMapPartName -> StoreSubmapOps storage mname key value

-- | Implementation of <a>StoreHasField</a> for a data type which has an
--   instance of <a>StoreHasField</a> inside. For instance, it can be used
--   for top-level storage.
storeFieldOpsDeeper :: (HasFieldOfType storage fieldsPartName fields, StoreHasField fields fname ftype) => Label fieldsPartName -> StoreFieldOps storage fname ftype

-- | Implementation of <a>StoreHasField</a> for case of datatype keeping a
--   pack of fields.
storeFieldOpsADT :: HasFieldOfType dt fname ftype => StoreFieldOps dt fname ftype

-- | Add a value in storage, but fail if it will overwrite some existing
--   entry.
stInsertNew :: StoreHasSubmap store mname key value => Label mname -> (forall (s0 :: [Type]) (any :: [Type]). () => (key : s0) :-> any) -> (key : (value : (store : s))) :-> (store : s)

-- | Add a value in storage.
stInsert :: StoreHasSubmap store mname key value => Label mname -> (key : (value : (store : s))) :-> (store : s)

-- | Delete a value in storage.
stDelete :: (StoreHasSubmap store mname key value, KnownValue value) => Label mname -> (key : (store : s)) :-> (store : s)

-- | Update a value in storage.
stUpdate :: StoreHasSubmap store mname key value => Label mname -> (key : (Maybe value : (store : s))) :-> (store : s)

-- | Get value in storage.
stGet :: StoreHasSubmap store mname key value => Label mname -> (key : (store : s)) :-> (Maybe value : s)

-- | Check value presence in storage.
stMem :: StoreHasSubmap store mname key value => Label mname -> (key : (store : s)) :-> (Bool : s)

-- | Update storage field.
stSetField :: StoreHasField store fname ftype => Label fname -> (ftype : (store : s)) :-> (store : s)

-- | Get storage field, preserving the storage itself on stack.
stGetField :: StoreHasField store fname ftype => Label fname -> (store : s) :-> (ftype : (store : s))

-- | Pick storage field.
stToField :: StoreHasField store fname ftype => Label fname -> (store : s) :-> (ftype : s)

-- | Datatype containing the full implementation of <a>StoreHasField</a>
--   typeclass.
--   
--   We use this grouping because in most cases implementation will be
--   chosen among the default ones, and initializing all methods at once is
--   simpler and more consistent. (One can say that we are trying to
--   emulate benefits of <tt>DerivingVia</tt> extension.)
data StoreFieldOps store (fname :: Symbol) ftype
StoreFieldOps :: (forall (s :: [Type]). () => Label fname -> (store : s) :-> (ftype : s)) -> (forall (s :: [Type]). () => Label fname -> (ftype : (store : s)) :-> (store : s)) -> StoreFieldOps store ftype
[sopToField] :: StoreFieldOps store ftype -> forall (s :: [Type]). () => Label fname -> (store : s) :-> (ftype : s)
[sopSetField] :: StoreFieldOps store ftype -> forall (s :: [Type]). () => Label fname -> (ftype : (store : s)) :-> (store : s)

-- | Provides operations on fields for storage.
class StoreHasField store (fname :: Symbol) ftype | store fname -> ftype
storeFieldOps :: StoreHasField store fname ftype => StoreFieldOps store fname ftype

-- | Datatype containing the full implementation of <a>StoreHasField</a>
--   typeclass.
--   
--   We use this grouping because in most cases implementation will be
--   chosen among the default ones, and initializing all methods at once is
--   simpler and more consistent. (One can say that we are trying to
--   emulate <tt>DerivingVia</tt> extension.)
data StoreSubmapOps store (mname :: Symbol) key value
StoreSubmapOps :: (forall (s :: [Type]). () => Label mname -> (key : (store : s)) :-> (Bool : s)) -> (forall (s :: [Type]). () => Label mname -> (key : (store : s)) :-> (Maybe value : s)) -> (forall (s :: [Type]). () => Label mname -> (key : (Maybe value : (store : s))) :-> (store : s)) -> (forall (s :: [Type]). () => Maybe (Label mname -> (key : (store : s)) :-> (store : s))) -> (forall (s :: [Type]). () => Maybe (Label mname -> (key : (value : (store : s))) :-> (store : s))) -> StoreSubmapOps store key value
[sopMem] :: StoreSubmapOps store key value -> forall (s :: [Type]). () => Label mname -> (key : (store : s)) :-> (Bool : s)
[sopGet] :: StoreSubmapOps store key value -> forall (s :: [Type]). () => Label mname -> (key : (store : s)) :-> (Maybe value : s)
[sopUpdate] :: StoreSubmapOps store key value -> forall (s :: [Type]). () => Label mname -> (key : (Maybe value : (store : s))) :-> (store : s)
[sopDelete] :: StoreSubmapOps store key value -> forall (s :: [Type]). () => Maybe (Label mname -> (key : (store : s)) :-> (store : s))
[sopInsert] :: StoreSubmapOps store key value -> forall (s :: [Type]). () => Maybe (Label mname -> (key : (value : (store : s))) :-> (store : s))

-- | Provides operations on fields for storage.
class StoreHasSubmap store (mname :: Symbol) key value | store mname -> key value
storeSubmapOps :: StoreHasSubmap store mname key value => StoreSubmapOps store mname key value

-- | Indicates a submap with given key and value types.
data (~>) (k2 :: k) (v :: k1) :: forall k k1. () => k -> k1 -> Type
infix 9 ~>

-- | Concise way to write down constraints with expected content of a
--   storage.
--   
--   Use it like follows:
--   
--   <pre>
--   type StorageConstraint = StorageContains
--     [ "fieldInt" := Int
--     , "fieldNat" := Nat
--     , "balances" := Address ~&gt; Int
--     ]
--   </pre>
type family StorageContains store (content :: [NamedField]) :: Constraint

-- | Wrap entry in constructor. Useful for sum types.
unwrapUnsafe_ :: InstrUnwrapC dt name => Label name -> (dt & st) :-> (CtorOnlyField name dt : st)

-- | Wrap entry in constructor. Useful for sum types.
wrap_ :: InstrWrapC dt name => Label name -> AppendCtorField (GetCtorField dt name) st :-> (dt & st)

-- | Lift an instruction to field constructor.
fieldCtor :: HasCallStack => (st :-> (f & st)) -> FieldConstructor st f

-- | Apply given modifier to a datatype field.
modifyField :: (InstrGetFieldC dt name, InstrSetFieldC dt name) => Label name -> (forall (st0 :: [Type]). () => (GetFieldType dt name : st0) :-> (GetFieldType dt name : st0)) -> (dt & st) :-> (dt & st)

-- | Set a field of a datatype.
setField :: InstrSetFieldC dt name => Label name -> (GetFieldType dt name : (dt : st)) :-> (dt : st)

-- | Like <a>getField</a>, but leaves field named.
getFieldNamed :: InstrGetFieldC dt name => Label name -> (dt & st) :-> ((name :! GetFieldType dt name) & (dt : st))

-- | Extract a field of a datatype, leaving the original datatype on stack.
getField :: InstrGetFieldC dt name => Label name -> (dt & st) :-> (GetFieldType dt name & (dt : st))

-- | Like <a>toField</a>, but leaves field named.
toFieldNamed :: InstrGetFieldC dt name => Label name -> (dt & st) :-> ((name :! GetFieldType dt name) & st)

-- | Extract a field of a datatype replacing the value of this datatype
--   with the extracted field.
--   
--   For this and the following functions you have to specify field name
--   which is either record name or name attached with <tt>(:!)</tt>
--   operator.
toField :: InstrGetFieldC dt name => Label name -> (dt & st) :-> (GetFieldType dt name & st)

-- | Allows field access and modification.
type HasField dt (fname :: Symbol) = (InstrGetFieldC dt fname, InstrSetFieldC dt fname)

-- | Like <a>HasField</a>, but allows constrainting field type.
type HasFieldOfType dt (fname :: Symbol) fieldTy = (HasField dt fname, GetFieldType dt fname ~ fieldTy)

-- | A pair of field name and type.
data NamedField
NamedField :: Symbol -> Type -> NamedField
type (:=) (n :: Symbol) ty = NamedField n ty
infixr 0 :=

-- | Shortcut for multiple <a>HasFieldOfType</a> constraints.
type family HasFieldsOfType dt (fs :: [NamedField]) :: Constraint

-- | Lorentz analogy of <a>CaseClause</a>, it works on plain <a>Type</a>
--   types.
data CaseClauseL (inp :: [Type]) (out :: [Type]) (param :: CaseClauseParam)
[CaseClauseL] :: forall (inp :: [Type]) (out :: [Type]) (param :: CaseClauseParam) (x :: CtorField) (ctor :: Symbol). () => (AppendCtorField x inp :-> out) -> CaseClauseL inp out (CaseClauseParam ctor x)

-- | Provides "case" arrow which works on different wrappers for clauses.
class CaseArrow (name :: Symbol) body clause | clause -> name, clause -> body

-- | Lift an instruction to case clause.
--   
--   You should write out constructor name corresponding to the clause
--   explicitly. Prefix constructor name with "c" letter, otherwise your
--   label will not be recognized by Haskell parser. Passing constructor
--   name can be circumvented but doing so is not recomended as mentioning
--   contructor name improves readability and allows avoiding some
--   mistakes.
(/->) :: CaseArrow name body clause => Label name -> body -> clause
infixr 0 /->
type CaseTC dt (out :: [Type]) (inp :: [Type]) clauses = (InstrCaseC dt inp out, RMap CaseClauses dt, RecFromTuple clauses, clauses ~ Rec CaseClauseL inp out CaseClauses dt)

-- | Handlers for most common errors defined in Lorentz.
baseErrorDocHandlers :: [NumericErrorDocHandler]

-- | Handler for <a>VoidResult</a>.
voidResultDocHandler :: NumericErrorDocHandler

-- | Handler for all <a>CustomError</a>s.
customErrorDocHandler :: NumericErrorDocHandler

-- | Extended version of <a>applyErrorTagToErrorsDoc</a> which accepts
--   error handlers.
--   
--   In most cases that function should be enough for your purposes, but it
--   uses a fixed set of base handlers which may be not enough in case when
--   you define your own errors. In this case define and pass all the
--   necessary handlers to this function.
--   
--   It fails with <a>error</a> if some of the errors used in the contract
--   cannot be handled with given handlers.
applyErrorTagToErrorsDocWith :: HasCallStack => [NumericErrorDocHandler] -> ErrorTagMap -> (inp :-> out) -> inp :-> out

-- | Modify documentation generated for given code so that all
--   <a>CustomError</a> mention not their textual error tag rather
--   respective numeric one from the given map.
--   
--   If some documented error is not present in the map, it remains
--   unmodified. This function may fail with <a>error</a> if contract uses
--   some uncommon errors, see <a>applyErrorTagToErrorsDocWith</a> for
--   details.
applyErrorTagToErrorsDoc :: HasCallStack => ErrorTagMap -> (inp :-> out) -> inp :-> out

-- | Adds a section which explains error tag mapping.
data DDescribeErrorTagMap
DDescribeErrorTagMap :: Text -> DDescribeErrorTagMap

-- | Describes where the error tag map is defined in Haskell code.
[detmSrcLoc] :: DDescribeErrorTagMap -> Text

-- | Errors for <a>NumericErrorDocHandler</a>
data NumericErrorDocHandlerError

-- | Handler which changes documentation for one particular error type.
data NumericErrorDocHandler

-- | Some error with a numeric tag attached.
data NumericErrorWrapper (numTag :: Nat) err

-- | Like <a>ustoreDecompose</a>, but requires all entries from
--   <tt>UStore</tt> to be recognized.
ustoreDecomposeFull :: UStoreConversible template => UStore template -> Either Text template

-- | Make migration script which initializes <a>UStore</a> from scratch.
fillUStore :: UStoreConversible template => template -> UStoreMigration () template

-- | Decompose <a>UStore</a> into separate <tt>big_map</tt>s and fields.
--   
--   Since this function needs to <tt>UNPACK</tt> content of
--   <tt>UStore</tt> to actual keys and values, you have to provide
--   <tt>UnpackEnv</tt>.
--   
--   Along with resulting value, you get a list of <tt>UStore</tt> entries
--   which were not recognized as belonging to any submap or field
--   according to <tt>UStore</tt>'s template - this should be empty unless
--   <tt>UStore</tt> invariants were violated.
ustoreDecompose :: UStoreConversible template => UStore template -> Either Text (UStoreContent, template)

-- | Make <a>UStore</a> from separate <tt>big_map</tt>s and fields.
mkUStore :: UStoreConversible template => template -> UStore template

-- | Given template can be converted to <a>UStore</a> value.
class (Generic template, GUStoreConversible Rep template) => UStoreConversible template

-- | Get the old version of storage.
--   
--   This can be applied only in the beginning of migration.
--   
--   In fact this function is not very useful, all required operations
--   should be available for <a>MUStore</a>, but leaving it here just in
--   case.
mustoreToOld :: RequireBeInitial touched => (MUStore oldTemplate newTemplate remDiff touched : s) :-> (UStore oldTemplate : s)

-- | Modify field which should stay in new version of storage. This does
--   not affect remaining diff.
migrateModifyField :: (HasUField field fieldTy oldTempl, HasUField field fieldTy newTempl) => Label field -> (fieldTy : (MUStore oldTempl newTempl diff touched : s)) :-> (MUStore oldTempl newTempl diff touched : s)

-- | Remove field and write new one in place of it.
--   
--   This is semantically equivalent to <tt>dip (migrateRemoveField label)
--   &gt;&gt; migrateAddField label</tt>, but is cheaper.
migrateOverwriteField :: ((,) (UStoreFieldExt oldMarker oldFieldTy) newDiff0 ~ CoverDiff DcRemove field diff, (,) (UStoreFieldExt marker fieldTy) newDiff ~ CoverDiff DcAdd field newDiff0, HasUField field fieldTy newTempl) => Label field -> (fieldTy : (MUStore oldTempl newTempl diff touched : s)) :-> (MUStore oldTempl newTempl newDiff (field : touched) : s)

-- | Get and remove a field from old version of <a>UStore</a>.
--   
--   You probably want to use this more often than plain
--   <a>migrateRemoveField</a>.
migrateExtractField :: ((,) (UStoreFieldExt marker fieldTy) newDiff ~ CoverDiff DcRemove field diff, HasUField field fieldTy oldTempl, RequireUntouched field (IsElem field touched)) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (fieldTy : (MUStore oldTempl newTempl newDiff (field : touched) : s))

-- | Remove a field which should not be present in new version of storage.
--   This covers one removal from the diff.
--   
--   In fact, this action could be performed automatically, but since
--   removal is a destructive operation, being explicit about it seems like
--   a good thing.
migrateRemoveField :: ((,) (UStoreFieldExt marker fieldTy) newDiff ~ CoverDiff DcRemove field diff, HasUField field fieldTy oldTempl) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (MUStore oldTempl newTempl newDiff (field : touched) : s)

-- | Add a field which was not present before. This covers one addition
--   from the diff and any removals of field with given name.
--   
--   This function cannot overwrite existing field with the same name, if
--   this is necessary use <a>migrateOverwriteField</a> which would declare
--   removal explicitly.
migrateAddField :: ((,) (UStoreFieldExt marker fieldTy) newDiff ~ CoverDiff DcAdd field diff, HasUField field fieldTy newTempl) => Label field -> (fieldTy : (MUStore oldTempl newTempl diff touched : s)) :-> (MUStore oldTempl newTempl newDiff (field : touched) : s)

-- | Get a field present in old version of <a>UStore</a>.
migrateGetField :: (HasUField field fieldTy oldTempl, RequireUntouched field (IsElem field touched)) => Label field -> (MUStore oldTempl newTempl diff touched : s) :-> (fieldTy : (MUStore oldTempl newTempl diff touched : s))

-- | Like <tt>setField</tt>, but for <a>UStore</a>.
ustoreSetField :: FieldAccessC store name => Label name -> (GetUStoreField store name : (UStore store : s)) :-> (UStore store : s)

-- | Like <tt>getField</tt>, but for <a>UStore</a>.
--   
--   This may fail only if <a>UStore</a> was made up incorrectly during
--   contract initialization.
ustoreGetField :: FieldAccessC store name => Label name -> (UStore store : s) :-> (GetUStoreField store name : (UStore store : s))

-- | Like <tt>toField</tt>, but for <a>UStore</a>.
--   
--   This may fail only if <a>UStore</a> was made up incorrectly during
--   contract initialization.
ustoreToField :: FieldAccessC store name => Label name -> (UStore store : s) :-> (GetUStoreField store name : s)
ustoreDelete :: KeyAccessC store name => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (UStore store : s)

-- | Insert a key-value pair, but fail if it will overwrite some existing
--   entry.
ustoreInsertNew :: (KeyAccessC store name, ValueAccessC store name) => Label name -> (forall (s0 :: [Type]) (any :: [Type]). () => (GetUStoreKey store name : s0) :-> any) -> (GetUStoreKey store name : (GetUStoreValue store name : (UStore store : s))) :-> (UStore store : s)
ustoreInsert :: (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (GetUStoreValue store name : (UStore store : s))) :-> (UStore store : s)
ustoreUpdate :: (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (Maybe (GetUStoreValue store name) : (UStore store : s))) :-> (UStore store : s)
ustoreGet :: (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (Maybe (GetUStoreValue store name) : s)
ustoreMem :: KeyAccessC store name => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (Bool : s)

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some submap(s) of it.
--   
--   It can use all UStore operations for a particular name, key and value
--   without knowing whole template.
type HasUStore (name :: Symbol) key value store = (KeyAccessC store name, ValueAccessC store name, GetUStoreKey store name ~ key, GetUStoreValue store name ~ value)

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some field of it.
type HasUField (name :: Symbol) ty store = (FieldAccessC store name, GetUStoreField store name ~ ty)

-- | Write down all sensisble constraints which given <tt>store</tt>
--   satisfies and apply them to <tt>constrained</tt>.
--   
--   This store should have <a>|~&gt;</a> and <a>UStoreFieldExt</a> fields
--   in its immediate fields, no deep inspection is performed.
type HasUStoreForAllIn store constrained = (Generic store, GHasStoreForAllIn constrained Rep store)

-- | <tt>view</tt> type synonym as described in A1.
data View a r

-- | Unlift an <a>UStore</a> to a smaller <a>UStore</a> which is part of
--   the former.
--   
--   This function is not intended for use in migrations, only in normal
--   entry points.
--   
--   Surprisingly, despite smaller <a>UStore</a> may have extra entries,
--   this function is safe when used in contract code. Truly, all getters
--   and setters are still safe to use. Also, there is no way for the
--   resulting small <tt>UStore</tt> to leak outside of the contract since
--   the only place where <tt>big_map</tt> can appear is contract storage,
--   so this small <tt>UStore</tt> can be either dropped or lifted back via
--   <a>liftUStore</a> to appear as part of the new contract's state.
--   
--   When this function is run as part of standalone instructions sequence,
--   not as part of contract code (e.g. in tests), you may get an
--   <tt>UStore</tt> with entries not inherent to it.
unliftUStore :: Generic template => Label name -> (UStore template : s) :-> (UStore (GetFieldType template name) : s)

-- | Lift an <a>UStore</a> to another <a>UStore</a> which contains all the
--   entries of the former under given field.
--   
--   This function is not intended for use in migrations, only in normal
--   entry points.
--   
--   Note that this function ensures that template of resulting store does
--   not contain inner nested templates with duplicated fields, otherwise
--   <a>UStore</a> invariants could get broken.
liftUStore :: (Generic template, RequireAllUniqueFields template) => Label name -> (UStore (GetFieldType template name) : s) :-> (UStore template : s)

-- | Get migration script in case of simple (non-batched) migration.
migrationToScript :: () => UStoreMigration os ns -> MigrationScript os ns

-- | Get migration script in case of simple (non-batched) migration.
migrationToScriptI :: () => UStoreMigration os ns -> Identity (MigrationScript os ns)

-- | Safe way to create migration scripts for <a>UStore</a>.
--   
--   You have to supply a code which would transform <a>MUStore</a>,
--   coverring required diff step-by-step. All basic instructions work,
--   also use <tt>migrate*</tt> functions from this module to operate with
--   <a>MUStore</a>.
--   
--   This method produces a whole migration, it cannot be splitted in
--   batches. In case if your migration is too big to be applied within a
--   single transaction, use <a>mkUStoreBatchedMigration</a>.
mkUStoreMigration :: () => Lambda (MUStore oldTempl newTempl (BuildDiff oldTempl newTempl) ([] :: [Symbol])) (MUStore oldTempl newTempl ([] :: [DiffItem]) _1) -> UStoreMigration oldTempl newTempl

-- | Turn <tt>Migration</tt> into a whole piece of code for transforming
--   storage.
--   
--   This is not want you'd want to use for contract deployment because of
--   gas and operation size limits that Tezos applies to transactions.
migrationToLambda :: () => UStoreMigration oldTemplate newTemplate -> Lambda (UStore oldTemplate) (UStore newTemplate)

-- | Keeps information about migration between <a>UStore</a>s with two
--   given templates.
data UStoreMigration oldTempl newTempl

-- | Code of migration for <a>UStore</a>.
--   
--   Invariant: preferably should fit into op size / gas limits (quite
--   obvious). Often this stands for exactly one stage of migration (one
--   Tezos transaction).
newtype MigrationScript oldStore newStore
MigrationScript :: Lambda UStore_ UStore_ -> MigrationScript oldStore newStore
[unMigrationScript] :: MigrationScript oldStore newStore -> Lambda UStore_ UStore_
type MigrationScript_ = MigrationScript SomeUTemplate SomeUTemplate

-- | Implementation of <a>castDummy</a> for types composed from smaller
--   types. It helps to ensure that all necessary constraints are requested
--   in instance head.
castDummyG :: (Generic a, Generic b, GCanCastTo (Rep a) (Rep b)) => Proxy a -> Proxy b -> ()

-- | Locally provide bidirectional <a>CanCastTo</a> instance.
allowCheckedCoerce :: () => Dict (CanCastTo a b, CanCastTo b a)

-- | Locally provide given <a>CanCastTo</a> instance.
allowCheckedCoerceTo :: () => Dict (CanCastTo a b)

-- | Pretends that the top item of the stack was coerced.
checkedCoercing_ :: Coercible_ a b => ((b : s) :-> (b : s)) -> (a : s) :-> (a : s)

-- | Coerce between types which have an explicit permission for that in the
--   face of <a>CanCastTo</a> constraint.
checkedCoerce_ :: Castable_ a b => (a : s) :-> (b : s)

-- | Coercion in Haskell world which respects <a>CanCastTo</a>.
checkedCoerce :: (CanCastTo a b, Coercible a b) => a -> b

-- | Unpack named value.
fromNamed :: () => Label name -> (NamedF Identity a name : s) :-> (a : s)

-- | Lift given value to a named value.
toNamed :: () => Label name -> (a : s) :-> (NamedF Identity a name : s)

-- | Specialized version of <tt>coerce_</tt> to unwrap a haskell newtype.
coerceUnwrap :: (inner ~ Unwrapped newtyp, MichelsonCoercible newtyp (Unwrapped newtyp)) => (newtyp : s) :-> (inner : s)

-- | Specialized version of <tt>coerce_</tt> to wrap into a haskell
--   newtype.
coerceWrap :: (inner ~ Unwrapped newtyp, MichelsonCoercible newtyp (Unwrapped newtyp)) => (inner : s) :-> (newtyp : s)
fakeCoercing :: () => (s1 :-> s2) -> s1' :-> s2'

-- | Convert between two stacks via failing.
fakeCoerce :: () => s1 :-> s2
gForcedCoerce_ :: MichelsonCoercible (t a) (t b) => (t a : s) :-> (t b : s)

-- | Convert between values of types that have the same representation.
--   
--   This function is not safe in a sense that this allows breaking
--   invariants of casted type (example: <tt>UStore</tt>) or may stop
--   compile on code changes (example: coercion of pair to a datatype with
--   two fields will break if new field is added). Still, produced
--   Michelson code will always be valid.
--   
--   Prefer using one of more specific functions from this module.
forcedCoerce_ :: MichelsonCoercible a b => (a & s) :-> (b & s)

-- | Coercion for Haskell world.
--   
--   We discourage using this function on Lorentz types, consider using
--   <tt>coerce</tt> instead. One of the reasons forthat is that in Lorentz
--   it's common to declare types as newtypes consisting of existing
--   primitives, and <tt>forcedCoerce</tt> tends to ignore all phantom type
--   variables of newtypes thus violating their invariants.
forcedCoerce :: Coercible a b => a -> b

-- | Whether two types have the same Michelson representation.
type MichelsonCoercible a b = ToT a ~ ToT b

-- | Explicitly allowed coercions.
--   
--   <tt>a <a>CanCastTo</a> b</tt> proclaims that <tt>a</tt> can be casted
--   to <tt>b</tt> without violating any invariants of <tt>b</tt>.
--   
--   This relation is reflexive; it <i>may</i> be symmetric or not. It
--   tends to be composable: casting complex types usually requires
--   permission to cast their respective parts; for such types consider
--   using <a>castDummyG</a> as implementation of the method of this
--   typeclass.
--   
--   For cases when a cast from <tt>a</tt> to <tt>b</tt> requires some
--   validation, consider rather making a dedicated function which performs
--   the necessary checks and then calls <tt>forcedCoerce</tt>.
class CanCastTo (a :: k) (b :: k1)

-- | An optional method which helps passing -Wredundant-constraints check.
--   Also, you can set specific implementation for it with specific sanity
--   checks.
castDummy :: CanCastTo a b => Proxy a -> Proxy b -> ()

-- | Coercions between <tt>a</tt> to <tt>b</tt> are permitted and safe.
type Coercible_ a b = (MichelsonCoercible a b, CanCastTo a b, CanCastTo b a)

-- | If you apply numeric error representation in your contract,
--   <a>errorFromVal</a> will stop working because it doesn't know about
--   this transformation. This function takes this transformation into
--   account. If a number is used as a tag, but it is not found in the
--   passed map, we conservatively preserve that number (because this whole
--   approach is rather a heuristic).
errorFromValNumeric :: (Typeable t, SingI t, IsError e) => ErrorTagMap -> Value t -> Either Text e

-- | This function implements the simplest scenario of using this module's
--   functionality: 1. Gather all error tags from a single instruction. 2.
--   Turn them into error conversion map. 3. Apply this conversion.
useNumericErrors :: HasCallStack => (inp :-> out) -> (inp :-> out, ErrorTagMap)

-- | Similar to <a>applyErrorTagMap</a>, but for case when you have
--   excluded some tags from map via <a>excludeErrorTags</a>. Needed,
--   because both <a>excludeErrorTags</a> and this function do not tolerate
--   unknown errors in contract code (for your safety).
applyErrorTagMapWithExclusions :: HasCallStack => ErrorTagMap -> ErrorTagExclusions -> (inp :-> out) -> inp :-> out

-- | For each typical <a>FAILWITH</a> that uses a string to represent error
--   tag this function changes error tag to be a number using the supplied
--   conversion map. It assumes that supplied map contains all such strings
--   (and will error out if it does not). It will always be the case if you
--   gather all error tags using <a>gatherErrorTags</a> and build
--   <a>ErrorTagMap</a> from them using <a>addNewErrorTags</a>.
applyErrorTagMap :: HasCallStack => ErrorTagMap -> (inp :-> out) -> inp :-> out

-- | Remove some error tags from map. This way you say to remain these
--   string tags intact, while others will be converted to numbers when
--   this map is applied.
--   
--   Note that later you have to apply this map using
--   <a>applyErrorTagMapWithExclusions</a>, otherwise an error would be
--   raised.
excludeErrorTags :: HasCallStack -> ErrorTagExclusions -> ErrorTagMap -> ErrorTagMap

-- | Build <a>ErrorTagMap</a> from a set of textual tags.
buildErrorTagMap :: HashSet MText -> ErrorTagMap

-- | Add more error tags to an existing <a>ErrorTagMap</a>. It is useful
--   when your contract consists of multiple parts (e. g. in case of
--   contract upgrade), you have existing map for some part and want to add
--   tags from another part to it. You can pass empty map as existing one
--   if you just want to build <a>ErrorTagMap</a> from a set of textual
--   tags. See <a>buildErrorTagMap</a>.
addNewErrorTags :: ErrorTagMap -> HashSet MText -> ErrorTagMap

-- | Find all textual error tags that are used in typical <tt>FAILWITH</tt>
--   patterns within given instruction. Map them to natural numbers.
gatherErrorTags :: () => (inp :-> out) -> HashSet MText

-- | This is a bidirectional map with correspondence between numeric and
--   textual error tags.
type ErrorTagMap = Bimap Natural MText

-- | Tags excluded from map.
type ErrorTagExclusions = HashSet MText

-- | Fail with given error, picking argument for error from the top of the
--   stack.
--   
--   If your error constructor does not carry an argument, use
--   <a>failUsing</a> function instead. Consider the following practice:
--   once error datatype for your contract is defined, create a
--   specialization of this function to the error type.
--   
--   This function is deprecated.
failUsingArg :: () => FailUsingArg err name fieldTy s s'

-- | Derive <a>IsError</a> instance for given type.
--   
--   This will also forbid deriving <a>IsoValue</a> instance for that type
--   to avoid having multiple different Michelson representations.
deriveCustomError :: Name -> Q [Dec]

-- | Implementation of <a>errorFromVal</a> for custom errors.
--   
--   This function is deprecated.
customErrorFromVal :: (SingI t, LooseSumC e) => Value t -> Either Text e

-- | Implementation of <a>errorToVal</a> for custom errors.
customErrorToVal :: (LooseSumC e, HasCallStack) => e -> (forall (t :: T). ErrorScope t => Value t -> r) -> r

-- | Implementation of <a>typeDocMdDescription</a> (of <a>TypeHasDoc</a>
--   typeclass) for Haskell types which sole purpose is to be error.
typeDocMdDescriptionReferToError :: IsError e => Markdown
errorTagToText :: KnownSymbol tag => Text

-- | Demote error tag to term level.
errorTagToMText :: () => Label tag -> MText

-- | Description of error representation in Haskell.
customErrorDocHaskellRepGeneral :: (SingI (ToT (ErrorArg tag)), IsError (CustomError tag), TypeHasDoc (ErrorArg tag), CustomErrorHasDoc tag) => Text -> Proxy tag -> Markdown

-- | Fail, providing a reference to the place in the code where this
--   function is called.
--   
--   Like <a>error</a> in Haskell code, this instruction is for internal
--   errors only.
failUnexpected :: () => MText -> s :-> t

-- | Fail with the given Haskell value.
failUsing :: IsError e => e -> s :-> t

-- | Implementation of <a>errorFromVal</a> via <a>IsoValue</a>.
isoErrorFromVal :: (Typeable t, Typeable (ToT e), IsoValue e) => Value t -> Either Text e

-- | Implementation of <a>errorToVal</a> via <a>IsoValue</a>.
isoErrorToVal :: (KnownError e, IsoValue e) => e -> (forall (t :: T). ErrorScope t => Value t -> r) -> r

-- | Haskell type representing error.
class (Typeable e, ErrorHasDoc e) => IsError e

-- | Converts a Haskell error into <tt>Value</tt> representation.
errorToVal :: IsError e => e -> (forall (t :: T). ErrorScope t => Value t -> r) -> r

-- | Converts a <tt>Value</tt> into Haskell error.
errorFromVal :: (IsError e, Typeable t, SingI t) => Value t -> Either Text e
class Typeable e => ErrorHasDoc e where {
    
    -- | Constraints which we require in a particular instance. You are not
    --   oblidged to often instantiate this correctly, it is only useful for
    --   some utilities.
    type family ErrorRequirements e :: Constraint;
}

-- | Name of error as it appears in the corresponding section title.
errorDocName :: ErrorHasDoc e => Text

-- | What should happen for this error to be raised.
errorDocMdCause :: ErrorHasDoc e => Markdown

-- | Brief version of <a>errorDocMdCause</a>.
--   
--   This will appear along with the error when mentioned in entrypoint
--   description. By default, the first sentence of the full description is
--   used.
errorDocMdCauseInEntrypoint :: ErrorHasDoc e => Markdown

-- | How this error is represented in Haskell.
errorDocHaskellRep :: ErrorHasDoc e => Markdown

-- | Error class.
errorDocClass :: ErrorHasDoc e => ErrorClass

-- | Which definitions documentation for this error mentions.
errorDocDependencies :: ErrorHasDoc e => [SomeDocDefinitionItem]

-- | Captured constraints which we require in a particular instance. This
--   is a way to encode a bidirectional instance in the nowaday Haskell,
--   for <tt>class MyConstraint =&gt; ErrorHasDoc MyType</tt> instance it
--   lets deducing <tt>MyConstraint</tt> by <tt>ErrorHasDoc MyType</tt>.
--   
--   You are not oblidged to always instantiate, it is only useful for some
--   utilities which otherwise would not compile.
errorDocRequirements :: ErrorHasDoc e => Dict (ErrorRequirements e)

-- | Use this type as replacement for <tt>()</tt> when you <b>really</b>
--   want to leave error cause unspecified.
data UnspecifiedError
UnspecifiedError :: UnspecifiedError

-- | Declares a custom error, defining <tt>error name - error argument</tt>
--   relation.
--   
--   If your error is supposed to carry no argument, then provide
--   <tt>()</tt>.
--   
--   Note that this relation is defined globally rather than on
--   per-contract basis, so define errors accordingly. If your error has
--   argument specific to your contract, call it such that error name
--   reflects its belonging to this contract.
--   
--   This is the basic [error format].
type family ErrorArg (tag :: Symbol) :: Type

-- | Material custom error.
--   
--   Use this in pattern matches against error (e.g. in tests).
data CustomError (tag :: Symbol)
CustomError :: Label tag -> ErrorArg tag -> CustomError
[ceTag] :: CustomError -> Label tag
[ceArg] :: CustomError -> ErrorArg tag
type RequireNoArgError (tag :: Symbol) (msg :: ErrorMessage) = (TypeErrorUnless ErrorArg tag == () msg, msg ~ Text "Expected no-arg error, but given error requires argument of type " :<>: ShowType ErrorArg tag)

-- | Error class on how the error should be handled by the client.
data ErrorClass

-- | Normal expected error. Examples: "insufficient balance", "wallet does
--   not exist".
ErrClassActionException :: ErrorClass

-- | Invalid argument passed to entrypoint. Examples: your entrypoint
--   accepts an enum represented as <tt>nat</tt>, and unknown value is
--   provided. This includes more complex cases which involve multiple
--   entrypoints. E.g. API provides iterator interface, middleware should
--   care about using it hiding complex details and exposing a simpler API
--   to user; then an attempt to request non-existing element would also
--   correspond to an error from this class.
ErrClassBadArgument :: ErrorClass

-- | Unexpected error. Most likely it means that there is a bug in the
--   contract or the contract has been deployed incorrectly.
ErrClassContractInternal :: ErrorClass

-- | It's possible to leave error class unspecified.
ErrClassUnknown :: ErrorClass
class (KnownSymbol tag, TypeHasDoc ErrorArg tag, IsError CustomError tag) => CustomErrorHasDoc (tag :: Symbol)

-- | What should happen for this error to be raised.
customErrDocMdCause :: CustomErrorHasDoc tag => Markdown

-- | Brief version of <a>customErrDocMdCause</a>. This will appear along
--   with the error when mentioned in entrypoint description.
--   
--   By default, the first sentence of the full description is used.
customErrDocMdCauseInEntrypoint :: CustomErrorHasDoc tag => Markdown

-- | Error class.
--   
--   By default this returns "unknown error" class; though you should
--   provide explicit implementation in order to avoid a warning.
customErrClass :: CustomErrorHasDoc tag => ErrorClass

-- | Clarification of error argument meaning.
--   
--   Provide when it's not obvious, e.g. argument is not named with
--   <tt>:!</tt>.
--   
--   NOTE: This should <i>not</i> be an entire sentence, rather just the
--   semantic backbone.
--   
--   Bad: * <tt>Error argument stands for the previous value of
--   approval.</tt>
--   
--   Good: * <tt>the previous value of approval</tt> * <tt>pair, first
--   argument of which is one thing, and the second is another</tt>
customErrArgumentSemantics :: CustomErrorHasDoc tag => Maybe Markdown

-- | Mentions that contract uses given error.
data DError
[DError] :: forall e. ErrorHasDoc e => Proxy e -> DError

-- | Documentation for custom errors.
--   
--   Mentions that entrypoint throws given error.
data DThrows
[DThrows] :: forall e. ErrorHasDoc e => Proxy e -> DThrows

-- | Prompt an error message saying that <a>IsoValue</a> is not applicable
--   for this type.
type family CustomErrorNoIsoValue (a :: t) :: k

-- | Signature of <tt>userFailWith</tt>.
type FailUsingArg e (name :: Symbol) fieldTy (s :: [Type]) (s' :: [Type]) = KnownSymbol name -> IsError e -> IsoValue fieldTy -> CtorHasOnlyField name e fieldTy -> Each (Typeable :: T -> Constraint) : (SingI :: T -> Constraint) : ([] :: [T -> Constraint]) ToT fieldTy : ([] :: [T]) -> HasCallStack -> Label name -> fieldTy : s :-> s'

-- | Gathers multple fields and <a>BigMap</a>s under one object.
--   
--   Type argument of this datatype stands for a "store template" - a
--   datatype with one constructor and multiple fields, each containing an
--   object of type <a>UStoreFieldExt</a> or <a>|~&gt;</a> and
--   corresponding to single virtual field or <a>BigMap</a> respectively.
--   It's also possible to parameterize it with a larger type which is a
--   product of types satisfying the above property.
data UStore a

-- | Describes one virtual big map in the storage.
newtype (|~>) k v
UStoreSubMap :: Map k v -> (|~>) k v
[unUStoreSubMap] :: (|~>) k v -> Map k v

-- | Describes plain field in the storage.
newtype UStoreFieldExt (m :: UStoreMarkerType) v
UStoreField :: v -> UStoreFieldExt v
[unUStoreField] :: UStoreFieldExt v -> v

-- | Specific kind used to designate markers for <a>UStoreFieldExt</a>.
--   
--   We suggest that fields may serve different purposes and so annotated
--   with special markers accordingly. See example below.
--   
--   This kind is implemented like that because we want markers to differ
--   from all other types in kind; herewith <a>UStoreMarkerType</a> is
--   still an open kind (has potentially infinite number of inhabitants).
type UStoreMarkerType = UStoreMarker -> Type

-- | Just a plain field used as data.
type UStoreField = UStoreFieldExt UMarkerPlainField

-- | Allows to specify format of key under which fields of this type are
--   stored. Useful to avoid collisions.
class KnownUStoreMarker (marker :: UStoreMarkerType) where {
    
    -- | Display type-level information about UStore field with given marker
    --   and field value type. Used for error messages.
    type family ShowUStoreField (marker :: UStoreMarkerType) v :: ErrorMessage;
}

-- | By field name derive key under which field should be stored.
mkFieldMarkerUKey :: KnownUStoreMarker marker => MText -> ByteString

-- | Get type of submap key.
type GetUStoreKey store (name :: Symbol) = MSKey GetUStore name store

-- | Get type of submap value.
type GetUStoreValue store (name :: Symbol) = MSValue GetUStore name store

-- | Get type of plain field. This ignores marker with field type.
type GetUStoreField store (name :: Symbol) = FSValue GetUStore name store

-- | Get kind of field.
type GetUStoreFieldMarker store (name :: Symbol) = FSMarker GetUStore name store

-- | Collect all fields with the given marker.
type PickMarkedFields (marker :: UStoreMarkerType) template = GPickMarkedFields marker Rep template

-- | Leave only instructions related to documentation.
--   
--   This function is useful when your method executes a lambda coming from
--   outside, but you know its properties and want to propagate its
--   documentation to your contract code.
cutLorentzNonDoc :: () => (inp :-> out) -> s :-> s
renderLorentzDoc :: () => (inp :-> out) -> LText
buildLorentzDoc :: () => (inp :-> out) -> ContractDoc

-- | Remove element with the given type from the stack.
dropT :: (DipT inp a inp dinp dout out, dinp ~ (a : dout)) => inp :-> out

-- | Dip repeatedly until element of the given type is on top of the stack.
--   
--   If stack contains multiple entries of this type, compile error is
--   raised.
dipT :: DipT inp a inp dinp dout out => (dinp :-> dout) -> inp :-> out

-- | Duplicate an element of stack referring it by type.
--   
--   If stack contains multiple entries of this type, compile error is
--   raised.
dupT :: DupT st a st => st :-> (a : st)

-- | Lifted <tt>AithOp</tt>.
class (ArithOp aop ToCT n ToCT m, IsComparable n, IsComparable m, Typeable ToCT n, Typeable ToCT m, ToT ArithResHs aop n m ~ Tc ArithRes aop ToCT n ToCT m) => ArithOpHs aop n m where {
    type family ArithResHs aop n m :: Type;
}

-- | Lifted <tt>UnaryAithOp</tt>.
class (UnaryArithOp aop ToCT n, IsComparable n, Typeable ToCT n, ToT UnaryArithResHs aop n ~ Tc UnaryArithRes aop ToCT n) => UnaryArithOpHs aop n where {
    type family UnaryArithResHs aop n :: Type;
}

-- | Pretty-print a Lorentz contract into Michelson code.
printLorentzContract :: (NiceParameterFull cp, NiceStorage st) => Bool -> ContractCode cp st -> LText

-- | Pretty-print a Haskell value as Michelson one.
printLorentzValue :: NicePrintedValue v => Bool -> v -> LText

-- | Lorentz version of analyzer.
analyzeLorentz :: () => (inp :-> out) -> AnalyzerRes

-- | Like <a>interpretLorentzInstr</a>, but works on lambda rather than
--   arbitrary instruction.
interpretLorentzLambda :: (IsoValue inp, IsoValue out) => ContractEnv -> Lambda inp out -> inp -> Either MichelsonFailed out

-- | Interpret a Lorentz instruction, for test purposes.
interpretLorentzInstr :: (IsoValuesStack inp, IsoValuesStack out) => ContractEnv -> (inp :-> out) -> Rec Identity inp -> Either MichelsonFailed (Rec Identity out)

-- | Version on <a>compileLorentzContract</a> which accepts
--   <tt>CompilationOptions</tt>.
--   
--   Note that compiled contract can be ill-typed in terms of Michelson
--   code when some of the compilation options are used (e.g. when
--   coDoInitialCast is False, resulted contract can be ill-typed).
--   However, compilation with <tt>defaultCompilationOptions</tt> should be
--   valid.
compileLorentzContractWithOptions :: (NiceParameterFull cp, NiceStorage st) => CompilationOptions -> ContractCode cp st -> FullContract (ToT cp) (ToT st)

-- | Version of <a>compileLorentz</a> specialized to instruction
--   corresponding to contract code.
compileLorentzContract :: (NiceParameterFull cp, NiceStorage st) => ContractCode cp st -> FullContract (ToT cp) (ToT st)

-- | For use outside of Lorentz.
compileLorentz :: () => (inp :-> out) -> Instr (ToTs inp) (ToTs out)
data CompilationOptions
CompilationOptions :: Bool -> CompilationOptions

-- | Flag which defines, whether compiled Michelson contract will have
--   <tt>CAST</tt> (which drops parameter annotations) as a first
--   instruction. Note, that when flag is false, there still can be no
--   <tt>CAST</tt> (in case when parameter type has no annotations).
[coDisableInitialCast] :: CompilationOptions -> Bool

-- | Implementation of <a>ParameterHasEntryPoints</a> which fits for case
--   when your contract exposes multiple entrypoints via having sum type as
--   its parameter.
--   
--   In particular, each constructor would produce a homonymous entrypoint
--   with argument type equal to type of constructor field (each
--   constructor should have only one field). Constructor called
--   <a>Default</a> will designate the default entrypoint.
data EpdPlain

-- | Extension of <a>EpdPlain</a> on parameters being defined as several
--   nested datatypes.
--   
--   In particular, this will traverse sum types recursively, stopping at
--   Michelson primitives (like <a>Natural</a>) and constructors with
--   number of fields different from one.
--   
--   It does not assign names to intermediate nodes of <a>Or</a> tree, only
--   to the very leaves.
--   
--   If some entrypoint arguments have custom <a>IsoValue</a> instance,
--   this derivation way will not work. As a workaround, you can wrap your
--   argument into some primitive (e.g. <tt>:!</tt>).
data EpdRecursive

-- | Extension of <a>EpdPlain</a> on parameters being defined as several
--   nested datatypes.
--   
--   In particular, it will traverse the immediate sum type, and require
--   another <a>ParameterHasEntryPoints</a> for the inner complex
--   datatypes. Only those inner types are considered which are the only
--   fields in their respective constructors. Inner types should not
--   themselves declare default entrypoint, we enforce this for better
--   modularity. Each top-level constructor will be treated as entrypoint
--   even if it contains a complex datatype within, in such case that would
--   be an entrypoint corresponding to intermediate node in <tt>or</tt>
--   tree.
--   
--   Comparing to <a>EpdRecursive</a> this gives you more control over
--   where and how entrypoints will be derived.
data EpdDelegate
type List = []
convertContractRef :: (ToContractRef cp contract1, FromContractRef cp contract2) => contract1 -> contract2

-- | Specification of <tt>callTAddress</tt> to call the default entrypoint.
callingDefTAddress :: NiceParameterFull cp => TAddress cp -> ContractRef (GetDefaultEntryPointArg cp)

-- | Turn <a>TAddress</a> to <a>ContractRef</a> in <i>Haskell</i> world.
--   
--   This is an analogy of <tt>address</tt> to <tt>contract</tt> convertion
--   in Michelson world, thus you have to supply an entrypoint (or call the
--   default one explicitly).
callingTAddress :: NiceParameterFull cp => TAddress cp -> EntryPointRef mname -> ContractRef (GetEntryPointArgCustom cp mname)

-- | Address which remembers the parameter type of the contract it refers
--   to.
--   
--   It differs from Michelson's <tt>contract</tt> type because it cannot
--   contain entrypoint, and it always refers to entire contract parameter
--   even if this contract has explicit default entrypoint.
newtype TAddress (p :: k) :: forall k. () => k -> Type
TAddress :: Address -> TAddress
[unTAddress] :: TAddress -> Address

-- | Address associated with value of <tt>contract arg</tt> type.
--   
--   Places where <a>ContractRef</a> can appear are now severely limited,
--   this type gives you type-safety of <a>ContractRef</a> but still can be
--   used everywhere. This type is not a full-featured one rather a helper;
--   in particular, once pushing it on stack, you cannot return it back to
--   Haskell world.
--   
--   Note that it refers to an entrypoint of the contract, not just the
--   contract as a whole. In this sense this type differs from
--   <a>TAddress</a>.
--   
--   Unlike with <a>ContractRef</a>, having this type you still cannot be
--   sure that the referred contract exists and need to perform a lookup
--   before calling it.
newtype FutureContract arg
FutureContract :: ContractRef arg -> FutureContract arg
[unFutureContract] :: FutureContract arg -> ContractRef arg

-- | Convert something to <a>Address</a> in <i>Haskell</i> world.
--   
--   Use this when you want to access state of the contract and are not
--   interested in calling it.
class ToAddress a
toAddress :: ToAddress a => a -> Address

-- | Convert something referring to a contract (not specific entrypoint) to
--   <a>TAddress</a> in <i>Haskell</i> world.
class ToTAddress cp a
toTAddress :: ToTAddress cp a => a -> TAddress cp

-- | Convert something to <a>ContractRef</a> in <i>Haskell</i> world.
class ToContractRef cp contract
toContractRef :: ToContractRef cp contract => contract -> ContractRef cp

-- | Convert something from <tt>ContractAddr</tt> in <i>Haskell</i> world.
class FromContractRef cp contract
fromContractRef :: FromContractRef cp contract => ContractRef cp -> contract

-- | Single entrypoint of a contract.
--   
--   Note that we cannot make it return <tt>[[Operation], store]</tt>
--   because such entrypoint should've been followed by <tt>pair</tt>, and
--   this is not possible if entrypoint implementation ends with
--   <tt>failWith</tt>.
type Entrypoint param store = param : store : ([] :: [Type]) :-> ContractOut store

-- | Version of <a>Entrypoint</a> which accepts no argument.
type Entrypoint_ store = store : ([] :: [Type]) :-> ContractOut store
stackType :: () => s :-> s
testAssert :: (Typeable (ToTs out), HasCallStack) => Text -> PrintComment (ToTs inp) -> (inp :-> (Bool & out)) -> inp :-> inp
printComment :: () => PrintComment (ToTs s) -> s :-> s
stackRef :: (n ~ ToPeano gn, SingI n, KnownPeano n, RequireLongerThan st n) => PrintComment st
optimizeLorentz :: () => (inp :-> out) -> inp :-> out
optimizeLorentzWithConf :: () => OptimizerConf -> (inp :-> out) -> inp :-> out

-- | Lorentz version of <a>transformBytes</a>.
transformBytesLorentz :: () => Bool -> (ByteString -> ByteString) -> (inp :-> out) -> inp :-> out

-- | Lorentz version of <a>transformStrings</a>.
transformStringsLorentz :: () => Bool -> (MText -> MText) -> (inp :-> out) -> inp :-> out

-- | Parse textual representation of a Michelson value and turn it into
--   corresponding Haskell value.
--   
--   Note: it won't work in some complex cases, e. g. if there is a lambda
--   which uses an instruction which depends on current contract's type.
--   Obviously it can not work, because we don't have any information about
--   a contract to which this value belongs (there is no such contract at
--   all).
parseLorentzValue :: (IsoValue v, SingI (ToT v), Typeable (ToT v)) => Text -> Either ParseLorentzError v

-- | Version of <a>#</a> which performs some optimizations immediately.
(##) :: () => (a :-> b) -> (b :-> c) -> a :-> c
(#) :: () => (a :-> b) -> (b :-> c) -> a :-> c
infixl 8 #

-- | Wrap Lorentz instruction with variable annotations, <tt>annots</tt>
--   list has to be non-empty, otherwise this function raises an error.
iWithVarAnnotations :: HasCallStack => [Text] -> (inp :-> out) -> inp :-> out
iForceNotFail :: () => (i :-> o) -> i :-> o
iMapAnyCode :: () => (forall (o' :: [T]). () => Instr (ToTs i1) o' -> Instr (ToTs i2) o') -> (i1 :-> o) -> i2 :-> o
iNonFailingCode :: HasCallStack => (inp :-> out) -> Instr (ToTs inp) (ToTs out)
iAnyCode :: () => (inp :-> out) -> Instr (ToTs inp) (ToTs out)
iGenericIf :: () => (forall (s' :: [T]). () => Instr (ToTs a) s' -> Instr (ToTs b) s' -> Instr (ToTs c) s') -> (a :-> s) -> (b :-> s) -> c :-> s
pattern I :: forall (inp :: [Type]) (out :: [Type]). () => () => Instr (ToTs inp) (ToTs out) -> inp :-> out
pattern FI :: forall (inp :: [Type]) (out :: [Type]). () => () => (forall (out' :: [T]). () => Instr (ToTs inp) out') -> inp :-> out

-- | Alias for instruction which hides inner types representation via
--   <tt>T</tt>.
newtype (:->) (inp :: [Type]) (out :: [Type])
LorentzInstr :: RemFail Instr (ToTs inp) (ToTs out) -> (:->)
[unLorentzInstr] :: (:->) -> RemFail Instr (ToTs inp) (ToTs out)
infixr 1 :->

-- | Alias for <a>:-&gt;</a>, seems to make signatures more readable
--   sometimes.
--   
--   Let's someday decide which one of these two should remain.
type (%>) = (:->)
infixr 1 %>
type ContractOut st = ([Operation], st) : ([] :: [Type])
type ContractCode cp st = (cp, st) : ([] :: [Type]) :-> ContractOut st
data SomeContract
[SomeContract] :: forall cp st. (NiceParameterFull cp, NiceStorage st) => ContractCode cp st -> SomeContract
type (&) a (b :: [Type]) = a : b
infixr 2 &
type Lambda i o = i : ([] :: [Type]) :-> o : ([] :: [Type])

-- | Wrap parameter into this to locally assign a way to derive entrypoints
--   for it.
newtype ParameterWrapper deriv cp
ParameterWrapper :: cp -> ParameterWrapper deriv cp
[unParameterWraper] :: ParameterWrapper deriv cp -> cp
lEncodeValue :: NicePrintedValue a => a -> ByteString
lUnpackValue :: NiceUnpackedValue a => ByteString -> Either UnpackError a
lPackValue :: NicePackedValue a => a -> ByteString

-- | Constraint applied to a whole parameter type.
type NiceParameterFull cp = (Typeable cp, ParameterDeclaresEntryPoints cp)

-- | Universal entrypoint calling.
parameterEntryPointCallCustom :: ParameterDeclaresEntryPoints cp => EntryPointRef mname -> EntryPointCall cp (GetEntryPointArgCustom cp mname)
eprName :: () => EntryPointRef mname -> EpName

-- | Call root entrypoint safely.
sepcCallRootChecked :: (NiceParameter cp, ForbidExplicitDefaultEntryPoint cp) => SomeEntryPointCall cp

-- | Call the default entrypoint.
parameterEntryPointCallDefault :: ParameterDeclaresEntryPoints cp => EntryPointCall cp (GetDefaultEntryPointArg cp)

-- | Prepare call to given entrypoint.
--   
--   This does not treat calls to default entrypoint in a special way. To
--   call default entrypoint properly use
--   <a>parameterEntryPointCallDefault</a>.
parameterEntryPointCall :: ParameterDeclaresEntryPoints cp => Label name -> EntryPointCall cp (GetEntryPointArg cp name)

-- | Derive annotations for given parameter.
parameterEntryPointsToNotes :: (Typeable cp, ParameterDeclaresEntryPoints cp) => ParamNotes (ToT cp)

-- | Defines a generalized way to declare entrypoints for various parameter
--   types.
--   
--   When defining instances of this typeclass, set concrete <tt>deriv</tt>
--   argument and leave variable <tt>cp</tt> argument. Also keep in mind,
--   that in presence of explicit default entrypoint, all other <a>Or</a>
--   arms should be callable, though you can put this burden on user if
--   very necessary.
--   
--   Methods of this typeclass aim to better type-safety when making up an
--   implementation and they may be not too convenient to use; users should
--   exploit their counterparts.
class EntryPointsDerivation (deriv :: k) cp where {
    
    -- | Name and argument of each entrypoint. This may include intermediate
    --   ones, even root if necessary.
    --   
    --   Touching this type family is costly (<tt>O(N^2)</tt>), don't use it
    --   often.
    --   
    --   Note [order of entrypoints children]: If this contains entrypoints
    --   referring to indermediate nodes (not leaves) in <tt>or</tt> tree, then
    --   each such entrypoint should be mentioned eariler than all of its
    --   children.
    type family EpdAllEntryPoints (deriv :: k) cp :: [(Symbol, Type)];
    
    -- | Get entrypoint argument by name.
    type family EpdLookupEntryPoint (deriv :: k) cp :: Symbol -> Exp Maybe Type;
}

-- | Construct parameter annotations corresponding to expected entrypoints
--   set.
--   
--   This method is implementation detail, for actual notes construction
--   use <a>parameterEntryPointsToNotes</a>.
--   
--   TODO [#35]: Should also return field annotation
epdNotes :: EntryPointsDerivation deriv cp => Notes (ToT cp)

-- | Construct entrypoint caller.
--   
--   This does not treat calls to default entrypoint in a special way.
--   
--   This method is implementation detail, for actual entrypoint lookup use
--   <a>parameterEntryPointCall</a>.
epdCall :: (EntryPointsDerivation deriv cp, ParameterScope (ToT cp)) => Label name -> EpConstructionRes (ToT cp) (Eval (EpdLookupEntryPoint deriv cp name))

-- | Description of how each of the entrypoints is constructed.
epdDescs :: EntryPointsDerivation deriv cp => Rec EpCallingDesc (EpdAllEntryPoints deriv cp)

-- | Ensure that all declared entrypoints are unique.
type RequireAllUniqueEntryPoints cp = RequireAllUniqueEntryPoints' ParameterEntryPointsDerivation cp cp

-- | Which entrypoints given parameter declares.
--   
--   Note that usually this function should not be used as constraint, use
--   <a>ParameterDeclaresEntryPoints</a> for this purpose.
class (EntryPointsDerivation ParameterEntryPointsDerivation cp cp, RequireAllUniqueEntryPoints cp) => ParameterHasEntryPoints cp where {
    type family ParameterEntryPointsDerivation cp :: Type;
}

-- | Parameter declares some entrypoints.
--   
--   This is a version of <a>ParameterHasEntryPoints</a> which we actually
--   use in constraints. When given type is a sum type or newtype, we refer
--   to <a>ParameterHasEntryPoints</a> instance, otherwise this instance is
--   not necessary.
type ParameterDeclaresEntryPoints cp = (If CanHaveEntryPoints cp ParameterHasEntryPoints cp (), NiceParameter cp, EntryPointsDerivation GetParameterEpDerivation cp cp)

-- | Get all entrypoints declared for parameter.
type family AllParameterEntryPoints cp :: [(Symbol, Type)]

-- | Lookup for entrypoint type by name.
--   
--   Does not treat default entrypoints in a special way.
type family LookupParameterEntryPoint cp :: Symbol -> Exp Maybe Type

-- | Get type of entrypoint with given name, fail if not found.
type GetEntryPointArg cp (name :: Symbol) = Eval LiftM2 (FromMaybe :: Type -> Maybe Type -> Type -> Type) (TError Text "Entrypoint not found: " :<>: ShowType name :$$: Text "In contract parameter `" :<>: ShowType cp :<>: Text "`" :: Type -> Type) LookupParameterEntryPoint cp name

-- | Get type of entrypoint with given name, fail if not found.
type GetDefaultEntryPointArg cp = Eval LiftM2 (FromMaybe :: Type -> Maybe Type -> Type -> Type) Pure cp LookupParameterEntryPoint cp DefaultEpName

-- | Ensure that there is no explicit "default" entrypoint.
type ForbidExplicitDefaultEntryPoint cp = Eval LiftM3 (UnMaybe :: Exp Constraint -> Type -> Exp Constraint -> Maybe Type -> Constraint -> Type) Pure Pure () (TError Text "Parameter used here must have no explicit \"default\" entrypoint" :$$: Text "In parameter type `" :<>: ShowType cp :<>: Text "`" :: Type -> Exp Constraint -> Type) LookupParameterEntryPoint cp DefaultEpName

-- | Similar to <a>ForbidExplicitDefaultEntryPoint</a>, but in a version
--   which the compiler can work with (and which produces errors confusing
--   for users :/)
type NoExplicitDefaultEntryPoint cp = Eval LookupParameterEntryPoint cp DefaultEpName ~ (Nothing :: Maybe Type)

-- | Which entrypoint to call.
--   
--   We intentionally distinguish default and non-default cases because
--   this makes API more details-agnostic.
data EntryPointRef (mname :: Maybe Symbol)

-- | Call the default entrypoint, or root if no explicit default is
--   assigned.
[CallDefault] :: forall (mname :: Maybe Symbol). () => EntryPointRef (Nothing :: Maybe Symbol)

-- | Call the given entrypoint; calling default is not treated specially.
--   You have to provide entrypoint name via passing it as type argument.
--   
--   Unfortunatelly, here we cannot accept a label because in most cases
--   our entrypoints begin from capital letter (being derived from
--   constructor name), while labels must start from a lower-case letter,
--   and there is no way to make a conversion at type-level.
[Call] :: forall (mname :: Maybe Symbol) (name :: Symbol). NiceEntryPointName name => EntryPointRef (Just name)

-- | Universal entrypoint lookup.
type family GetEntryPointArgCustom cp (mname :: Maybe Symbol) :: Type

-- | When we call a Lorentz contract we should pass entrypoint name and
--   corresponding argument. Ideally we want to statically check that
--   parameter has entrypoint with given name and argument. Constraint
--   defined by this type class holds for contract with parameter
--   <tt>cp</tt> that have entrypoint matching <tt>name</tt> with type
--   <tt>arg</tt>.
--   
--   In order to check this property statically, we need to know entrypoint
--   name in compile time, <a>EntryPointRef</a> type serves this purpose.
--   If entrypoint name is not known, one can use <a>TrustEpName</a>
--   wrapper to take responsibility for presence of this entrypoint.
--   
--   If you want to call a function which has this constraint, you have two
--   options: 1. Pass contract parameter <tt>cp</tt> using type
--   application, pass <a>EntryPointRef</a> as a value and pass entrypoint
--   argument. Type system will check that <tt>cp</tt> has an entrypoint
--   with given reference and type. 2. Pass <a>EpName</a> wrapped into
--   <a>TrustEpName</a> and entrypoint argument. In this case passing
--   contract parameter is not necessary, you do not even have to know it.
class HasEntryPointArg (cp :: k) name arg

-- | Data returned by this method may look somewhat arbitrary.
--   <a>EpName</a> is obviously needed because <tt>name</tt> can be
--   <a>EntryPointRef</a> or <a>TrustEpName</a>. <tt>Dict</tt> is returned
--   because in <a>EntryPointRef</a> case we get this evidence for free and
--   don't want to use it. We seem to always need it anyway.
useHasEntryPointArg :: HasEntryPointArg cp name arg => name -> (Dict (ParameterScope (ToT arg)), EpName)

-- | <a>HasEntryPointArg</a> constraint specialized to default entrypoint.
type HasDefEntryPointArg (cp :: k) defEpName defArg = (defEpName ~ EntryPointRef (Nothing :: Maybe Symbol), HasEntryPointArg cp defEpName defArg)

-- | This wrapper allows to pass untyped <a>EpName</a> and bypass checking
--   that entrypoint with given name and type exists.
newtype TrustEpName
TrustEpName :: EpName -> TrustEpName

-- | Checks that the given parameter consists of some specific entrypoint.
--   Similar as <a>HasEntryPointArg</a> but ensures that the argument
--   matches the following datatype.
type HasEntryPointOfType param (con :: Symbol) exp = (GetEntryPointArgCustom param Just con ~ exp, ParameterDeclaresEntryPoints param)
type (:>) (n :: Symbol) ty = NamedEp n ty
infixr 0 :>

-- | Check that the given entrypoint has some fields inside. This interface
--   allows for an abstraction of contract parameter so that it requires
--   some *minimal* specification, but not a concrete one.
type family ParameterContainsEntryPoints param (fields :: [NamedEp]) :: Constraint

-- | No entrypoints declared, parameter type will serve as argument type of
--   the only existing entrypoint (default one).
data EpdNone

-- | Lifted <a>MemOpKey</a>.
class (MemOp ToT c, ToT MemOpKeyHs c ~ Tc MemOpKey ToT c) => MemOpHs c where {
    type family MemOpKeyHs c :: Type;
}

-- | A useful property which holds for reasonable <a>MapOp</a> instances.
--   
--   It's a separate thing from <a>MapOpHs</a> because it mentions
--   <tt>b</tt> type parameter.
type family IsoMapOpRes c b :: Constraint

-- | Lifted <a>MapOp</a>.
class (MapOp ToT c, ToT MapOpInpHs c ~ MapOpInp ToT c, ToT MapOpResHs c () ~ MapOpRes ToT c ToT ()) => MapOpHs c where {
    type family MapOpInpHs c :: Type;
    type family MapOpResHs c :: Type -> Type;
}

-- | Lifted <a>IterOp</a>.
class (IterOp ToT c, ToT IterOpElHs c ~ IterOpEl ToT c) => IterOpHs c where {
    type family IterOpElHs c :: Type;
}

-- | Lifted <a>SizeOp</a>.
--   
--   This could be just a constraint alias, but to avoid <a>T</a> types
--   appearance in error messages we make a full type class with concrete
--   instances.
class SizeOp ToT c => SizeOpHs c

-- | Lifted <a>UpdOp</a>.
class (UpdOp ToT c, ToT UpdOpKeyHs c ~ Tc UpdOpKey ToT c, ToT UpdOpParamsHs c ~ UpdOpParams ToT c) => UpdOpHs c where {
    type family UpdOpKeyHs c :: Type;
    type family UpdOpParamsHs c :: Type;
}

-- | Lifted <a>GetOp</a>.
class (GetOp ToT c, ToT GetOpKeyHs c ~ Tc GetOpKey ToT c, ToT GetOpValHs c ~ GetOpVal ToT c) => GetOpHs c where {
    type family GetOpKeyHs c :: Type;
    type family GetOpValHs c :: Type;
}

-- | Lifted <a>ConcatOp</a>.
class ConcatOp ToT c => ConcatOpHs c

-- | Lifted <a>SliceOp</a>.
class SliceOp ToT c => SliceOpHs c

-- | Lifted <a>EDivOp</a>.
class (EDivOp ToCT n ToCT m, IsComparable n, IsComparable m, ToT EDivOpResHs n m ~ Tc EDivOpRes ToCT n ToCT m, ToT EModOpResHs n m ~ Tc EModOpRes ToCT n ToCT m) => EDivOpHs n m where {
    type family EDivOpResHs n m :: Type;
    type family EModOpResHs n m :: Type;
}

-- | A special type which wraps over a primitive type and states that it
--   has entrypoints (one).
--   
--   Assuming that any type can have entrypoints makes use of Lorentz
--   entrypoints too annoying, so for declaring entrypoints for not sum
--   types we require an explicit wrapper.
newtype ShouldHaveEntryPoints a
ShouldHaveEntryPoints :: a -> ShouldHaveEntryPoints a
[unHasEntryPoints] :: ShouldHaveEntryPoints a -> a
nicePrintedValueEvi :: () => NicePrintedValue a :- PrintedValScope (ToT a)
niceUnpackedValueEvi :: () => NiceUnpackedValue a :- UnpackedValScope (ToT a)
nicePackedValueEvi :: () => NicePackedValue a :- PackedValScope (ToT a)
niceConstantEvi :: () => NiceConstant a :- ConstantScope (ToT a)
niceStorageEvi :: () => NiceStorage a :- StorageScope (ToT a)
niceParameterEvi :: () => NiceParameter a :- ParameterScope (ToT a)

-- | Gathers constraints, commonly required for values.
class (IsoValue a, Typeable ToT a, SingI ToT a) => KnownValue a
class (IsoValue a, Typeable ToCT a, SingI ToCT a) => KnownCValue a

-- | Ensure given type does not contain "operation".
class (IsoValue a, ForbidOp ToT a) => NoOperation a
class (IsoValue a, ForbidContract ToT a) => NoContractType a
class (IsoValue a, ForbidBigMap ToT a) => NoBigMap a
class (IsoValue a, HasNoNestedBigMaps ToT a) => CanHaveBigMap a

-- | Constraint applied to any part of parameter type.
--   
--   Note that you don't usually apply this constraint to the whole
--   parameter, consider using <a>NiceParameterFull</a> in such case.
--   
--   Using this type is justified e.g. when calling another contract, there
--   you usually supply an entrypoint argument, not the whole parameter.
type NiceParameter a = (KnownValue a, ProperParameterBetterErrors ToT a)
type NiceStorage a = (KnownValue a, ProperStorageBetterErrors ToT a)
type NiceConstant a = (KnownValue a, ProperConstantBetterErrors ToT a)
type NicePackedValue a = (KnownValue a, ProperPackedValBetterErrors ToT a)
type NiceUnpackedValue a = (KnownValue a, ProperUnpackedValBetterErrors ToT a)
type NiceFullPackedValue a = (NicePackedValue a, NiceUnpackedValue a)
type NicePrintedValue a = (KnownValue a, ProperPrintedValBetterErrors ToT a)
type NiceComparable a = (KnownValue a, ProperComparabilityBetterErrors ToT a)

-- | A record is parameterized by a universe <tt>u</tt>, an interpretation
--   <tt>f</tt> and a list of rows <tt>rs</tt>. The labels or indices of
--   the record are given by inhabitants of the kind <tt>u</tt>; the type
--   of values at any label <tt>r :: u</tt> is given by its interpretation
--   <tt>f r :: *</tt>.
data Rec (a :: u -> Type) (b :: [u]) :: forall u. () => u -> Type -> [u] -> Type
[RNil] :: forall u (a :: u -> Type) (b :: [u]). () => Rec a ([] :: [u])
[:&] :: forall u (a :: u -> Type) (b :: [u]) (r :: u) (rs :: [u]). () => !a r -> !Rec a rs -> Rec a (r : rs)
infixr 7 :&

-- | <a>arg</a> unwraps a named parameter with the specified name. One way
--   to use it is to match on arguments with <tt>-XViewPatterns</tt>:
--   
--   <pre>
--   fn (arg #t -&gt; t) (arg #f -&gt; f) = ...
--   </pre>
--   
--   This way, the names of parameters can be inferred from the patterns:
--   no type signature for <tt>fn</tt> is required. In case a type
--   signature for <tt>fn</tt> is provided, the parameters must come in the
--   same order:
--   
--   <pre>
--   fn :: "t" :! Integer -&gt; "f" :! Integer -&gt; ...
--   fn (arg #t -&gt; t) (arg #f -&gt; f) = ... -- ok
--   fn (arg #f -&gt; f) (arg #t -&gt; t) = ... -- does not typecheck
--   </pre>
arg :: () => Name name -> (name :! a) -> a

-- | <a>argF</a> is similar to <a>arg</a>: it unwraps a named parameter
--   with the specified name. The difference is that the result of
--   <a>argF</a> is inside an arity wrapper, which is <a>Identity</a> for
--   normal parameters and <a>Maybe</a> for optional parameters.
argF :: () => Name name -> NamedF f a name -> f a

-- | A variation of <a>arg</a> for optional arguments. Requires a default
--   value to handle the case when the optional argument was omitted:
--   
--   <pre>
--   fn (argDef #answer 42 -&gt; ans) = ...
--   </pre>
--   
--   In case you want to get a value wrapped in <a>Maybe</a> instead, use
--   <a>argF</a> or <a>ArgF</a>.
argDef :: () => Name name -> a -> (name :? a) -> a

-- | Infix notation for the type of a named parameter.
type (:!) (name :: Symbol) a = NamedF Identity a name

-- | Infix notation for the type of an optional named parameter.
type (:?) (name :: Symbol) a = NamedF Maybe a name

-- | A piece of markdown document.
--   
--   This is opposed to <a>Text</a> type, which in turn is not supposed to
--   contain markup elements.
type Markdown = Builder

-- | Entrypoint name.
--   
--   Empty if this entrypoint is default one. Cannot be equal to "default",
--   the reference implementation forbids that. Also, set of allowed
--   characters should be the same as in annotations.
data EpName
pattern DefEpName :: () => () => EpName

-- | Proxy for a label type that includes the <a>KnownSymbol</a> constraint
data Label (name :: Symbol)
[Label] :: forall (name :: Symbol). KnownSymbol name => Label name

-- | Michelson string value.
--   
--   This is basically a mere text with limits imposed by the language:
--   <a>https://tezos.gitlab.io/whitedoc/michelson.html#constants</a>
--   Although, this document seems to be not fully correct, and thus we
--   applied constraints deduced empirically.
--   
--   You construct an item of this type using one of the following ways:
--   
--   <ul>
--   <li>With QuasyQuotes when need to create a string literal.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; [mt|Some text|]
--   MTextUnsafe { unMText = "Some text" }
--   </pre>
--   
--   <ul>
--   <li>With <a>mkMText</a> when constructing from a runtime text
--   value.</li>
--   <li>With <a>mkMTextUnsafe</a> or <a>MTextUnsafe</a> when absolutelly
--   sure that given string does not violate invariants.</li>
--   <li>With <a>mkMTextCut</a> when not sure about text contents and want
--   to make it compliant with Michelson constraints.</li>
--   </ul>
data MText

-- | QuasyQuoter for constructing Michelson strings.
--   
--   Validity of result will be checked at compile time. Note:
--   
--   <ul>
--   <li>slash must be escaped</li>
--   <li>newline character must appear as '\n'</li>
--   <li>use quotes as is</li>
--   <li>other special characters are not allowed.</li>
--   </ul>
mt :: QuasiQuoter

-- | Blake2b_160 hash of a public key.
data KeyHash

-- | Cryptographic signatures used by Tezos. Constructors correspond to
--   <a>PublicKey</a> constructors.
--   
--   Tezos distinguishes signatures for different curves. For instance,
--   ed25519 signatures and secp256k1 signatures are printed differently
--   (have different prefix). However, signatures are packed without
--   information about the curve. For this purpose there is a generic
--   signature which only stores bytes and doesn't carry information about
--   the curve. Apparently unpacking from bytes always produces such
--   signature. Unpacking from string produces a signature with curve
--   information.
data Signature

-- | Public cryptographic key used by Tezos. There are three cryptographic
--   curves each represented by its own constructor.
data PublicKey

-- | Identifier of a network (babylonnet, mainnet, test network or other).
--   Evaluated as hash of the genesis block.
--   
--   The only operation supported for this type is packing. Use case:
--   multisig contract, for instance, now includes chain ID into signed
--   data "in order to add extra replay protection between the main chain
--   and the test chain".
data ChainId

-- | Time in the real world. Use the functions below to convert it to/from
--   Unix time in seconds.
data Timestamp

-- | Mutez is a wrapper over integer data type. 1 mutez is 1 token (μTz).
data Mutez

-- | Safely create <a>Mutez</a>.
--   
--   This is recommended way to create <tt>Mutez</tt> from a numeric
--   literal; you can't construct all valid <tt>Mutez</tt> values using
--   this function but for small values it works neat.
--   
--   Warnings displayed when trying to construct invalid <a>Natural</a> or
--   <a>Word</a> literal are hardcoded for these types in GHC
--   implementation, so we can only exploit these existing rules.
toMutez :: Word32 -> Mutez
timestampFromSeconds :: Integer -> Timestamp
timestampFromUTCTime :: UTCTime -> Timestamp

-- | Quote a value of type <a>Timestamp</a> in
--   <tt>yyyy-mm-ddThh:mm:ss[.sss]Z</tt> format.
--   
--   <pre>
--   &gt;&gt;&gt; formatTimestamp [timestampQuote| 2019-02-21T16:54:12.2344523Z |]
--   "2019-02-21T16:54:12Z"
--   </pre>
--   
--   Inspired by 'time-quote' library.
timestampQuote :: QuasiQuoter

-- | Data type corresponding to address structure in Tezos.
data Address
mkUType :: SingI x => Notes x -> Type

-- | Address with optional entrypoint name attached to it. TODO: come up
--   with better name?
data EpAddress
EpAddress :: Address -> EpName -> EpAddress

-- | Address itself
[eaAddress] :: EpAddress -> Address

-- | Entrypoint name (might be empty)
[eaEntryPoint] :: EpAddress -> EpName

-- | Representation of comparable value in Michelson language.
--   
--   By specification, we're allowed to compare only following types: int,
--   nat, string, bytes, mutez, bool, key_hash, timestamp, address.
--   
--   Only these values can be used as map keys or set elements.
data CValue (t :: CT)
[CvInt] :: forall (t :: CT). () => Integer -> CValue CInt
[CvNat] :: forall (t :: CT). () => Natural -> CValue CNat
[CvString] :: forall (t :: CT). () => MText -> CValue CString
[CvBytes] :: forall (t :: CT). () => ByteString -> CValue CBytes
[CvMutez] :: forall (t :: CT). () => Mutez -> CValue CMutez
[CvBool] :: forall (t :: CT). () => Bool -> CValue CBool
[CvKeyHash] :: forall (t :: CT). () => KeyHash -> CValue CKeyHash
[CvTimestamp] :: forall (t :: CT). () => Timestamp -> CValue CTimestamp
[CvAddress] :: forall (t :: CT). () => EpAddress -> CValue CAddress

-- | Keeps documentation gathered for some piece of contract code.
--   
--   Used for building documentation of a contract.
data ContractDoc
ContractDoc :: DocBlock -> DocBlock -> Set SomeDocDefinitionItem -> Set DocItemId -> ContractDoc

-- | All inlined doc items.
[cdContents] :: ContractDoc -> DocBlock

-- | Definitions used in document.
--   
--   Usually you put some large and repetitive descriptions here. This
--   differs from the document content in that it contains sections which
--   are always at top-level, disregard the nesting.
--   
--   All doc items which define <tt>docItemId</tt> method go here, and only
--   they.
[cdDefinitions] :: ContractDoc -> DocBlock

-- | We remember all already declared entries to avoid cyclic dependencies
--   in documentation items discovery.
[cdDefinitionsSet] :: ContractDoc -> Set SomeDocDefinitionItem

-- | We remember all already used identifiers. (Documentation naturally
--   should not declare multiple items with the same identifier because
--   that would make references to the respective anchors ambiguous).
[cdDefinitionIds] :: ContractDoc -> Set DocItemId

-- | A part of documentation to be grouped. Essentially incapsulates
--   <a>DocBlock</a>.
newtype SubDoc
SubDoc :: DocBlock -> SubDoc

-- | Hides some documentation item which is put to "definitions" section.
data SomeDocDefinitionItem
[SomeDocDefinitionItem] :: forall d. (DocItem d, DocItemPlacement d ~ DocItemInDefinitions) => d -> SomeDocDefinitionItem

-- | Hides some documentation item.
data SomeDocItem
[SomeDocItem] :: forall d. DocItem d => d -> SomeDocItem

-- | How to render section name.
data DocSectionNameStyle

-- | Suitable for block name.
DocSectionNameBig :: DocSectionNameStyle

-- | Suitable for subsection title within block.
DocSectionNameSmall :: DocSectionNameStyle

-- | Defines an identifier which given doc item can be referenced with.
data DocItemRef (p :: DocItemPlacementKind)
[DocItemRef] :: forall (p :: DocItemPlacementKind). () => DocItemId -> DocItemRef DocItemInDefinitions
[DocItemNoRef] :: forall (p :: DocItemPlacementKind). () => DocItemRef DocItemInlined

-- | Where do we place given doc item.
data DocItemPlacementKind

-- | Placed in the document content itself.
DocItemInlined :: DocItemPlacementKind

-- | Placed in dedicated definitions section; can later be referenced.
DocItemInDefinitions :: DocItemPlacementKind

-- | Some unique identifier of a doc item.
--   
--   All doc items which should be refer-able need to have this identifier.
newtype DocItemId
DocItemId :: Text -> DocItemId

-- | A piece of documentation describing one property of a thing, be it a
--   name or description of a contract, or an error throwable by given
--   endpoint.
--   
--   Items of the same type appear close to each other in a rendered
--   documentation and form a <i>section</i>.
--   
--   Doc items are later injected into a contract code via a dedicated
--   nop-like instruction. Normally doc items which belong to one section
--   appear in resulting doc in the same order in which they appeared in
--   the contract.
--   
--   While documentation framework grows, this typeclass acquires more and
--   more methods for fine tuning of existing rendering logic because we
--   don't want to break backward compatibility, hope one day we will make
--   everything concise :( E.g. all rendering and reording stuff could be
--   merged in one method, and we could have several template
--   implementations for it which would allow user to specify only stuff
--   relevant to his case.
class (Typeable d, DOrd d, KnownNat DocItemPosition d) => DocItem d where {
    
    -- | Position of this item in the resulting documentation; the smaller the
    --   value, the higher the section with this element will be placed.
    --   
    --   Documentation structure is not necessarily flat. If some doc item
    --   consolidates a whole documentation block within it, this block will
    --   have its own placement of items independent from outer parts of the
    --   doc.
    type family DocItemPosition d = (pos :: Nat) | pos -> d;
    
    -- | Defines where given doc item should be put. There are two options: 1.
    --   Inline right here (default behaviour); 2. Put into definitions
    --   section.
    --   
    --   Note that we require all doc items with "in definitions" placement to
    --   have <a>Eq</a> and <a>Ord</a> instances which comply the following
    --   law: if two documentation items describe the same entity or property,
    --   they should be considered equal.
    type family DocItemPlacement d :: DocItemPlacementKind;
}

-- | When multiple items of the same type belong to one section, how this
--   section will be called.
--   
--   If not provided, section will contain just untitled content.
docItemSectionName :: DocItem d => Maybe Text

-- | Description of a section.
--   
--   Can be used to mention some common things about all elements of this
--   section. Markdown syntax is permitted here.
docItemSectionDescription :: DocItem d => Maybe Markdown

-- | How to render section name.
--   
--   Takes effect only if section name is set.
docItemSectionNameStyle :: DocItem d => DocSectionNameStyle

-- | Defines a function which constructs an unique identifier of given doc
--   item, if it has been decided to put the doc item into definitions
--   section.
--   
--   Identifier should be unique both among doc items of the same type and
--   items of other types. Thus, consider using "typeId-contentId" pattern.
docItemRef :: DocItem d => d -> DocItemRef (DocItemPlacement d)

-- | Render given doc item to Markdown, preferably one line, optionally
--   with header.
--   
--   Accepts the smallest allowed level of header. (Using smaller value
--   than provided one will interfere with existing headers thus delivering
--   mess).
docItemToMarkdown :: DocItem d => HeaderLevel -> d -> Markdown

-- | All doc items which this doc item refers to.
--   
--   They will automatically be put to definitions as soon as given doc
--   item is detected.
docItemDependencies :: DocItem d => d -> [SomeDocDefinitionItem]

-- | This function accepts doc items put under the same section in the
--   order in which they appeared in the contract and returns their new
--   desired order. It's also fine to use this function for filtering or
--   merging doc items.
--   
--   Default implementation * leaves inlined items as is; * for items put
--   to definitions, lexicographically sorts them by their id.
docItemsOrder :: DocItem d => [d] -> [d]

-- | Get doc item position at term-level.
docItemPosition :: DocItem d => DocItemPos

-- | Make a reference to doc item in definitions.
docDefinitionRef :: (DocItem d, DocItemPlacement d ~ DocItemInDefinitions) => Markdown -> d -> Markdown

-- | Render documentation for <a>SubDoc</a>.
subDocToMarkdown :: HeaderLevel -> SubDoc -> Markdown

-- | A hand-made anchor.
data DAnchor
DAnchor :: Anchor -> DAnchor

-- | Comment in the doc (mostly used for licenses)
data DComment
DComment :: Text -> DComment

-- | Repository settings for <a>DGitRevision</a>.
newtype GitRepoSettings
GitRepoSettings :: (Text -> Text) -> GitRepoSettings

-- | By commit sha make up a url to that commit in remote repository.
[grsMkGitRevision] :: GitRepoSettings -> Text -> Text
data DGitRevision
DGitRevisionKnown :: DGitRevisionInfo -> DGitRevision
DGitRevisionUnknown :: DGitRevision

-- | Description of something.
data DDescription
DDescription :: Markdown -> DDescription

-- | A function which groups a piece of doc under one doc item.
type DocGrouping = SubDoc -> SomeDocItem

-- | Render given contract documentation to markdown document.
contractDocToMarkdown :: ContractDoc -> LText
morleyRepoSettings :: GitRepoSettings

-- | Make <a>DGitRevision</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :t $mkDGitRevision
--   GitRepoSettings -&gt; DGitRevision
--   </pre>
mkDGitRevision :: ExpQ
type Operation = Operation' Instr
type Value = Value' Instr
newtype BigMap k v
BigMap :: Map k v -> BigMap k v
[unBigMap] :: BigMap k v -> Map k v

-- | Since <tt>Contract</tt> name is used to designate contract code, lets
--   call analogy of <a>TContract</a> type as follows.
--   
--   Note that type argument always designates an argument of entrypoint.
--   If a contract has explicit default entrypoint (and no root
--   entrypoint), <tt>ContractRef</tt> referring to it can never have the
--   entire parameter as its type argument.
data ContractRef arg
ContractRef :: Address -> SomeEntryPointCall arg -> ContractRef arg
[crAddress] :: ContractRef arg -> Address
[crEntryPoint] :: ContractRef arg -> SomeEntryPointCall arg
type SomeEntryPointCall arg = SomeEntryPointCallT ToT arg
type EntryPointCall param arg = EntryPointCallT ToT param ToT arg

-- | Isomorphism between Michelson values and plain Haskell types.
--   
--   Default implementation of this typeclass converts ADTs to Michelson
--   "pair"s and "or"s.
class IsoValue a where {
    
    -- | Type function that converts a regular Haskell type into a <tt>T</tt>
    --   type.
    type family ToT a :: T;
}

-- | Converts a Haskell structure into <tt>Value</tt> representation.
toVal :: IsoValue a => a -> Value (ToT a)

-- | Converts a <tt>Value</tt> into Haskell type.
fromVal :: IsoValue a => Value (ToT a) -> a

-- | Isomorphism between Michelson primitive values and plain Haskell
--   types.
class IsoCValue a where {
    
    -- | Type function that converts a regular Haskell type into a comparable
    --   type (which has kind <tt>CT</tt>).
    type family ToCT a :: CT;
}

-- | Converts a single Haskell value into <tt>CVal</tt> representation.
toCVal :: IsoCValue a => a -> CValue (ToCT a)

-- | Converts a <tt>CVal</tt> value into a single Haskell value.
fromCVal :: IsoCValue a => CValue (ToCT a) -> a

-- | Replace type argument of <tt>ContractAddr</tt> with isomorphic one.
coerceContractRef :: ToT a ~ ToT b => ContractRef a -> ContractRef b

-- | Constraint for <a>instrConstruct</a>.
type InstrConstructC dt = (GenericIsoValue dt, GInstrConstruct Rep dt)

-- | Types of all fields in a datatype.
type ConstructorFieldTypes dt = GFieldTypes Rep dt

-- | Require this type to be homomorphic.
class IsHomomorphic (a :: k)

-- | Require two types to be built from the same type constructor.
--   
--   E.g. <tt>HaveCommonTypeCtor (Maybe Integer) (Maybe Natural)</tt> is
--   defined, while <tt>HaveCmmonTypeCtor (Maybe Integer) [Integer]</tt> is
--   not.
class HaveCommonTypeCtor (a :: k) (b :: k1)

-- | Doc element with description of a type.
data DType
[DType] :: forall a. TypeHasDoc a => Proxy a -> DType

-- | Data hides some type implementing <a>TypeHasDoc</a>.
data SomeTypeWithDoc
[SomeTypeWithDoc] :: forall td. TypeHasDoc td => Proxy td -> SomeTypeWithDoc

-- | Description for a Haskell type appearing in documentation.
class Typeable a => TypeHasDoc a

-- | Name of type as it appears in definitions section.
--   
--   Each type must have its own unique name because it will be used in
--   identifier for references.
--   
--   Default definition derives name from Generics. If it does not fit,
--   consider defining this function manually. (We tried using <a>Data</a>
--   for this, but it produces names including module names which is not do
--   we want).
typeDocName :: TypeHasDoc a => Proxy a -> Text

-- | Explanation of a type. Markdown formatting is allowed.
typeDocMdDescription :: TypeHasDoc a => Markdown

-- | How reference to this type is rendered, in Markdown.
--   
--   Examples: * <tt><a>Integer</a></tt>, * <tt><a>Maybe</a>
--   <a>()</a></tt>.
--   
--   Consider using one of the following functions as default
--   implementation; which one to use depends on number of type arguments
--   in your type: * <a>homomorphicTypeDocMdReference</a> *
--   <a>poly1TypeDocMdReference</a> * <a>poly2TypeDocMdReference</a>
--   
--   If none of them fits your purposes precisely, consider using
--   <a>customTypeDocMdReference</a>.
typeDocMdReference :: TypeHasDoc a => Proxy a -> WithinParens -> Markdown

-- | All types which this type directly contains.
--   
--   Used in automatic types discovery.
typeDocDependencies :: TypeHasDoc a => Proxy a -> [SomeTypeWithDoc]

-- | For complex types - their immediate Haskell representation.
--   
--   For primitive types set this to <a>Nothing</a>.
--   
--   For homomorphic types use <a>homomorphicTypeDocHaskellRep</a>
--   implementation.
--   
--   For polymorhpic types consider using <a>concreteTypeDocHaskellRep</a>
--   as implementation.
--   
--   Modifier <a>haskellRepNoFields</a> can be used to hide names of
--   fields, beneficial for newtypes.
--   
--   Another modifier called <a>haskellRepStripFieldPrefix</a> can be used
--   for datatypes to leave only meaningful part of name in every field.
typeDocHaskellRep :: TypeHasDoc a => TypeDocHaskellRep a

-- | Final michelson representation of a type.
--   
--   For homomorphic types use <a>homomorphicTypeDocMichelsonRep</a>
--   implementation.
--   
--   For polymorhpic types consider using
--   <a>concreteTypeDocMichelsonRep</a> as implementation.
typeDocMichelsonRep :: TypeHasDoc a => TypeDocMichelsonRep a

-- | Render a reference to a type which consists of type constructor (you
--   have to provide name of this type constructor and documentation for
--   the whole type) and zero or more type arguments.
customTypeDocMdReference :: (Text, DType) -> [DType] -> WithinParens -> Markdown

-- | Derive <a>typeDocMdReference</a>, for homomorphic types only.
homomorphicTypeDocMdReference :: (Typeable t, TypeHasDoc t, IsHomomorphic t) => Proxy t -> WithinParens -> Markdown

-- | Derive <a>typeDocMdReference</a>, for polymorphic type with one type
--   argument, like <tt>Maybe Integer</tt>.
poly1TypeDocMdReference :: (r ~ t a, Typeable t, Each (TypeHasDoc : ([] :: [Type -> Constraint])) (r : (a : ([] :: [Type]))), IsHomomorphic t) => Proxy r -> WithinParens -> Markdown

-- | Derive <a>typeDocMdReference</a>, for polymorphic type with two type
--   arguments, like <tt>Lambda Integer Natural</tt>.
poly2TypeDocMdReference :: (r ~ t a b, Typeable t, Each (TypeHasDoc : ([] :: [Type -> Constraint])) (r : (a : (b : ([] :: [Type])))), IsHomomorphic t) => Proxy r -> WithinParens -> Markdown

-- | Implement <a>typeDocDependencies</a> via getting all immediate fields
--   of a datatype.
--   
--   Note: this will not include phantom types, I'm not sure yet how this
--   scenario should be handled (@martoon).
genericTypeDocDependencies :: (Generic a, GTypeHasDoc (Rep a)) => Proxy a -> [SomeTypeWithDoc]

-- | Implement <a>typeDocHaskellRep</a> for a homomorphic type.
--   
--   Note that it does not require your type to be of <a>IsHomomorphic</a>
--   instance, which can be useful for some polymorhpic types which, for
--   documentation purposes, we want to consider homomorphic. Example:
--   <a>Operation</a> is in fact polymorhpic, but we don't want this fact
--   to be reflected in the documentation.
homomorphicTypeDocHaskellRep :: (Generic a, GTypeHasDoc (Rep a)) => TypeDocHaskellRep a

-- | Implement <a>typeDocHaskellRep</a> on example of given concrete type.
--   
--   This is a best effort attempt to implement <a>typeDocHaskellRep</a>
--   for polymorhpic types, as soon as there is no simple way to preserve
--   type variables when automatically deriving Haskell representation of a
--   type.
concreteTypeDocHaskellRep :: (Typeable a, GenericIsoValue a, GTypeHasDoc (Rep a), HaveCommonTypeCtor b a) => TypeDocHaskellRep b

-- | Version of <a>concreteTypeDocHaskellRep</a> which does not ensure
--   whether the type for which representation is built is any similar to
--   the original type which you implement a <a>TypeHasDoc</a> instance
--   for.
concreteTypeDocHaskellRepUnsafe :: (Typeable a, GenericIsoValue a, GTypeHasDoc (Rep a)) => TypeDocHaskellRep b

-- | Erase fields from Haskell datatype representation.
--   
--   Use this when rendering fields names is undesired.
haskellRepNoFields :: () => TypeDocHaskellRep a -> TypeDocHaskellRep a

-- | Cut fields prefixes which we use according to the style guide.
--   
--   E.g. <tt>cmMyField</tt> field will be transformed to <tt>myField</tt>.
haskellRepStripFieldPrefix :: HasCallStack => TypeDocHaskellRep a -> TypeDocHaskellRep a

-- | Implement <a>typeDocMichelsonRep</a> for homomorphic type.
homomorphicTypeDocMichelsonRep :: SingI (ToT a) => TypeDocMichelsonRep a

-- | Implement <a>typeDocMichelsonRep</a> on example of given concrete
--   type.
--   
--   This function exists for the same reason as
--   <a>concreteTypeDocHaskellRep</a>.
concreteTypeDocMichelsonRep :: (Typeable a, SingI (ToT a), HaveCommonTypeCtor b a) => TypeDocMichelsonRep b

-- | Version of <a>concreteTypeDocHaskellRepUnsafe</a> which does not
--   ensure whether the type for which representation is built is any
--   similar to the original type which you implement a <a>TypeHasDoc</a>
--   instance for.
concreteTypeDocMichelsonRepUnsafe :: (Typeable a, SingI (ToT a)) => TypeDocMichelsonRep b


-- | This module is intended to be imported instead of `morley-prelude` by
--   Indigo modules.
--   
--   This only serves the purpose of listing <tt>hiding</tt> rules once and
--   avoid boilerplate
module Indigo.Prelude

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: () => [a] -> [a] -> [a]
infixr 5 ++

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: () => a -> b -> b

-- | <a>filter</a>, applied to a predicate and a list, returns the list of
--   those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
filter :: () => (a -> Bool) -> [a] -> [a]

-- | <a>zip</a> takes two lists and returns a list of corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
zip :: () => [a] -> [b] -> [(a, b)]

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>($)</tt> is levity-polymorphic in its result type, so
--   that foo $ True where foo :: Bool -&gt; Int# is well-typed
($) :: () => (a -> b) -> a -> b
infixr 0 $

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   '(+)', '(*)' and <a>exp</a> are customarily expected to define an
--   exponential field and have the following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = @exp a * exp b</li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   '(+)' and '(*)' are customarily expected to define a division ring and
--   have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | fractional division
(/) :: Fractional a => a -> a -> a

-- | reciprocal fraction
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the 'div'/'mod'
--   and 'quot'/'rem' pairs, given suitable Euclidean functions <tt>f</tt>
--   and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (\x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However, '(+)' and
--   '(*)' are customarily expected to define a ring and have the following
--   properties:
--   
--   <ul>
--   <li><i><b>Associativity of (+)</b></i> <tt>(x + y) + z</tt> = <tt>x +
--   (y + z)</tt></li>
--   <li><i><b>Commutativity of (+)</b></i> <tt>x + y</tt> = <tt>y +
--   x</tt></li>
--   <li><i><b><tt>fromInteger 0</tt> is the additive identity</b></i>
--   <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of (*)</b></i> <tt>(x * y) * z</tt> = <tt>x *
--   (y * z)</tt></li>
--   <li><i><b><tt>fromInteger 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of (*) with respect to (+)</b></i> <tt>a * (b
--   + c)</tt> = <tt>(a * b) + (a * c)</tt> and <tt>(b + c) * a</tt> =
--   <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <tt>Rational</tt> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 +
infixl 7 *
infixl 6 -

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 >
infix 4 <
infix 4 <=

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <tt>&gt;&gt;=</tt>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <tt>MonadPlus</tt>, a popular definition
--   is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <tt>&lt;$&gt;</tt> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>traverse</a> f =
--   <a>traverse</a> (t . f)</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>traverse</a> Identity =
--   Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>traverse</a> (Compose .
--   <a>fmap</a> g . f) = Compose . <a>fmap</a> (<a>traverse</a> g) .
--   <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>sequenceA</a> =
--   <a>sequenceA</a> . <a>fmap</a> t</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>sequenceA</a> . <a>fmap</a> Identity
--   = Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>sequenceA</a> . <a>fmap</a>
--   Compose = Compose . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <ul>
--   <li><pre>t (<a>pure</a> x) = <a>pure</a> x</pre></li>
--   <li><pre>t (x <a>&lt;*&gt;</a> y) = t x <a>&lt;*&gt;</a> t
--   y</pre></li>
--   </ul>
--   
--   and the identity functor <tt>Identity</tt> and composition of functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity a
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Identity where
--     pure x = Identity x
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure x = Compose (pure (pure x))
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <tt>id</tt>
--   <a>to</a> . <a>from</a> ≡ <tt>id</tt>
--   </pre>
class Generic a

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)
class IsLabel (x :: Symbol) a
fromLabel :: IsLabel x a => a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the associativity law:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</pre></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <tt>&lt;&gt;</tt>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in <i>O(1)</i> by picking
--   <tt>stimes = <tt>stimesIdempotent</tt></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> <a>mempty</a> = x</pre></li>
--   <li><pre><a>mempty</a> <a>&lt;&gt;</a> x = x</pre></li>
--   <li><tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a> law)</li>
--   <li><pre><a>mconcat</a> = <a>foldr</a> '(&lt;&gt;)'
--   <a>mempty</a></pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = '(&lt;&gt;)'</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double
D# :: Double# -> Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float
F# :: Float# -> Float

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | 8-bit signed integer type
data Int8

-- | 16-bit signed integer type
data Int16

-- | 32-bit signed integer type
data Int32

-- | 64-bit signed integer type
data Int64

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><tt>throw</tt>
--   (<tt>Underflow</tt> :: <tt>ArithException</tt>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Rational numbers, with numerator and denominator of some
--   <a>Integral</a> type.
--   
--   Note that <a>Ratio</a>'s instances inherit the deficiencies from the
--   type parameter's. For example, <tt>Ratio Natural</tt>'s <a>Num</a>
--   instance has similar problems to <a>Natural</a>'s.
data Ratio a
(:%) :: !a -> !a -> Ratio a

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | 8-bit unsigned integer type
data Word8

-- | 16-bit unsigned integer type
data Word16

-- | 32-bit unsigned integer type
data Word32

-- | 64-bit unsigned integer type
data Word64

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a

-- | A value of type <tt><a>FunPtr</a> a</tt> is a pointer to a function
--   callable from foreign code. The type <tt>a</tt> will normally be a
--   <i>foreign type</i>, a function type with zero or more arguments where
--   
--   <ul>
--   <li>the argument types are <i>marshallable foreign types</i>, i.e.
--   <a>Char</a>, <a>Int</a>, <a>Double</a>, <a>Float</a>, <a>Bool</a>,
--   <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, <a>Word64</a>, <tt><a>Ptr</a> a</tt>,
--   <tt><a>FunPtr</a> a</tt>, <tt><a>StablePtr</a> a</tt> or a renaming of
--   any of these using <tt>newtype</tt>.</li>
--   <li>the return type is either a marshallable foreign type or has the
--   form <tt><a>IO</a> t</tt> where <tt>t</tt> is a marshallable foreign
--   type or <tt>()</tt>.</li>
--   </ul>
--   
--   A value of type <tt><a>FunPtr</a> a</tt> may be a pointer to a foreign
--   function, either returned by another foreign function or imported with
--   a a static address import like
--   
--   <pre>
--   foreign import ccall "stdlib.h &amp;free"
--     p_free :: FunPtr (Ptr a -&gt; IO ())
--   </pre>
--   
--   or a pointer to a Haskell function created using a <i>wrapper</i> stub
--   declared to produce a <a>FunPtr</a> of the correct type. For example:
--   
--   <pre>
--   type Compare = Int -&gt; Int -&gt; Bool
--   foreign import ccall "wrapper"
--     mkCompare :: Compare -&gt; IO (FunPtr Compare)
--   </pre>
--   
--   Calls to wrapper stubs like <tt>mkCompare</tt> allocate storage, which
--   should be released with <a>freeHaskellFunPtr</a> when no longer
--   required.
--   
--   To convert <a>FunPtr</a> values to corresponding Haskell functions,
--   one can define a <i>dynamic</i> stub for the specific foreign type,
--   e.g.
--   
--   <pre>
--   type IntFunction = CInt -&gt; IO ()
--   foreign import ccall "dynamic"
--     mkFun :: FunPtr IntFunction -&gt; IntFunction
--   </pre>
data FunPtr a

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The kind of constraints, like <tt>Show a</tt>
data Constraint

-- | Comparison of type-level naturals, as a function.
type family CmpNat (a :: Nat) (b :: Nat) :: Ordering

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k0) (b :: k0)

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:2:1 in interactive:Ghci1
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: () => a -> a

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <tt>length</tt> function (if we have a <a>String</a>) or the
--   "times-two" function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: () => (a -> c) -> (b -> c) -> Either a b -> c

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r (m :: Type -> Type) | m -> r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Retrieves a function of the current environment.
reader :: MonadReader r m => (r -> a) -> m a

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: Type -> Type) | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | The class of types that can be converted to a hash value.
--   
--   Minimal implementation: <a>hashWithSalt</a>.
class Hashable a

-- | Return a hash value for the argument, using the given salt.
--   
--   The general contract of <a>hashWithSalt</a> is:
--   
--   <ul>
--   <li>If two values are equal according to the <a>==</a> method, then
--   applying the <a>hashWithSalt</a> method on each of the two values
--   <i>must</i> produce the same integer result if the same salt is used
--   in each case.</li>
--   <li>It is <i>not</i> required that if two values are unequal according
--   to the <a>==</a> method, then applying the <a>hashWithSalt</a> method
--   on each of the two values must produce distinct integer results.
--   However, the programmer should be aware that producing distinct
--   integer results for unequal values may improve the performance of
--   hashing-based data structures.</li>
--   <li>This method can be used to compute different hash values for the
--   same input by providing a different salt in each application of the
--   method. This implies that any instance that defines
--   <a>hashWithSalt</a> <i>must</i> make use of the salt in its
--   implementation.</li>
--   </ul>
hashWithSalt :: Hashable a => Int -> a -> Int
infixl 0 `hashWithSalt`

-- | A space efficient, packed, unboxed Unicode text type.
data Text

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: () => a -> b -> a

-- | Function composition.
(.) :: () => (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | A map from keys to values. A map cannot contain duplicate keys; each
--   key can map to at most one value.
data HashMap k v

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <tt>&lt;$&gt;</tt> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a
integralEnumFromThenTo :: Integral a => a -> a -> a -> [a]
integralEnumFromTo :: Integral a => a -> a -> [a]
integralEnumFromThen :: (Integral a, Bounded a) => a -> a -> [a]
integralEnumFrom :: (Integral a, Bounded a) => a -> [a]
gcdWord' :: Word -> Word -> Word
gcdInt' :: Int -> Int -> Int
(^^%^^) :: Integral a => Rational -> a -> Rational
(^%^) :: Integral a => Rational -> a -> Rational
numericEnumFromThenTo :: (Ord a, Fractional a) => a -> a -> a -> [a]
numericEnumFromTo :: (Ord a, Fractional a) => a -> a -> [a]
numericEnumFromThen :: Fractional a => a -> a -> [a]
numericEnumFrom :: Fractional a => a -> [a]
notANumber :: Rational
infinity :: Rational
ratioPrec1 :: Int
ratioPrec :: Int
underflowError :: () => a
overflowError :: () => a
ratioZeroDenominatorError :: () => a
divZeroError :: () => a

-- | <a>reduce</a> is a subsidiary function used only in this module. It
--   normalises a ratio by dividing both numerator and denominator by their
--   greatest common divisor.
reduce :: Integral a => a -> a -> Ratio a
boundedEnumFromThen :: (Enum a, Bounded a) => a -> a -> [a]
boundedEnumFrom :: (Enum a, Bounded a) => a -> [a]
maxInt :: Int
minInt :: Int

-- | Right-to-left composition of functors. The composition of applicative
--   functors is always applicative, but the composition of monads is not
--   always a monad.
newtype Compose (f :: k -> Type) (g :: k1 -> k) (a :: k1) :: forall k k1. () => k -> Type -> k1 -> k -> k1 -> Type
Compose :: f (g a) -> Compose
[getCompose] :: Compose -> f (g a)
infixr 9 `Compose`
infixr 9 `Compose`

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values.
vacuous :: Functor f => f Void -> f a

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: () => Void -> a

-- | Uninhabited data type
data Void

-- | Repeat a value <tt>n</tt> times.
--   
--   <pre>
--   mtimesDefault n a = a &lt;&gt; a &lt;&gt; ... &lt;&gt; a  -- using &lt;&gt; (n-1) times
--   </pre>
--   
--   Implemented using <a>stimes</a> and <a>mempty</a>.
--   
--   This is a suitable definition for an <tt>mtimes</tt> member of
--   <a>Monoid</a>.
mtimesDefault :: (Integral b, Monoid a) => b -> a -> a

-- | A generalization of <a>cycle</a> to an arbitrary <a>Semigroup</a>. May
--   fail to terminate for some values in some semigroups.
cycle1 :: Semigroup m => m -> m

-- | Provide a Semigroup for an arbitrary Monoid.
--   
--   <b>NOTE</b>: This is not needed anymore since <a>Semigroup</a> became
--   a superclass of <a>Monoid</a> in <i>base-4.11</i> and this newtype be
--   deprecated at some point in the future.
data WrappedMonoid m

-- | <a>Option</a> is effectively <a>Maybe</a> with a better instance of
--   <a>Monoid</a>, built off of an underlying <a>Semigroup</a> instead of
--   an underlying <a>Monoid</a>.
--   
--   Ideally, this type would not exist at all and we would just fix the
--   <a>Monoid</a> instance of <a>Maybe</a>.
--   
--   In GHC 8.4 and higher, the <a>Monoid</a> instance for <a>Maybe</a> has
--   been corrected to lift a <a>Semigroup</a> instance instead of a
--   <a>Monoid</a> instance. Consequently, this type is no longer useful.
--   It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.
newtype Option a
Option :: Maybe a -> Option a
[getOption] :: Option a -> Maybe a

-- | The <a>sortWith</a> function sorts a list of elements using the user
--   supplied function to project something out of each element
sortWith :: Ord b => (a -> b) -> [a] -> [a]

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c

-- | Extract everything except the last element of the stream.
init :: () => NonEmpty a -> [a]

-- | Extract the last element of the stream.
last :: () => NonEmpty a -> a

-- | Extract the possibly-empty tail of the stream.
tail :: () => NonEmpty a -> [a]

-- | Extract the first element of the stream.
head :: () => NonEmpty a -> a

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: () => [a] -> Maybe (NonEmpty a)

-- | Get a string representation of the current execution stack state.
showStackTrace :: IO (Maybe String)

-- | Get a trace of the current execution stack state.
--   
--   Returns <tt>Nothing</tt> if stack trace support isn't available on
--   host machine.
getStackTrace :: IO (Maybe [Location])

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | The <a>foldM</a> function is analogous to <tt>foldl</tt>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state-transforming monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
forever :: Applicative f => f a -> f b

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Left-to-right composition of Kleisli arrows.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | This generalizes the list-based <tt>filter</tt> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | This function may be used as a value for <a>foldMap</a> in a
--   <a>Foldable</a> instance.
--   
--   <pre>
--   <a>foldMapDefault</a> f ≡ <a>getConst</a> . <a>traverse</a> (<a>Const</a> . f)
--   </pre>
foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m

-- | This function may be used as a value for <a>fmap</a> in a
--   <a>Functor</a> instance, provided that <a>traverse</a> is defined.
--   (Using <a>fmapDefault</a> with a <a>Traversable</a> instance defined
--   only by <a>sequenceA</a> will result in infinite recursion.)
--   
--   <pre>
--   <a>fmapDefault</a> f ≡ <a>runIdentity</a> . <a>traverse</a> (<a>Identity</a> . f)
--   </pre>
fmapDefault :: Traversable t => (a -> b) -> t a -> t b

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldr</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from right to left,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldl</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from left to right,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)

-- | Lists, but with an <a>Applicative</a> functor based on zipping.
newtype ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 &&&

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | Perform some computation without adding new entries to the
--   <a>CallStack</a>.
withFrozenCallStack :: HasCallStack => (HasCallStack -> a) -> a

-- | Return the current <a>CallStack</a>.
--   
--   Does *not* include the call-site of <a>callStack</a>.
callStack :: HasCallStack -> CallStack

-- | Write the supplied value into a <a>TVar</a>.
writeTVar :: () => TVar a -> a -> STM ()

-- | Return the current value stored in a <a>TVar</a>.
readTVar :: () => TVar a -> STM a

-- | Create a new <a>TVar</a> holding a value supplied
newTVar :: () => a -> STM (TVar a)

-- | A monad supporting atomic memory transactions.
data STM a

-- | Shared memory locations that support atomic memory transactions.
data TVar a

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | A mutable variable in the <a>IO</a> monad
data IORef a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Pretty print a <a>CallStack</a>.
prettyCallStack :: CallStack -> String

-- | Pretty print a <a>SrcLoc</a>.
prettySrcLoc :: SrcLoc -> String

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <a>Const</a> functor.
newtype Const a (b :: k) :: forall k. () => Type -> k -> Type
Const :: a -> Const a
[getConst] :: Const a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | Monadic fold over the elements of a structure, associating to the
--   left, i.e. from left to right.
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Monadic fold over the elements of a structure, associating to the
--   right, i.e. from right to left.
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | Maybe monoid returning the leftmost non-Nothing value.
--   
--   <tt><a>First</a> a</tt> is isomorphic to <tt><a>Alt</a> <a>Maybe</a>
--   a</tt>, but precedes it historically.
--   
--   <pre>
--   &gt;&gt;&gt; getFirst (First (Just "hello") &lt;&gt; First Nothing &lt;&gt; First (Just "world"))
--   Just "hello"
--   </pre>
--   
--   Use of this type is discouraged. Note the following equivalence:
--   
--   <pre>
--   Data.Monoid.First x === Maybe (Data.Semigroup.First x)
--   </pre>
--   
--   In addition to being equivalent in the structural sense, the two also
--   have <a>Monoid</a> instances that behave the same. This type will be
--   marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are
--   advised to use the variant from <a>Data.Semigroup</a> and wrap it in
--   <a>Maybe</a>.
newtype First a
First :: Maybe a -> First a
[getFirst] :: First a -> Maybe a

-- | Maybe monoid returning the rightmost non-Nothing value.
--   
--   <tt><a>Last</a> a</tt> is isomorphic to <tt><a>Dual</a> (<a>First</a>
--   a)</tt>, and thus to <tt><a>Dual</a> (<a>Alt</a> <a>Maybe</a> a)</tt>
--   
--   <pre>
--   &gt;&gt;&gt; getLast (Last (Just "hello") &lt;&gt; Last Nothing &lt;&gt; Last (Just "world"))
--   Just "world"
--   </pre>
--   
--   Use of this type is discouraged. Note the following equivalence:
--   
--   <pre>
--   Data.Monoid.Last x === Maybe (Data.Semigroup.Last x)
--   </pre>
--   
--   In addition to being equivalent in the structural sense, the two also
--   have <a>Monoid</a> instances that behave the same. This type will be
--   marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are
--   advised to use the variant from <a>Data.Semigroup</a> and wrap it in
--   <a>Maybe</a>.
newtype Last a
Last :: Maybe a -> Last a
[getLast] :: Last a -> Maybe a

-- | This is a valid definition of <a>stimes</a> for a <a>Monoid</a>.
--   
--   Unlike the default definition of <a>stimes</a>, it is defined for 0
--   and so it should be preferred where possible.
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Semigroup</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>.
stimesIdempotent :: Integral b => b -> a -> a

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>.
--   
--   <pre>
--   &gt;&gt;&gt; getDual (mappend (Dual "Hello") (Dual "World"))
--   "WorldHello"
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
--   False
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction (<a>||</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
--   True
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   &gt;&gt;&gt; getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty)
--   3
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; getProduct (Product 3 &lt;&gt; Product 4 &lt;&gt; mempty)
--   12
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | Monoid under <a>&lt;|&gt;</a>.
newtype Alt (f :: k -> Type) (a :: k) :: forall k. () => k -> Type -> k -> Type
Alt :: f a -> Alt
[getAlt] :: Alt -> f a

-- | Convert an integer into an unknown type-level natural.
someNatVal :: Natural -> SomeNat

natVal :: KnownNat n => proxy n -> Natural

-- | This type represents unknown type-level natural numbers.
data SomeNat
[SomeNat] :: forall (n :: Nat). KnownNat n => Proxy n -> SomeNat

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: () => (b -> Maybe (a, b)) -> b -> [a]

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt>sortOn f</tt> is equivalent to <tt>sortBy (comparing
--   f)</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortBy :: () => (a -> a -> Ordering) -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
sort :: Ord a => [a] -> [a]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: () => [a] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: () => [a] -> [[a]]

-- | The <a>tails</a> function returns all final segments of the argument,
--   longest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: () => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
inits :: () => [a] -> [[a]]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | The <a>genericLength</a> function is an overloaded version of
--   <a>length</a>. In particular, instead of returning an <a>Int</a>, it
--   returns any type which is an instance of <a>Num</a>. It is, however,
--   less efficient than <a>length</a>.
genericLength :: Num i => [a] -> i

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: () => [[a]] -> [[a]]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: () => [a] -> [[a]] -> [a]

-- | The <a>intersperse</a> function takes an element and a list and
--   `intersperses' that element between the elements of the list. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: () => a -> [a] -> [a]

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "123" :: Maybe Int
--   Just 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "hello" :: Maybe Int
--   Nothing
--   </pre>
readMaybe :: Read a => String -> Maybe a

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: () => Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: () => Either a b -> Bool

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: () => [Either a b] -> ([a], [b])

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: () => [Either a b] -> [b]

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: () => [Either a b] -> [a]

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>). If <tt>a</tt> has
--   an <tt><a>Ord</a></tt> instance associated with it then comparing two
--   values thus wrapped will give you the opposite of their normal sort
--   order. This is particularly useful when sorting in generalised list
--   comprehensions, as in: <tt>then sortWith by <a>Down</a> x</tt>
newtype Down a
Down :: a -> Down a

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt>'undefined :: a'</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k) :: forall k. () => k -> Type
Proxy :: Proxy

-- | See <a>openFile</a>
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | Reverse order of bytes in <a>Word64</a>.
byteSwap64 :: Word64 -> Word64

-- | Reverse order of bytes in <a>Word32</a>.
byteSwap32 :: Word32 -> Word32

-- | Swap bytes in <a>Word16</a>.
byteSwap16 :: Word16 -> Word16

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: () => a -> a -> Bool -> a

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: () => a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <tt>fix'</tt> argument, hence the recursion is reintroduced.
fix :: () => (a -> a) -> a

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with
--   unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with unit, resulting in an <tt><tt>Either</tt>
--   <tt>Int</tt> '()'</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^
odd :: Integral a => a -> Bool
even :: Integral a => a -> Bool

-- | Extract the denominator of the ratio in reduced form: the numerator
--   and denominator have no common factor and the denominator is positive.
denominator :: () => Ratio a -> a

-- | Extract the numerator of the ratio in reduced form: the numerator and
--   denominator have no common factor and the denominator is positive.
numerator :: () => Ratio a -> a

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: () => [(a, b, c)] -> ([a], [b], [c])

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: () => [(a, b)] -> ([a], [b])

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums.
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
zipWith :: () => (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>.
zip3 :: () => [a] -> [b] -> [c] -> [(a, b, c)]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: () => [a] -> [a]

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: () => (a -> Bool) -> [a] -> ([a], [a])

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: () => Int -> [a] -> ([a], [a])

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: () => Int -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: () => (a -> Bool) -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: () => (a -> Bool) -> [a] -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: () => [a] -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: () => Int -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: () => a -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See 'iterate\''
--   for a strict variant of this function.
iterate :: () => (a -> a) -> a -> [a]

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: () => (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: () => (b -> a -> b) -> b -> [a] -> [b]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: () => (a -> Maybe b) -> [a] -> [b]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: () => [Maybe a] -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: () => [a] -> Maybe a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when not given <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: () => Maybe a -> [a]

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: () => a -> Maybe a -> a

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: () => Maybe a -> Bool

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: () => Maybe a -> Bool

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <tt>show</tt> to a <tt>Maybe Int</tt>. If we have <tt>Just
--   n</tt>, we want to show the underlying <a>Int</a> <tt>n</tt>. But if
--   we have <a>Nothing</a>, we return the empty string instead of (for
--   example) "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: () => b -> (a -> b) -> Maybe a -> b

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: () => (a -> b -> c) -> (a, b) -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: () => ((a, b) -> c) -> a -> b -> c

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data MVar a

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | Returns a <tt>[String]</tt> representing the current call stack. This
--   can be useful for debugging.
--   
--   The implementation uses the call-stack simulation maintained by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: () => a -> a -> a

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: () => (a -> b -> c) -> b -> a -> c

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | Extract a list of call-sites from the <a>CallStack</a>.
--   
--   The list is ordered by most recent call.
getCallStack :: CallStack -> [([Char], SrcLoc)]

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Monoid</a>.
--   
--   When <tt>mappend x x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
[SomeException] :: forall e. Exception e => e -> SomeException

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | The trivial monad transformer, which maps a monad to an equivalent
--   monad.
data IdentityT (f :: k -> Type) (a :: k) :: forall k. () => k -> Type -> k -> Type

-- | A map of integers to values <tt>a</tt>.
data IntMap a

-- | A set of integers.
data IntSet

-- | General-purpose finite sequences.
data Seq a

-- | A set of values <tt>a</tt>.
data Set a

-- | A class of types that can be fully evaluated.
class NFData a

-- | <a>rnf</a> should reduce its argument to normal form (that is, fully
--   evaluate all sub-components), and then return '()'.
--   
--   <h3><a>Generic</a> <a>NFData</a> deriving</h3>
--   
--   Starting with GHC 7.2, you can automatically derive instances for
--   types possessing a <a>Generic</a> instance.
--   
--   Note: <a>Generic1</a> can be auto-derived starting with GHC 7.4
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic, Generic1)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1)
--   
--   instance NFData a =&gt; NFData (Foo a)
--   instance NFData1 Foo
--   
--   data Colour = Red | Green | Blue
--                 deriving Generic
--   
--   instance NFData Colour
--   </pre>
--   
--   Starting with GHC 7.10, the example above can be written more
--   concisely by enabling the new <tt>DeriveAnyClass</tt> extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1, NFData, NFData1)
--   
--   data Colour = Red | Green | Blue
--                 deriving (Generic, NFData)
--   </pre>
--   
--   <h3>Compatibility with previous <tt>deepseq</tt> versions</h3>
--   
--   Prior to version 1.4.0.0, the default implementation of the <a>rnf</a>
--   method was defined as
--   
--   <pre>
--   <a>rnf</a> a = <a>seq</a> a ()
--   </pre>
--   
--   However, starting with <tt>deepseq-1.4.0.0</tt>, the default
--   implementation is based on <tt>DefaultSignatures</tt> allowing for
--   more accurate auto-derived <a>NFData</a> instances. If you need the
--   previously used exact default <a>rnf</a> method implementation
--   semantics, use
--   
--   <pre>
--   instance NFData Colour where rnf x = seq x ()
--   </pre>
--   
--   or alternatively
--   
--   <pre>
--   instance NFData Colour where rnf = rwhnf
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# LANGUAGE BangPatterns #-}
--   instance NFData Colour where rnf !_ = ()
--   </pre>
rnf :: NFData a => a -> ()

-- | a variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   Finally, here's an exception safe variant of the <tt>readFile'</tt>
--   example:
--   
--   <pre>
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = bracket (openFile fn ReadMode) hClose $ \h -&gt;
--                          evaluate . force =&lt;&lt; hGetContents h
--   </pre>
force :: NFData a => a -> a

-- | the deep analogue of <a>$!</a>. In the expression <tt>f $!! x</tt>,
--   <tt>x</tt> is fully evaluated before the function <tt>f</tt> is
--   applied to it.
($!!) :: NFData a => (a -> b) -> a -> b
infixr 0 $!!

-- | <a>deepseq</a>: fully evaluates the first argument, before returning
--   the second.
--   
--   The name <a>deepseq</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <a>deepseq</a> traverses the
--   entire data structure evaluating it completely.
--   
--   <a>deepseq</a> can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the
--   <tt>parallel</tt> package).
--   
--   There is no guarantee about the ordering of evaluation. The
--   implementation may evaluate the components of the structure in any
--   order or in parallel. To impose an actual order on evaluation, use
--   <tt>pseq</tt> from <a>Control.Parallel</a> in the <tt>parallel</tt>
--   package.
deepseq :: NFData a => a -> b -> b

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype MaybeT (m :: Type -> Type) a
MaybeT :: m (Maybe a) -> MaybeT a
[runMaybeT] :: MaybeT a -> m (Maybe a)

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype ExceptT e (m :: Type -> Type) a
ExceptT :: m (Either e a) -> ExceptT e a

-- | A class for monads in which exceptions may be thrown.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   throwM e &gt;&gt; x = throwM e
--   </pre>
--   
--   In other words, throwing an exception short-circuits the rest of the
--   monadic computation.
class Monad m => MonadThrow (m :: Type -> Type)

-- | A class for monads which allow exceptions to be caught, in particular
--   exceptions which were thrown by <a>throwM</a>.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   catch (throwM e) f = f e
--   </pre>
--   
--   Note that the ability to catch an exception does <i>not</i> guarantee
--   that we can deal with all possible exit points from a computation.
--   Some monads, such as continuation-based stacks, allow for more than
--   just a success/failure strategy, and therefore <tt>catch</tt>
--   <i>cannot</i> be used by those monads to properly implement a function
--   such as <tt>finally</tt>. For more information, see <a>MonadMask</a>.
class MonadThrow m => MonadCatch (m :: Type -> Type)

-- | A class for monads which provide for the ability to account for all
--   possible exit points from a computation, and to mask asynchronous
--   exceptions. Continuation-based monads are invalid instances of this
--   class.
--   
--   Instances should ensure that, in the following code:
--   
--   <pre>
--   fg = f `finally` g
--   </pre>
--   
--   The action <tt>g</tt> is called regardless of what occurs within
--   <tt>f</tt>, including async exceptions. Some monads allow <tt>f</tt>
--   to abort the computation via other effects than throwing an exception.
--   For simplicity, we will consider aborting and throwing an exception to
--   be two forms of "throwing an error".
--   
--   If <tt>f</tt> and <tt>g</tt> both throw an error, the error thrown by
--   <tt>fg</tt> depends on which errors we're talking about. In a monad
--   transformer stack, the deeper layers override the effects of the inner
--   layers; for example, <tt>ExceptT e1 (Except e2) a</tt> represents a
--   value of type <tt>Either e2 (Either e1 a)</tt>, so throwing both an
--   <tt>e1</tt> and an <tt>e2</tt> will result in <tt>Left e2</tt>. If
--   <tt>f</tt> and <tt>g</tt> both throw an error from the same layer,
--   instances should ensure that the error from <tt>g</tt> wins.
--   
--   Effects other than throwing an error are also overriden by the deeper
--   layers. For example, <tt>StateT s Maybe a</tt> represents a value of
--   type <tt>s -&gt; Maybe (a, s)</tt>, so if an error thrown from
--   <tt>f</tt> causes this function to return <tt>Nothing</tt>, any
--   changes to the state which <tt>f</tt> also performed will be erased.
--   As a result, <tt>g</tt> will see the state as it was before
--   <tt>f</tt>. Once <tt>g</tt> completes, <tt>f</tt>'s error will be
--   rethrown, so <tt>g</tt>' state changes will be erased as well. This is
--   the normal interaction between effects in a monad transformer stack.
--   
--   By contrast, <a>lifted-base</a>'s version of <a>finally</a> always
--   discards all of <tt>g</tt>'s non-IO effects, and <tt>g</tt> never sees
--   any of <tt>f</tt>'s non-IO effects, regardless of the layer ordering
--   and regardless of whether <tt>f</tt> throws an error. This is not the
--   result of interacting effects, but a consequence of
--   <tt>MonadBaseControl</tt>'s approach.
class MonadCatch m => MonadMask (m :: Type -> Type)

-- | Runs an action with asynchronous exceptions disabled. The action is
--   provided a method for restoring the async. environment to what it was
--   at the <a>mask</a> call. See <a>Control.Exception</a>'s <a>mask</a>.
mask :: MonadMask m => ((forall a. () => m a -> m a) -> m b) -> m b

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception</a>'s <a>uninterruptibleMask</a>. WARNING: Only
--   use if you need to mask exceptions around an interruptible operation
--   AND you can guarantee the interruptible operation will only block for
--   a short period of time. Otherwise you render the program/thread
--   unresponsive and/or unkillable.
uninterruptibleMask :: MonadMask m => ((forall a. () => m a -> m a) -> m b) -> m b

-- | A generalized version of <a>bracket</a> which uses <a>ExitCase</a> to
--   distinguish the different exit cases, and returns the values of both
--   the <tt>use</tt> and <tt>release</tt> actions. In practice, this extra
--   information is rarely needed, so it is often more convenient to use
--   one of the simpler functions which are defined in terms of this one,
--   such as <a>bracket</a>, <a>finally</a>, <a>onError</a>, and
--   <a>bracketOnError</a>.
--   
--   This function exists because in order to thread their effects through
--   the execution of <a>bracket</a>, monad transformers need values to be
--   threaded from <tt>use</tt> to <tt>release</tt> and from
--   <tt>release</tt> to the output value.
--   
--   <i>NOTE</i> This method was added in version 0.9.0 of this library.
--   Previously, implementation of functions like <a>bracket</a> and
--   <a>finally</a> in this module were based on the <a>mask</a> and
--   <a>uninterruptibleMask</a> functions only, disallowing some classes of
--   tranformers from having <tt>MonadMask</tt> instances (notably
--   multi-exit-point transformers like <a>ExceptT</a>). If you are a
--   library author, you'll now need to provide an implementation for this
--   method. The <tt>StateT</tt> implementation demonstrates most of the
--   subtleties:
--   
--   <pre>
--   generalBracket acquire release use = StateT $ s0 -&gt; do
--     ((b, _s2), (c, s3)) &lt;- generalBracket
--       (runStateT acquire s0)
--       ((resource, s1) exitCase -&gt; case exitCase of
--         ExitCaseSuccess (b, s2) -&gt; runStateT (release resource (ExitCaseSuccess b)) s2
--   
--         -- In the two other cases, the base monad overrides <tt>use</tt>'s state
--         -- changes and the state reverts to <tt>s1</tt>.
--         ExitCaseException e     -&gt; runStateT (release resource (ExitCaseException e)) s1
--         ExitCaseAbort           -&gt; runStateT (release resource ExitCaseAbort) s1
--       )
--       ((resource, s1) -&gt; runStateT (use resource) s1)
--     return ((b, c), s3)
--   </pre>
--   
--   The <tt>StateT s m</tt> implementation of <tt>generalBracket</tt>
--   delegates to the <tt>m</tt> implementation of <tt>generalBracket</tt>.
--   The <tt>acquire</tt>, <tt>use</tt>, and <tt>release</tt> arguments
--   given to <tt>StateT</tt>'s implementation produce actions of type
--   <tt>StateT s m a</tt>, <tt>StateT s m b</tt>, and <tt>StateT s m
--   c</tt>. In order to run those actions in the base monad, we need to
--   call <tt>runStateT</tt>, from which we obtain actions of type <tt>m
--   (a, s)</tt>, <tt>m (b, s)</tt>, and <tt>m (c, s)</tt>. Since each
--   action produces the next state, it is important to feed the state
--   produced by the previous action to the next action.
--   
--   In the <a>ExitCaseSuccess</a> case, the state starts at <tt>s0</tt>,
--   flows through <tt>acquire</tt> to become <tt>s1</tt>, flows through
--   <tt>use</tt> to become <tt>s2</tt>, and finally flows through
--   <tt>release</tt> to become <tt>s3</tt>. In the other two cases,
--   <tt>release</tt> does not receive the value <tt>s2</tt>, so its action
--   cannot see the state changes performed by <tt>use</tt>. This is fine,
--   because in those two cases, an error was thrown in the base monad, so
--   as per the usual interaction between effects in a monad transformer
--   stack, those state changes get reverted. So we start from <tt>s1</tt>
--   instead.
--   
--   Finally, the <tt>m</tt> implementation of <tt>generalBracket</tt>
--   returns the pairs <tt>(b, s)</tt> and <tt>(c, s)</tt>. For monad
--   transformers other than <tt>StateT</tt>, this will be some other type
--   representing the effects and values performed and returned by the
--   <tt>use</tt> and <tt>release</tt> actions. The effect part of the
--   <tt>use</tt> result, in this case <tt>_s2</tt>, usually needs to be
--   discarded, since those effects have already been incorporated in the
--   <tt>release</tt> action.
--   
--   The only effect which is intentionally not incorporated in the
--   <tt>release</tt> action is the effect of throwing an error. In that
--   case, the error must be re-thrown. One subtlety which is easy to miss
--   is that in the case in which <tt>use</tt> and <tt>release</tt> both
--   throw an error, the error from <tt>release</tt> should take priority.
--   Here is an implementation for <tt>ExceptT</tt> which demonstrates how
--   to do this.
--   
--   <pre>
--   generalBracket acquire release use = ExceptT $ do
--     (eb, ec) &lt;- generalBracket
--       (runExceptT acquire)
--       (eresource exitCase -&gt; case eresource of
--         Left e -&gt; return (Left e) -- nothing to release, acquire didn't succeed
--         Right resource -&gt; case exitCase of
--           ExitCaseSuccess (Right b) -&gt; runExceptT (release resource (ExitCaseSuccess b))
--           ExitCaseException e       -&gt; runExceptT (release resource (ExitCaseException e))
--           _                         -&gt; runExceptT (release resource ExitCaseAbort))
--       (either (return . Left) (runExceptT . use))
--     return $ do
--       -- The order in which we perform those two <a>Either</a> effects determines
--       -- which error will win if they are both <a>Left</a>s. We want the error from
--       -- <tt>release</tt> to win.
--       c &lt;- ec
--       b &lt;- eb
--       return (b, c)
--   </pre>
generalBracket :: MonadMask m => m a -> (a -> ExitCase b -> m c) -> (a -> m b) -> m (b, c)

-- | <i>O(n)</i> Convert a lazy <a>Text</a> into a strict <a>Text</a>.
toStrict :: Text -> Text

-- | A set of values. A set cannot contain duplicate values.
data HashSet a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s (m :: Type -> Type) a
StateT :: (s -> m (a, s)) -> StateT s a
[runStateT] :: StateT s a -> s -> m (a, s)

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | Boxed vectors, supporting efficient slicing.
data Vector a

-- | The parameterizable reader monad.
--   
--   Computations are functions of a shared environment.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
type Reader r = ReaderT r Identity

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | Infix application.
--   
--   <pre>
--   f :: Either String $ Maybe Int
--   =
--   f :: Either String (Maybe Int)
--   </pre>
type ($) (f :: k -> k1) (a :: k) = f a
infixr 2 $

-- | <a>undefined</a> that leaves a warning in code on every usage.
undefined :: HasCallStack => a

-- | <a>error</a> that takes <a>Text</a> as an argument.
error :: HasCallStack => Text -> a

-- | <tt>s ^.. t</tt> returns the list of all values that <tt>t</tt> gets
--   from <tt>s</tt>.
--   
--   A <a>Maybe</a> contains either 0 or 1 values:
--   
--   <pre>
--   &gt;&gt;&gt; Just 3 ^.. _Just
--   [3]
--   </pre>
--   
--   Gathering all values in a list of tuples:
--   
--   <pre>
--   &gt;&gt;&gt; [(1,2),(3,4)] ^.. each.each
--   [1,2,3,4]
--   </pre>
(^..) :: () => s -> Getting (Endo [a]) s a -> [a]
infixl 8 ^..

-- | (<a>^.</a>) applies a getter to a value; in other words, it gets a
--   value out of a structure using a getter (which can be a lens,
--   traversal, fold, etc.).
--   
--   Getting 1st field of a tuple:
--   
--   <pre>
--   (<a>^.</a> <a>_1</a>) :: (a, b) -&gt; a
--   (<a>^.</a> <a>_1</a>) = <a>fst</a>
--   </pre>
--   
--   When (<a>^.</a>) is used with a traversal, it combines all results
--   using the <a>Monoid</a> instance for the resulting type. For instance,
--   for lists it would be simple concatenation:
--   
--   <pre>
--   &gt;&gt;&gt; ("str","ing") ^. each
--   "string"
--   </pre>
--   
--   The reason for this is that traversals use <a>Applicative</a>, and the
--   <a>Applicative</a> instance for <a>Const</a> uses monoid concatenation
--   to combine “effects” of <a>Const</a>.
--   
--   A non-operator version of (<a>^.</a>) is called <tt>view</tt>, and
--   it's a bit more general than (<a>^.</a>) (it works in
--   <tt>MonadReader</tt>). If you need the general version, you can get it
--   from <a>microlens-mtl</a>; otherwise there's <a>view</a> available in
--   <a>Lens.Micro.Extras</a>.
(^.) :: () => s -> Getting a s a -> a
infixl 8 ^.

-- | <a>set</a> is a synonym for (<a>.~</a>).
--   
--   Setting the 1st component of a pair:
--   
--   <pre>
--   <a>set</a> <a>_1</a> :: x -&gt; (a, b) -&gt; (x, b)
--   <a>set</a> <a>_1</a> = \x t -&gt; (x, snd t)
--   </pre>
--   
--   Using it to rewrite (<a>&lt;$</a>):
--   
--   <pre>
--   <a>set</a> <a>mapped</a> :: <a>Functor</a> f =&gt; a -&gt; f b -&gt; f a
--   <a>set</a> <a>mapped</a> = (<a>&lt;$</a>)
--   </pre>
set :: () => ASetter s t a b -> b -> s -> t

-- | (<a>.~</a>) assigns a value to the target. It's the same thing as
--   using (<a>%~</a>) with <a>const</a>:
--   
--   <pre>
--   l <a>.~</a> x = l <a>%~</a> <a>const</a> x
--   </pre>
--   
--   See <a>set</a> if you want a non-operator synonym.
--   
--   Here it is used to change 2 fields of a 3-tuple:
--   
--   <pre>
--   &gt;&gt;&gt; (0,0,0) &amp; _1 .~ 1 &amp; _3 .~ 3
--   (1,0,3)
--   </pre>
(.~) :: () => ASetter s t a b -> b -> s -> t
infixr 4 .~

-- | <a>over</a> is a synonym for (<a>%~</a>).
--   
--   Getting <a>fmap</a> in a roundabout way:
--   
--   <pre>
--   <a>over</a> <a>mapped</a> :: <a>Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   <a>over</a> <a>mapped</a> = <a>fmap</a>
--   </pre>
--   
--   Applying a function to both components of a pair:
--   
--   <pre>
--   <a>over</a> <a>both</a> :: (a -&gt; b) -&gt; (a, a) -&gt; (b, b)
--   <a>over</a> <a>both</a> = \f t -&gt; (f (fst t), f (snd t))
--   </pre>
--   
--   Using <tt><a>over</a> <a>_2</a></tt> as a replacement for
--   <a>second</a>:
--   
--   <pre>
--   &gt;&gt;&gt; over _2 show (10,20)
--   (10,"20")
--   </pre>
over :: () => ASetter s t a b -> (a -> b) -> s -> t

-- | Gives access to the 1st field of a tuple (up to 5-tuples).
--   
--   Getting the 1st component:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) ^. _1
--   1
--   </pre>
--   
--   Setting the 1st component:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3) &amp; _1 .~ 10
--   (10,2,3)
--   </pre>
--   
--   Note that this lens is lazy, and can set fields even of
--   <a>undefined</a>:
--   
--   <pre>
--   &gt;&gt;&gt; set _1 10 undefined :: (Int, Int)
--   (10,*** Exception: Prelude.undefined
--   </pre>
--   
--   This is done to avoid violating a lens law stating that you can get
--   back what you put:
--   
--   <pre>
--   &gt;&gt;&gt; view _1 . set _1 10 $ (undefined :: (Int, Int))
--   10
--   </pre>
--   
--   The implementation (for 2-tuples) is:
--   
--   <pre>
--   <a>_1</a> f t = (,) <a>&lt;$&gt;</a> f    (<a>fst</a> t)
--                <a>&lt;*&gt;</a> <a>pure</a> (<a>snd</a> t)
--   </pre>
--   
--   or, alternatively,
--   
--   <pre>
--   <a>_1</a> f ~(a,b) = (\a' -&gt; (a',b)) <a>&lt;$&gt;</a> f a
--   </pre>
--   
--   (where <tt>~</tt> means a <a>lazy pattern</a>).
--   
--   <a>_2</a>, <a>_3</a>, <a>_4</a>, and <a>_5</a> are also available (see
--   below).
_1 :: Field1 s t a b => Lens s t a b
_2 :: Field2 s t a b => Lens s t a b
_3 :: Field3 s t a b => Lens s t a b
_4 :: Field4 s t a b => Lens s t a b
_5 :: Field5 s t a b => Lens s t a b

-- | <tt>Lens s t a b</tt> is the lowest common denominator of a setter and
--   a getter, something that has the power of both; it has a
--   <a>Functor</a> constraint, and since both <a>Const</a> and
--   <a>Identity</a> are functors, it can be used whenever a getter or a
--   setter is needed.
--   
--   <ul>
--   <li><tt>a</tt> is the type of the value inside of structure</li>
--   <li><tt>b</tt> is the type of the replaced value</li>
--   <li><tt>s</tt> is the type of the whole structure</li>
--   <li><tt>t</tt> is the type of the structure after replacing <tt>a</tt>
--   in it with <tt>b</tt></li>
--   </ul>
type Lens s t a b = forall (f :: Type -> Type). Functor f => a -> f b -> s -> f t

-- | This is a type alias for monomorphic lenses which don't change the
--   type of the container (or of the value inside).
type Lens' s a = Lens s s a a

-- | <tt>Traversal s t a b</tt> is a generalisation of <a>Lens</a> which
--   allows many targets (possibly 0). It's achieved by changing the
--   constraint to <a>Applicative</a> instead of <a>Functor</a> – indeed,
--   the point of <a>Applicative</a> is that you can combine effects, which
--   is just what we need to have many targets.
--   
--   Ultimately, traversals should follow 2 laws:
--   
--   <pre>
--   t pure ≡ pure
--   fmap (t f) . t g ≡ getCompose . t (Compose . fmap f . g)
--   </pre>
--   
--   The 1st law states that you can't change the shape of the structure or
--   do anything funny with elements (traverse elements which aren't in the
--   structure, create new elements out of thin air, etc.). The 2nd law
--   states that you should be able to fuse 2 identical traversals into
--   one. For a more detailed explanation of the laws, see <a>this blog
--   post</a> (if you prefer rambling blog posts), or <a>The Essence Of The
--   Iterator Pattern</a> (if you prefer papers).
--   
--   Traversing any value twice is a violation of traversal laws. You can,
--   however, traverse values in any order.
type Traversal s t a b = forall (f :: Type -> Type). Applicative f => a -> f b -> s -> f t

-- | This is a type alias for monomorphic traversals which don't change the
--   type of the container (or of the values inside).
type Traversal' s a = Traversal s s a a

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
newtype ReaderT r (m :: Type -> Type) a
ReaderT :: (r -> m a) -> ReaderT r a
[runReaderT] :: ReaderT r a -> r -> m a

-- | <a>preuse</a> is (<a>^?</a>) (or <a>preview</a>) which implicitly
--   operates on the state – it takes the state and applies a traversal (or
--   fold) to it to extract the 1st element the traversal points at.
--   
--   <pre>
--   <a>preuse</a> l = <a>gets</a> (<a>preview</a> l)
--   </pre>
preuse :: MonadState s m => Getting (First a) s a -> m (Maybe a)

-- | <a>use</a> is (<a>^.</a>) (or <a>view</a>) which implicitly operates
--   on the state; for instance, if your state is a record containing a
--   field <tt>foo</tt>, you can write
--   
--   <pre>
--   x &lt;- <a>use</a> foo
--   </pre>
--   
--   to extract <tt>foo</tt> from the state. In other words, <a>use</a> is
--   the same as <a>gets</a>, but for getters instead of functions.
--   
--   The implementation of <a>use</a> is straightforward:
--   
--   <pre>
--   <a>use</a> l = <a>gets</a> (<a>view</a> l)
--   </pre>
--   
--   If you need to extract something with a fold or traversal, you need
--   <a>preuse</a>.
use :: MonadState s m => Getting a s a -> m a

-- | <a>preview</a> is a synonym for (<a>^?</a>), generalised for
--   <a>MonadReader</a> (just like <a>view</a>, which is a synonym for
--   (<a>^.</a>)).
--   
--   <pre>
--   &gt;&gt;&gt; preview each [1..5]
--   Just 1
--   </pre>
preview :: MonadReader s m => Getting (First a) s a -> m (Maybe a)

-- | <a>view</a> is a synonym for (<a>^.</a>), generalised for
--   <a>MonadReader</a> (we are able to use it instead of (<a>^.</a>) since
--   functions are instances of the <a>MonadReader</a> class):
--   
--   <pre>
--   &gt;&gt;&gt; view _1 (1, 2)
--   1
--   </pre>
--   
--   When you're using <a>Reader</a> for config and your config type has
--   lenses generated for it, most of the time you'll be using <a>view</a>
--   instead of <a>asks</a>:
--   
--   <pre>
--   doSomething :: (<a>MonadReader</a> Config m) =&gt; m Int
--   doSomething = do
--     thingy        &lt;- <a>view</a> setting1  -- same as “<a>asks</a> (<a>^.</a> setting1)”
--     anotherThingy &lt;- <a>view</a> setting2
--     ...
--   </pre>
view :: MonadReader s m => Getting a s a -> m a

-- | Map several constraints over several variables.
--   
--   <pre>
--   f :: Each [Show, Read] [a, b] =&gt; a -&gt; b -&gt; String
--   =
--   f :: (Show a, Show b, Read a, Read b) =&gt; a -&gt; b -&gt; String
--   </pre>
--   
--   To specify list with single constraint / variable, don't forget to
--   prefix it with <tt>'</tt>:
--   
--   <pre>
--   f :: Each '[Show] [a, b] =&gt; a -&gt; b -&gt; String
--   </pre>
type family Each (c :: [k -> Constraint]) (as :: [k]) :: Constraint

-- | Shorter alias for <tt>pure ()</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; pass :: Maybe ()
--   Just ()
--   </pre>
pass :: Applicative f => f ()

-- | Stricter version of <a>$</a> operator. Default Prelude defines this at
--   the toplevel module, so we do as well.
--   
--   <pre>
--   &gt;&gt;&gt; const 3 $ Prelude.undefined
--   3
--   
--   &gt;&gt;&gt; const 3 $! Prelude.undefined
--   *** Exception: Prelude.undefined
--   CallStack (from HasCallStack):
--     error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err
--   ...
--   </pre>
($!) :: () => (a -> b) -> a -> b
infixr 0 $!

-- | <a>map</a> generalized to <a>Functor</a>.
--   
--   <pre>
--   &gt;&gt;&gt; map not (Just True)
--   Just False
--   
--   &gt;&gt;&gt; map not [True,False,True,True]
--   [False,True,False,False]
--   </pre>
map :: Functor f => (a -> b) -> f a -> f b

-- | Alias for <tt>fmap . fmap</tt>. Convenient to work with two nested
--   <a>Functor</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; negate &lt;&lt;$&gt;&gt; Just [1,2,3]
--   Just [-1,-2,-3]
--   </pre>
(<<$>>) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
infixl 4 <<$>>

-- | Lifted to <a>MonadIO</a> version of <a>newEmptyMVar</a>.
newEmptyMVar :: MonadIO m => m (MVar a)

-- | Lifted to <a>MonadIO</a> version of <a>newMVar</a>.
newMVar :: MonadIO m => a -> m (MVar a)

-- | Lifted to <a>MonadIO</a> version of <a>putMVar</a>.
putMVar :: MonadIO m => MVar a -> a -> m ()

-- | Lifted to <a>MonadIO</a> version of <a>readMVar</a>.
readMVar :: MonadIO m => MVar a -> m a

-- | Lifted to <a>MonadIO</a> version of <a>swapMVar</a>.
swapMVar :: MonadIO m => MVar a -> a -> m a

-- | Lifted to <a>MonadIO</a> version of <a>takeMVar</a>.
takeMVar :: MonadIO m => MVar a -> m a

-- | Lifted to <a>MonadIO</a> version of <a>tryPutMVar</a>.
tryPutMVar :: MonadIO m => MVar a -> a -> m Bool

-- | Lifted to <a>MonadIO</a> version of <a>tryReadMVar</a>.
tryReadMVar :: MonadIO m => MVar a -> m (Maybe a)

-- | Lifted to <a>MonadIO</a> version of <a>tryTakeMVar</a>.
tryTakeMVar :: MonadIO m => MVar a -> m (Maybe a)

-- | Lifted to <a>MonadIO</a> version of <a>atomically</a>.
atomically :: MonadIO m => STM a -> m a

-- | Lifted to <a>MonadIO</a> version of <a>newTVarIO</a>.
newTVarIO :: MonadIO m => a -> m (TVar a)

-- | Lifted to <a>MonadIO</a> version of <a>readTVarIO</a>.
readTVarIO :: MonadIO m => TVar a -> m a

-- | Lifted version of <a>exitWith</a>.
exitWith :: MonadIO m => ExitCode -> m a

-- | Lifted version of <a>exitFailure</a>.
exitFailure :: MonadIO m => m a

-- | Lifted version of <a>exitSuccess</a>.
exitSuccess :: MonadIO m => m a

-- | Lifted version of <a>die</a>. <a>die</a> is available since base-4.8,
--   but it's more convenient to redefine it instead of using CPP.
die :: MonadIO m => String -> m a

-- | Lifted version of <a>appendFile</a>.
appendFile :: MonadIO m => FilePath -> Text -> m ()

-- | Lifted version of <a>getLine</a>.
getLine :: MonadIO m => m Text

-- | Lifted version of <a>openFile</a>.
--   
--   See also <a>withFile</a> for more information.
openFile :: MonadIO m => FilePath -> IOMode -> m Handle

-- | Close a file handle
--   
--   See also <a>withFile</a> for more information.
hClose :: MonadIO m => Handle -> m ()

-- | Opens a file, manipulates it with the provided function and closes the
--   handle before returning. The <a>Handle</a> can be written to using the
--   <a>hPutStr</a> and <a>hPutStrLn</a> functions.
--   
--   <a>withFile</a> is essentially the <a>bracket</a> pattern, specialized
--   to files. This should be preferred over <a>openFile</a> +
--   <a>hClose</a> as it properly deals with (asynchronous) exceptions. In
--   cases where <a>withFile</a> is insufficient, for instance because the
--   it is not statically known when manipulating the <a>Handle</a> has
--   finished, one should consider other safe paradigms for resource usage,
--   such as the <tt>ResourceT</tt> transformer from the <tt>resourcet</tt>
--   package, before resorting to <a>openFile</a> and <a>hClose</a>.
withFile :: (MonadIO m, MonadMask m) => FilePath -> IOMode -> (Handle -> m a) -> m a

-- | Lifted version of <a>newIORef</a>.
newIORef :: MonadIO m => a -> m (IORef a)

-- | Lifted version of <a>readIORef</a>.
readIORef :: MonadIO m => IORef a -> m a

-- | Lifted version of <a>writeIORef</a>.
writeIORef :: MonadIO m => IORef a -> a -> m ()

-- | Lifted version of <a>modifyIORef</a>.
modifyIORef :: MonadIO m => IORef a -> (a -> a) -> m ()

-- | Lifted version of <a>modifyIORef'</a>.
modifyIORef' :: MonadIO m => IORef a -> (a -> a) -> m ()

-- | Lifted version of <a>atomicModifyIORef</a>.
atomicModifyIORef :: MonadIO m => IORef a -> (a -> (a, b)) -> m b

-- | Lifted version of <a>atomicModifyIORef'</a>.
atomicModifyIORef' :: MonadIO m => IORef a -> (a -> (a, b)) -> m b

-- | Lifted version of <a>atomicWriteIORef</a>.
atomicWriteIORef :: MonadIO m => IORef a -> a -> m ()

-- | Similar to <a>fromMaybe</a> but with flipped arguments.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "True" ?: False
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "Tru" ?: False
--   False
--   </pre>
(?:) :: () => Maybe a -> a -> a
infixr 0 ?:

-- | Monadic version of <a>whenJust</a>.
whenJustM :: Monad m => m (Maybe a) -> (a -> m ()) -> m ()

-- | Performs default <a>Applicative</a> action if <a>Nothing</a> is given.
--   Do nothing for <a>Just</a>. Convenient for discarding <a>Just</a>
--   content.
--   
--   <pre>
--   &gt;&gt;&gt; whenNothing_ Nothing $ putTextLn "Nothing!"
--   Nothing!
--   
--   &gt;&gt;&gt; whenNothing_ (Just True) $ putTextLn "Nothing!"
--   </pre>
whenNothing_ :: Applicative f => Maybe a -> f () -> f ()

-- | Monadic version of <a>whenNothing</a>.
whenNothingM :: Monad m => m (Maybe a) -> m a -> m a

-- | Monadic version of <a>whenNothingM_</a>.
whenNothingM_ :: Monad m => m (Maybe a) -> m () -> m ()

-- | Extracts value from <a>Left</a> or return given default value.
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft 0 (Left 3)
--   3
--   
--   &gt;&gt;&gt; fromLeft 0 (Right 5)
--   0
--   </pre>
fromLeft :: () => a -> Either a b -> a

-- | Extracts value from <a>Right</a> or return given default value.
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 0 (Left 3)
--   0
--   
--   &gt;&gt;&gt; fromRight 0 (Right 5)
--   5
--   </pre>
fromRight :: () => b -> Either a b -> b

-- | Maps left part of <a>Either</a> to <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; leftToMaybe (Left True)
--   Just True
--   
--   &gt;&gt;&gt; leftToMaybe (Right "aba")
--   Nothing
--   </pre>
leftToMaybe :: () => Either l r -> Maybe l

-- | Maps right part of <a>Either</a> to <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; rightToMaybe (Left True)
--   Nothing
--   
--   &gt;&gt;&gt; rightToMaybe (Right "aba")
--   Just "aba"
--   </pre>
rightToMaybe :: () => Either l r -> Maybe r

-- | Maps <a>Maybe</a> to <a>Either</a> wrapping default value into
--   <a>Left</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maybeToRight True (Just "aba")
--   Right "aba"
--   
--   &gt;&gt;&gt; maybeToRight True Nothing
--   Left True
--   </pre>
maybeToRight :: () => l -> Maybe r -> Either l r

-- | Maps <a>Maybe</a> to <a>Either</a> wrapping default value into
--   <a>Right</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maybeToLeft True (Just "aba")
--   Left "aba"
--   
--   &gt;&gt;&gt; maybeToLeft True Nothing
--   Right True
--   </pre>
maybeToLeft :: () => r -> Maybe l -> Either l r

-- | Applies given action to <a>Either</a> content if <a>Left</a> is given.
whenLeft :: Applicative f => Either l r -> (l -> f ()) -> f ()

-- | Monadic version of <a>whenLeft</a>.
whenLeftM :: Monad m => m (Either l r) -> (l -> m ()) -> m ()

-- | Applies given action to <a>Either</a> content if <a>Right</a> is
--   given.
whenRight :: Applicative f => Either l r -> (r -> f ()) -> f ()

-- | Monadic version of <a>whenRight</a>.
whenRightM :: Monad m => m (Either l r) -> (r -> m ()) -> m ()

-- | Shorter and more readable alias for <tt>flip runReaderT</tt>.
usingReaderT :: () => r -> ReaderT r m a -> m a

-- | Shorter and more readable alias for <tt>flip runReader</tt>.
usingReader :: () => r -> Reader r a -> a

-- | Shorter and more readable alias for <tt>flip runStateT</tt>.
usingStateT :: () => s -> StateT s m a -> m (a, s)

-- | Shorter and more readable alias for <tt>flip runState</tt>.
usingState :: () => s -> State s a -> (a, s)

-- | Alias for <tt>flip evalStateT</tt>. It's not shorter but sometimes
--   more readable. Done by analogy with <tt>using*</tt> functions family.
evaluatingStateT :: Functor f => s -> StateT s f a -> f a

-- | Alias for <tt>flip evalState</tt>. It's not shorter but sometimes more
--   readable. Done by analogy with <tt>using*</tt> functions family.
evaluatingState :: () => s -> State s a -> a

-- | Alias for <tt>flip execStateT</tt>. It's not shorter but sometimes
--   more readable. Done by analogy with <tt>using*</tt> functions family.
executingStateT :: Functor f => s -> StateT s f a -> f s

-- | Alias for <tt>flip execState</tt>. It's not shorter but sometimes more
--   readable. Done by analogy with <tt>using*</tt> functions family.
executingState :: () => s -> State s a -> s

-- | Extracts <a>Monoid</a> value from <a>Maybe</a> returning <a>mempty</a>
--   if <tt>Nothing</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; maybeToMonoid (Just [1,2,3] :: Maybe [Int])
--   [1,2,3]
--   
--   &gt;&gt;&gt; maybeToMonoid (Nothing :: Maybe [Int])
--   []
--   </pre>
maybeToMonoid :: Monoid m => Maybe m -> m

-- | Type class for types that can be created from one element.
--   <tt>singleton</tt> is lone name for this function. Also constructions
--   of different type differ: <tt>:[]</tt> for lists, two arguments for
--   Maps. Also some data types are monomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; one True :: [Bool]
--   [True]
--   
--   &gt;&gt;&gt; one 'a' :: Text
--   "a"
--   
--   &gt;&gt;&gt; one (3, "hello") :: HashMap Int String
--   fromList [(3,"hello")]
--   </pre>
class One x where {
    type family OneItem x :: Type;
}

-- | Create a list, map, <a>Text</a>, etc from a single element.
one :: One x => OneItem x -> x

-- | Very similar to <a>Foldable</a> but also allows instances for
--   monomorphic types like <a>Text</a> but forbids instances for
--   <a>Maybe</a> and similar. This class is used as a replacement for
--   <a>Foldable</a> type class. It solves the following problems:
--   
--   <ol>
--   <li><a>Container</a>, <a>foldr</a> and other functions work on more
--   types for which it makes sense.</li>
--   <li>You can't accidentally use <a>Container</a> on polymorphic
--   <a>Foldable</a> (like list), replace list with <a>Maybe</a> and then
--   debug error for two days.</li>
--   <li>More efficient implementaions of functions for polymorphic types
--   (like <a>elem</a> for <a>Set</a>).</li>
--   </ol>
--   
--   The drawbacks:
--   
--   <ol>
--   <li>Type signatures of polymorphic functions look more scary.</li>
--   <li>Orphan instances are involved if you want to use <a>foldr</a> (and
--   similar) on types from libraries.</li>
--   </ol>
class Container t where {
    
    -- | Type of element for some container. Implemented as an asscociated type
    --   family because some containers are monomorphic over element type (like
    --   <a>Text</a>, <a>IntSet</a>, etc.) so we can't implement nice interface
    --   using old higher-kinded types approach. Implementing this as an
    --   associated type family instead of top-level family gives you more
    --   control over element types.
    type family Element t :: Type;
}

-- | Convert container to list of elements.
--   
--   <pre>
--   &gt;&gt;&gt; toList @Text "aba"
--   "aba"
--   
--   &gt;&gt;&gt; :t toList @Text "aba"
--   toList @Text "aba" :: [Char]
--   </pre>
toList :: Container t => t -> [Element t]

-- | Checks whether container is empty.
--   
--   <pre>
--   &gt;&gt;&gt; null @Text ""
--   True
--   
--   &gt;&gt;&gt; null @Text "aba"
--   False
--   </pre>
null :: Container t => t -> Bool
foldr :: Container t => (Element t -> b -> b) -> b -> t -> b
foldl :: Container t => (b -> Element t -> b) -> b -> t -> b
foldl' :: Container t => (b -> Element t -> b) -> b -> t -> b
length :: Container t => t -> Int
elem :: Container t => Element t -> t -> Bool
maximum :: Container t => t -> Element t
minimum :: Container t => t -> Element t
foldMap :: (Container t, Monoid m) => (Element t -> m) -> t -> m
fold :: Container t => t -> Element t
foldr' :: Container t => (Element t -> b -> b) -> b -> t -> b
foldr1 :: Container t => (Element t -> Element t -> Element t) -> t -> Element t
foldl1 :: Container t => (Element t -> Element t -> Element t) -> t -> Element t
notElem :: Container t => Element t -> t -> Bool
all :: Container t => (Element t -> Bool) -> t -> Bool
any :: Container t => (Element t -> Bool) -> t -> Bool
find :: Container t => (Element t -> Bool) -> t -> Maybe (Element t)
safeHead :: Container t => t -> Maybe (Element t)

-- | Type class for data types that can be converted to List of Pairs. You
--   can define <a>ToPairs</a> by just defining <a>toPairs</a> function.
--   
--   But the following laws should be met:
--   
--   <pre>
--   <a>toPairs</a> m ≡ <a>zip</a> (<a>keys</a> m) (<a>elems</a> m)
--   <a>keys</a>      ≡ <a>map</a> <a>fst</a> . <a>toPairs</a>
--   <a>elems</a>     ≡ <a>map</a> <a>snd</a> . <a>toPairs</a>
--   </pre>
class ToPairs t

-- | Converts the structure to the list of the key-value pairs.
--   &gt;&gt;&gt; toPairs (HashMap.fromList [(<tt>a</tt>, "xxx"),
--   (<tt>b</tt>, "yyy")]) [(<tt>a</tt>,"xxx"),(<tt>b</tt>,"yyy")]
toPairs :: ToPairs t => t -> [(Key t, Val t)]

-- | Converts the structure to the list of the keys.
--   
--   <pre>
--   &gt;&gt;&gt; keys (HashMap.fromList [('a', "xxx"), ('b', "yyy")])
--   "ab"
--   </pre>
keys :: ToPairs t => t -> [Key t]

-- | Converts the structure to the list of the values.
--   
--   <pre>
--   &gt;&gt;&gt; elems (HashMap.fromList [('a', "xxx"), ('b', "yyy")])
--   ["xxx","yyy"]
--   </pre>
elems :: ToPairs t => t -> [Val t]

-- | Similar to <a>foldl'</a> but takes a function with its arguments
--   flipped.
--   
--   <pre>
--   &gt;&gt;&gt; flipfoldl' (/) 5 [2,3] :: Rational
--   15 % 2
--   </pre>
flipfoldl' :: (Container t, Element t ~ a) => (a -> b -> b) -> b -> t -> b

-- | Stricter version of <a>sum</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   
--   &gt;&gt;&gt; sum (Just 3)
--   ...
--       • Do not use 'Foldable' methods on Maybe
--         Suggestions:
--             Instead of
--                 for_ :: (Foldable t, Applicative f) =&gt; t a -&gt; (a -&gt; f b) -&gt; f ()
--             use
--                 whenJust  :: Applicative f =&gt; Maybe a    -&gt; (a -&gt; f ()) -&gt; f ()
--                 whenRight :: Applicative f =&gt; Either l r -&gt; (r -&gt; f ()) -&gt; f ()
--   ...
--             Instead of
--                 fold :: (Foldable t, Monoid m) =&gt; t m -&gt; m
--             use
--                 maybeToMonoid :: Monoid m =&gt; Maybe m -&gt; m
--   ...
--   </pre>
sum :: (Container t, Num (Element t)) => t -> Element t

-- | Stricter version of <a>product</a>.
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   
--   &gt;&gt;&gt; product (Right 3)
--   ...
--       • Do not use 'Foldable' methods on Either
--         Suggestions:
--             Instead of
--                 for_ :: (Foldable t, Applicative f) =&gt; t a -&gt; (a -&gt; f b) -&gt; f ()
--             use
--                 whenJust  :: Applicative f =&gt; Maybe a    -&gt; (a -&gt; f ()) -&gt; f ()
--                 whenRight :: Applicative f =&gt; Either l r -&gt; (r -&gt; f ()) -&gt; f ()
--   ...
--             Instead of
--                 fold :: (Foldable t, Monoid m) =&gt; t m -&gt; m
--             use
--                 maybeToMonoid :: Monoid m =&gt; Maybe m -&gt; m
--   ...
--   </pre>
product :: (Container t, Num (Element t)) => t -> Element t

-- | Constrained to <a>Container</a> version of <a>traverse_</a>.
--   
--   <pre>
--   &gt;&gt;&gt; traverse_ putTextLn ["foo", "bar"]
--   foo
--   bar
--   </pre>
traverse_ :: (Container t, Applicative f) => (Element t -> f b) -> t -> f ()

-- | Constrained to <a>Container</a> version of <a>for_</a>.
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1 .. 5 :: Int] $ \i -&gt; when (even i) (print i)
--   2
--   4
--   </pre>
for_ :: (Container t, Applicative f) => t -> (Element t -> f b) -> f ()

-- | Constrained to <a>Container</a> version of <a>mapM_</a>.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print [True, False]
--   True
--   False
--   </pre>
mapM_ :: (Container t, Monad m) => (Element t -> m b) -> t -> m ()

-- | Constrained to <a>Container</a> version of <a>forM_</a>.
--   
--   <pre>
--   &gt;&gt;&gt; forM_ [True, False] print
--   True
--   False
--   </pre>
forM_ :: (Container t, Monad m) => t -> (Element t -> m b) -> m ()

-- | Constrained to <a>Container</a> version of <a>sequenceA_</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA_ [putTextLn "foo", print True]
--   foo
--   True
--   </pre>
sequenceA_ :: (Container t, Applicative f, Element t ~ f a) => t -> f ()

-- | Constrained to <a>Container</a> version of <a>sequence_</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence_ [putTextLn "foo", print True]
--   foo
--   True
--   </pre>
sequence_ :: (Container t, Monad m, Element t ~ m a) => t -> m ()

-- | Constrained to <a>Container</a> version of <a>asum</a>.
--   
--   <pre>
--   &gt;&gt;&gt; asum [Nothing, Just [False, True], Nothing, Just [True]]
--   Just [False,True]
--   </pre>
asum :: (Container t, Alternative f, Element t ~ f a) => t -> f a

-- | Lifting bind into a monad. Generalized version of <tt>concatMap</tt>
--   that works with a monadic predicate. Old and simpler specialized to
--   list version had next type:
--   
--   <pre>
--   concatMapM :: Monad m =&gt; (a -&gt; m [b]) -&gt; [a] -&gt; m [b]
--   </pre>
--   
--   Side note: previously it had type
--   
--   <pre>
--   concatMapM :: (Applicative q, Monad m, Traversable m)
--              =&gt; (a -&gt; q (m b)) -&gt; m a -&gt; q (m b)
--   </pre>
--   
--   Such signature didn't allow to use this function when traversed
--   container type and type of returned by function-argument differed. Now
--   you can use it like e.g.
--   
--   <pre>
--   concatMapM readFile files &gt;&gt;= putTextLn
--   </pre>
concatMapM :: (Applicative f, Monoid m, Container (l m), Element (l m) ~ m, Traversable l) => (a -> f m) -> l a -> f m

-- | Like <a>concatMapM</a>, but has its arguments flipped, so can be used
--   instead of the common <tt>fmap concat $ forM</tt> pattern.
concatForM :: (Applicative f, Monoid m, Container (l m), Element (l m) ~ m, Traversable l) => l a -> (a -> f m) -> f m

-- | Monadic and constrained to <a>Container</a> version of <a>and</a>.
--   
--   <pre>
--   &gt;&gt;&gt; andM [Just True, Just False]
--   Just False
--   
--   &gt;&gt;&gt; andM [Just True]
--   Just True
--   
--   &gt;&gt;&gt; andM [Just True, Just False, Nothing]
--   Just False
--   
--   &gt;&gt;&gt; andM [Just True, Nothing]
--   Nothing
--   
--   &gt;&gt;&gt; andM [putTextLn "1" &gt;&gt; pure True, putTextLn "2" &gt;&gt; pure False, putTextLn "3" &gt;&gt; pure True]
--   1
--   2
--   False
--   </pre>
andM :: (Container f, Element f ~ m Bool, Monad m) => f -> m Bool

-- | Monadic and constrained to <a>Container</a> version of <a>or</a>.
--   
--   <pre>
--   &gt;&gt;&gt; orM [Just True, Just False]
--   Just True
--   
--   &gt;&gt;&gt; orM [Just True, Nothing]
--   Just True
--   
--   &gt;&gt;&gt; orM [Nothing, Just True]
--   Nothing
--   </pre>
orM :: (Container f, Element f ~ m Bool, Monad m) => f -> m Bool

-- | Monadic and constrained to <a>Container</a> version of <a>all</a>.
--   
--   <pre>
--   &gt;&gt;&gt; allM (readMaybe &gt;=&gt; pure . even) ["6", "10"]
--   Just True
--   
--   &gt;&gt;&gt; allM (readMaybe &gt;=&gt; pure . even) ["5", "aba"]
--   Just False
--   
--   &gt;&gt;&gt; allM (readMaybe &gt;=&gt; pure . even) ["aba", "10"]
--   Nothing
--   </pre>
allM :: (Container f, Monad m) => (Element f -> m Bool) -> f -> m Bool

-- | Monadic and constrained to <a>Container</a> version of <a>any</a>.
--   
--   <pre>
--   &gt;&gt;&gt; anyM (readMaybe &gt;=&gt; pure . even) ["5", "10"]
--   Just True
--   
--   &gt;&gt;&gt; anyM (readMaybe &gt;=&gt; pure . even) ["10", "aba"]
--   Just True
--   
--   &gt;&gt;&gt; anyM (readMaybe &gt;=&gt; pure . even) ["aba", "10"]
--   Nothing
--   </pre>
anyM :: (Container f, Monad m) => (Element f -> m Bool) -> f -> m Bool

-- | Destructuring list into its head and tail if possible. This function
--   is total.
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   
--   &gt;&gt;&gt; uncons [1..5]
--   Just (1,[2,3,4,5])
--   
--   &gt;&gt;&gt; uncons (5 : [1..5]) &gt;&gt;= \(f, l) -&gt; pure $ f == length l
--   Just True
--   </pre>
uncons :: () => [a] -> Maybe (a, [a])

-- | Performs given action over <a>NonEmpty</a> list if given list is non
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; whenNotNull [] $ \(b :| _) -&gt; print (not b)
--   
--   &gt;&gt;&gt; whenNotNull [False,True] $ \(b :| _) -&gt; print (not b)
--   True
--   </pre>
whenNotNull :: Applicative f => [a] -> (NonEmpty a -> f ()) -> f ()

-- | Monadic version of <a>whenNotNull</a>.
whenNotNullM :: Monad m => m [a] -> (NonEmpty a -> m ()) -> m ()

-- | Type that represents exceptions used in cases when a particular
--   codepath is not meant to be ever executed, but happens to be executed
--   anyway.
data Bug
Bug :: SomeException -> CallStack -> Bug

-- | Pattern synonym to easy pattern matching on exceptions. So intead of
--   writing something like this:
--   
--   <pre>
--   isNonCriticalExc e
--       | Just (_ :: NodeAttackedError) &lt;- fromException e = True
--       | Just DialogUnexpected{} &lt;- fromException e = True
--       | otherwise = False
--   </pre>
--   
--   you can use <a>Exc</a> pattern synonym:
--   
--   <pre>
--   isNonCriticalExc = case
--       Exc (_ :: NodeAttackedError) -&gt; True  -- matching all exceptions of type <tt>NodeAttackedError</tt>
--       Exc DialogUnexpected{} -&gt; True
--       _ -&gt; False
--   </pre>
--   
--   This pattern is bidirectional. You can use <tt>Exc e</tt> instead of
--   <tt>toException e</tt>.
pattern Exc :: forall e. Exception e => () => e -> SomeException

-- | Generate a pure value which, when forced, will synchronously throw the
--   exception wrapped into <a>Bug</a> data type.
bug :: (HasCallStack, Exception e) => e -> a

-- | Throws error for <a>Maybe</a> if <a>Nothing</a> is given. Operates
--   over <a>MonadError</a>.
note :: MonadError e m => e -> Maybe a -> m a

-- | Lifted alias for <a>evaluate</a> with clearer name.
evaluateWHNF :: MonadIO m => a -> m a

-- | Like <tt>evaluateWNHF</tt> but discards value.
evaluateWHNF_ :: MonadIO m => a -> m ()

-- | Alias for <tt>evaluateWHNF . force</tt> with clearer name.
evaluateNF :: (NFData a, MonadIO m) => a -> m a

-- | Alias for <tt>evaluateWHNF . rnf</tt>. Similar to <a>evaluateNF</a>
--   but discards resulting value.
evaluateNF_ :: (NFData a, MonadIO m) => a -> m ()

-- | Monadic version of <a>when</a>.
--   
--   <pre>
--   &gt;&gt;&gt; whenM (pure False) $ putTextLn "No text :("
--   
--   &gt;&gt;&gt; whenM (pure True)  $ putTextLn "Yes text :)"
--   Yes text :)
--   
--   &gt;&gt;&gt; whenM (Just True) (pure ())
--   Just ()
--   
--   &gt;&gt;&gt; whenM (Just False) (pure ())
--   Just ()
--   
--   &gt;&gt;&gt; whenM Nothing (pure ())
--   Nothing
--   </pre>
whenM :: Monad m => m Bool -> m () -> m ()

-- | Monadic version of <a>unless</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unlessM (pure False) $ putTextLn "No text :("
--   No text :(
--   
--   &gt;&gt;&gt; unlessM (pure True) $ putTextLn "Yes text :)"
--   </pre>
unlessM :: Monad m => m Bool -> m () -> m ()

-- | Monadic version of <tt>if-then-else</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; ifM (pure True) (putTextLn "True text") (putTextLn "False text")
--   True text
--   </pre>
ifM :: Monad m => m Bool -> m a -> m a -> m a

-- | Monadic version of <a>guard</a>. Occasionally useful. Here some
--   complex but real-life example:
--   
--   <pre>
--   findSomePath :: IO (Maybe FilePath)
--   
--   somePath :: MaybeT IO FilePath
--   somePath = do
--       path &lt;- MaybeT findSomePath
--       guardM $ liftIO $ doesDirectoryExist path
--       return path
--   </pre>
guardM :: MonadPlus m => m Bool -> m ()

-- | Like <a>nub</a> but runs in <tt>O(n * log n)</tt> time and requires
--   <a>Ord</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ordNub [3, 3, 3, 2, 2, -1, 1]
--   [3,2,-1,1]
--   </pre>
ordNub :: Ord a => [a] -> [a]

-- | Like <a>nub</a> but runs in <tt>O(n * log_16(n))</tt> time and
--   requires <a>Hashable</a>.
--   
--   <pre>
--   &gt;&gt;&gt; hashNub [3, 3, 3, 2, 2, -1, 1]
--   [3,2,-1,1]
--   </pre>
hashNub :: (Eq a, Hashable a) => [a] -> [a]

-- | Like <a>ordNub</a> but also sorts a list.
--   
--   <pre>
--   &gt;&gt;&gt; sortNub [3, 3, 3, 2, 2, -1, 1]
--   [-1,1,2,3]
--   </pre>
sortNub :: Ord a => [a] -> [a]

-- | Like <a>hashNub</a> but has better performance and also doesn't save
--   the order.
--   
--   <pre>
--   &gt;&gt;&gt; unstableNub [3, 3, 3, 2, 2, -1, 1]
--   [1,2,3,-1]
--   </pre>
unstableNub :: (Eq a, Hashable a) => [a] -> [a]

-- | Support class to overload writing of string like values.
class Print a

-- | Write a string like value <tt>a</tt> to a supplied <a>Handle</a>.
hPutStr :: (Print a, MonadIO m) => Handle -> a -> m ()

-- | Write a string like value <tt>a</tt> to a supplied <a>Handle</a>,
--   appending a newline character.
hPutStrLn :: (Print a, MonadIO m) => Handle -> a -> m ()

-- | Write a string like value to <tt>stdout</tt>/.
putStr :: (Print a, MonadIO m) => a -> m ()

-- | Write a string like value to <tt>stdout</tt> appending a newline
--   character.
putStrLn :: (Print a, MonadIO m) => a -> m ()

-- | Lifted version of <a>print</a>.
print :: (MonadIO m, Show a) => a -> m ()

-- | Lifted version of <a>hPrint</a>
hPrint :: (MonadIO m, Show a) => Handle -> a -> m ()

-- | Specialized to <a>Text</a> version of <a>putStr</a> or forcing type
--   inference.
putText :: MonadIO m => Text -> m ()

-- | Specialized to <a>Text</a> version of <a>putStrLn</a> or forcing type
--   inference.
putTextLn :: MonadIO m => Text -> m ()

-- | Specialized to <a>Text</a> version of <a>putStr</a> or forcing type
--   inference.
putLText :: MonadIO m => Text -> m ()

-- | Specialized to <a>Text</a> version of <a>putStrLn</a> or forcing type
--   inference.
putLTextLn :: MonadIO m => Text -> m ()

-- | Similar to <a>undefined</a> but data type.
data Undefined
Undefined :: Undefined

-- | Version of <a>trace</a> that leaves a warning and takes <a>Text</a>.
trace :: () => Text -> a -> a

-- | Version of <a>traceShow</a> that leaves a warning.
traceShow :: Show a => a -> b -> b

-- | Version of <a>traceShowId</a> that leaves a warning.
traceShowId :: Show a => a -> a

-- | Version of <a>traceId</a> that leaves a warning. Useful to tag printed
--   data, for instance:
--   
--   <pre>
--   traceIdWith (x -&gt; "My data: " &lt;&gt; show x) (veryLargeExpression)
--   </pre>
--   
--   This is especially useful with custom formatters:
--   
--   <pre>
--   traceIdWith (x -&gt; "My data: " &lt;&gt; pretty x) (veryLargeExpression)
--   </pre>
traceIdWith :: () => (a -> Text) -> a -> a

-- | Version of <a>traceShowId</a> that leaves a warning. Useful to tag
--   printed data, for instance:
--   
--   <pre>
--   traceShowIdWith ("My data: ", ) (veryLargeExpression)
--   </pre>
traceShowIdWith :: Show s => (a -> s) -> a -> a

-- | Version of <a>traceShowM</a> that leaves a warning.
traceShowM :: (Show a, Monad m) => a -> m ()

-- | Version of <a>traceM</a> that leaves a warning and takes <a>Text</a>.
traceM :: Monad m => Text -> m ()

-- | Version of <a>traceId</a> that leaves a warning.
traceId :: Text -> Text

-- | Type class for converting other strings to <a>String</a>.
class ToString a
toString :: ToString a => a -> String

-- | Type class for converting other strings to <a>Text</a>.
class ToLText a
toLText :: ToLText a => a -> Text

-- | Type class for converting other strings to <a>Text</a>.
class ToText a
toText :: ToText a => a -> Text

-- | Type class for conversion to utf8 representation of text.
class ConvertUtf8 a b

-- | Encode as utf8 string (usually <a>ByteString</a>).
--   
--   <pre>
--   &gt;&gt;&gt; encodeUtf8 @Text @ByteString "патак"
--   "\208\191\208\176\209\130\208\176\208\186"
--   </pre>
encodeUtf8 :: ConvertUtf8 a b => a -> b

-- | Decode from utf8 string.
--   
--   <pre>
--   &gt;&gt;&gt; decodeUtf8 @Text @ByteString "\208\191\208\176\209\130\208\176\208\186"
--   "\1087\1072\1090\1072\1082"
--   
--   &gt;&gt;&gt; putStrLn $ decodeUtf8 @Text @ByteString "\208\191\208\176\209\130\208\176\208\186"
--   патак
--   </pre>
decodeUtf8 :: ConvertUtf8 a b => b -> a

-- | Decode as utf8 string but returning execption if byte sequence is
--   malformed.
--   
--   <pre>
--   &gt;&gt;&gt; decodeUtf8 @Text @ByteString "\208\208\176\209\130\208\176\208\186"
--   "\65533\1072\1090\1072\1082"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeUtf8Strict @Text @ByteString "\208\208\176\209\130\208\176\208\186"
--   Left Cannot decode byte '\xd0': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream
--   </pre>
decodeUtf8Strict :: ConvertUtf8 a b => b -> Either UnicodeException a

-- | Type synonym for <a>ByteString</a>.
type LByteString = ByteString

-- | Type synonym for <a>Text</a>.
type LText = Text

-- | Polymorhpic version of <a>readEither</a>.
--   
--   <pre>
--   &gt;&gt;&gt; readEither @Text @Int "123"
--   Right 123
--   
--   &gt;&gt;&gt; readEither @Text @Int "aa"
--   Left "Prelude.read: no parse"
--   </pre>
readEither :: (ToString a, Read b) => a -> Either Text b

-- | Generalized version of <a>show</a>.
show :: (Show a, IsString b) => a -> b

-- | Map several constraints over a single variable. Note, that <tt>With a
--   b ≡ Each a '[b]</tt>
--   
--   <pre>
--   a :: With [Show, Read] a =&gt; a -&gt; a
--   =
--   a :: (Show a, Read a) =&gt; a -&gt; a
--   </pre>
type With (a :: [k -> Constraint]) (b :: k) = a <+> b

-- | This type class allows to implement variadic composition operator.
class SuperComposition a b c | a b -> c

-- | Allows to apply function to result of another function with multiple
--   arguments.
--   
--   <pre>
--   &gt;&gt;&gt; (show ... (+)) 1 2
--   "3"
--   
--   &gt;&gt;&gt; show ... 5
--   "5"
--   
--   &gt;&gt;&gt; (null ... zip5) [1] [2] [3] [] [5]
--   True
--   </pre>
--   
--   Inspired by
--   <a>http://stackoverflow.com/questions/9656797/variadic-compose-function</a>.
--   
--   <h4>Performance</h4>
--   
--   To check the performance there was done a bunch of benchmarks.
--   Benchmarks were made on examples given above and also on the functions
--   of many arguments. The results are showing that the operator
--   (<a>...</a>) performs as fast as plain applications of the operator
--   (<a>.</a>) on almost all the tests, but (<a>...</a>) leads to the
--   performance draw-down if <tt>ghc</tt> fails to inline it. Slow
--   behavior was noticed on functions without type specifications. That's
--   why keep in mind that providing explicit type declarations for
--   functions is very important when using (<a>...</a>). Relying on type
--   inference will lead to the situation when all optimizations disappear
--   due to very general inferred type. However, functions without type
--   specification but with applied <tt>INLINE</tt> pragma are fast again.
(...) :: SuperComposition a b c => a -> b -> c
infixl 8 ...

-- | Convert a <a>MaybeT</a> computation to <a>ExceptT</a>, with a default
--   exception value.
maybeToExceptT :: Functor m => e -> MaybeT m a -> ExceptT e m a

-- | Convert a <a>ExceptT</a> computation to <a>MaybeT</a>, discarding the
--   value of any exception.
exceptToMaybeT :: Functor m => ExceptT e m a -> MaybeT m a

-- | An exception type for representing Unicode encoding errors.
data UnicodeException

-- | A handler for a decoding error.
type OnDecodeError = OnError Word8 Char

-- | Function type for handling a coding error. It is supplied with two
--   inputs:
--   
--   <ul>
--   <li>A <a>String</a> that describes the error.</li>
--   <li>The input value that caused the error. If the error arose because
--   the end of input was reached or could not be identified precisely,
--   this value will be <a>Nothing</a>.</li>
--   </ul>
--   
--   If the handler returns a value wrapped with <a>Just</a>, that value
--   will be used in the output as the replacement for the invalid input.
--   If it returns <a>Nothing</a>, no value will be used in the output.
--   
--   Should the handler need to abort processing, it should use
--   <a>error</a> or <a>throw</a> an exception (preferably a
--   <a>UnicodeException</a>). It may use the description provided to
--   construct a more helpful error report.
type OnError a b = String -> Maybe a -> Maybe b

-- | Throw a <a>UnicodeException</a> if decoding fails.
strictDecode :: OnDecodeError

-- | Replace an invalid input byte with the Unicode replacement character
--   U+FFFD.
lenientDecode :: OnDecodeError

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text.
--   
--   <b>NOTE</b>: The replacement character returned by
--   <a>OnDecodeError</a> MUST be within the BMP plane; surrogate code
--   points will automatically be remapped to the replacement char
--   <tt>U+FFFD</tt> (<i>since 0.11.3.0</i>), whereas code points beyond
--   the BMP will throw an <a>error</a> (<i>since 1.2.3.1</i>); For earlier
--   versions of <tt>text</tt> using those unsupported code points would
--   result in undefined behavior.
decodeUtf8With :: OnDecodeError -> ByteString -> Text

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text.
--   
--   If the input contains any invalid UTF-8 data, the relevant exception
--   will be returned, otherwise the decoded text.
decodeUtf8' :: ByteString -> Either UnicodeException Text

-- | <i>O(n)</i> Breaks a <a>Text</a> up into a list of words, delimited by
--   <a>Char</a>s representing white space.
words :: Text -> [Text]

-- | <i>O(n)</i> Breaks a <a>Text</a> up into a list of <a>Text</a>s at
--   newline <a>Char</a>s. The resulting strings do not contain newlines.
lines :: Text -> [Text]

-- | <i>O(n)</i> Joins lines, after appending a terminating newline to
--   each.
unlines :: [Text] -> Text

-- | <i>O(n)</i> Joins words using single space characters.
unwords :: [Text] -> Text

-- | <i>O(c)</i> Convert a strict <a>Text</a> into a lazy <a>Text</a>.
fromStrict :: Text -> Text

-- | Strict version of <a>modifyTVar</a>.
modifyTVar' :: () => TVar a -> (a -> a) -> STM ()

-- | Synonym for <a>throw</a>
throwM :: (MonadThrow m, Exception e) => e -> m a

-- | Same as upstream <a>catch</a>, but will not catch asynchronous
--   exceptions
catch :: (MonadCatch m, Exception e) => m a -> (e -> m a) -> m a

-- | <a>catch</a> specialized to catch all synchronous exception
catchAny :: MonadCatch m => m a -> (SomeException -> m a) -> m a

-- | Flipped version of <a>catchAny</a>
handleAny :: MonadCatch m => (SomeException -> m a) -> m a -> m a

-- | Same as upstream <a>try</a>, but will not catch asynchronous
--   exceptions
try :: (MonadCatch m, Exception e) => m a -> m (Either e a)

-- | <a>try</a> specialized to catch all synchronous exceptions
tryAny :: MonadCatch m => m a -> m (Either SomeException a)

-- | Async safe version of <a>onException</a>
onException :: MonadMask m => m a -> m b -> m a

-- | Async safe version of <a>bracket</a>
bracket :: MonadMask m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Async safe version of <a>bracket_</a>
bracket_ :: MonadMask m => m a -> m b -> m c -> m c

-- | Async safe version of <a>finally</a>
finally :: MonadMask m => m a -> m b -> m a

-- | Async safe version of <a>bracketOnError</a>
bracketOnError :: MonadMask m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | <tt><a>withState</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withState</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withState :: () => (s -> s) -> State s a -> State s a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: () => State s a -> s -> s

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: () => State s a -> s -> a

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: () => State s a -> s -> (a, s)

-- | Runs a <tt>Reader</tt> and extracts the final value from it. (The
--   inverse of <a>reader</a>.)
runReader :: () => Reader r a -> r -> a

-- | The inverse of <a>ExceptT</a>.
runExceptT :: () => ExceptT e m a -> m (Either e a)

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: MonadState s m => (s -> s) -> m ()

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a


-- | This module contains core of Indigo language: IndigoM monad, datatype
--   to represent its state and variables. It also includes some convenient
--   functions to work with state in IndigoM, to provide rebindable syntax.
--   
--   IndigoM monad implements functionality of a symbolic interpreter.
--   During its execution Lorentz code is being generated.
module Indigo.State

-- | IndigoM monad. It's basically
--   <a>https://hackage.haskell.org/package/category-extras-0.53.5/docs/Control-Monad-Indexed-State.html</a>
--   however, this package is not in the used lts and it doesn't compile.
newtype IndigoM inp out a
IndigoM :: (MetaData inp -> GenCode inp out a) -> IndigoM inp out a
[runIndigoM] :: IndigoM inp out a -> MetaData inp -> GenCode inp out a

-- | Bind for rebindable syntax. It's basically like bind for State monad
--   but also compose generated code from _m a_ and _a -&gt; m b_.
(>>=) :: IndigoM inp out a -> (a -> IndigoM out out1 b) -> IndigoM inp out1 b
(=<<) :: (a -> IndigoM out out1 b) -> IndigoM inp out a -> IndigoM inp out1 b

-- | Then for rebindable syntax.
(>>) :: IndigoM inp out a -> IndigoM out out1 b -> IndigoM inp out1 b

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Return for rebindable syntax.
return :: a -> IndigoM inp inp a

-- | Get current MetaData.
iget :: IndigoM inp inp (MetaData inp)

-- | Put new GenCode.
iput :: GenCode inp out a -> IndigoM inp out a

-- | Constraint for <a>StkEl</a>, required for comparison in constraint
--   checking
type TypeValue a = (Typeable a, Typeable (ToT a))

-- | Variable whcih is exposed to a user. It stores number of variable, its
--   phantom type represent type of a variable.
newtype Var a
Var :: Word -> Var a

-- | Stack element of symbolic interpreter. It holds either a variable
--   which refers to this element or just NoRef which indicates that there
--   are no references to this element.
data StkEl a
NoRef :: StkEl a
Ref :: Var a -> StkEl a

-- | Stack of symbolic interpreter.
type StackVars (stk :: [Type]) = Rec StkEl stk

-- | Resulting state of IndigoM.
data GenCode inp out a
GenCode :: ~a -> ~MetaData out -> (inp :-> out) -> (out :-> inp) -> GenCode inp out a

-- | Interpreter output value
[gcOut] :: GenCode inp out a -> ~a

-- | Interpreter meta data.
[gcMeta] :: GenCode inp out a -> ~MetaData out

-- | Generated Lorentz code.
[gcCode] :: GenCode inp out a -> inp :-> out

-- | Clearing Lorentz code.
[gcClear] :: GenCode inp out a -> out :-> inp

-- | Initial state of IndigoM.
data MetaData stk
MetaData :: StackVars stk -> Word -> MetaData stk

-- | Stack of symbolic interpreter.
[mdStack] :: MetaData stk -> StackVars stk

-- | Number of allocated variables.
[mdRefCount] :: MetaData stk -> Word

-- | Create a variable which references to the top of a stack.
makeTopVar :: TypeValue x => IndigoM (x & inp) (x & inp) (Var x)

-- | Push a new stack element with reference to it. Return a variable which
--   references to the just added element.
pushRefMd :: TypeValue x => MetaData stk -> (Var x, MetaData (x & stk))

-- | Push a new stack element without reference to it.
pushNoRefMd :: TypeValue a => MetaData inp -> MetaData (a & inp)

-- | Remove top element of the stack. It's supposed that no variables refer
--   to the top of the stack.
popNoRefMd :: MetaData (a & inp) -> MetaData inp

-- | Given a <a>MetaData</a> and a <a>Peano</a> singleton for a depth, it
--   puts a new <a>Var</a> at that depth (0-indexed) and returns it with
--   the updated <a>MetaData</a>. If there is a <a>Var</a> there already it
--   is used and the <a>MetaData</a> not changed.
withVarAt :: (TypeValue a, a ~ At n inp, RequireLongerThan inp n) => MetaData inp -> Sing n -> (MetaData inp, Var a)

-- | Produces the generated Lorentz code that cleans after itself, leaving
--   the same stack as the input one
cleanGenCode :: GenCode inp out a -> inp :-> inp
type DefaultStack stk = Default (MetaData stk)
instance GHC.Base.Functor (Indigo.State.IndigoM inp out)
instance GHC.Base.Functor (Indigo.State.GenCode inp out)
instance Data.Default.Class.Default (Indigo.State.MetaData '[])
instance (Indigo.State.TypeValue x, Data.Default.Class.Default (Indigo.State.MetaData xs)) => Data.Default.Class.Default (Indigo.State.MetaData (x : xs))
instance Data.Type.Equality.TestEquality Indigo.State.StkEl


-- | This module contains everything related to compilation from Indigo to
--   Lorentz, including plain Indigo code, as well as Indigo contracts.
module Indigo.Compilation

-- | Compile Indigo code to Lorentz.
--   
--   Note: it is necessary to specify the number of parameters (using the
--   first type variable) of the Indigo function. Also, these should be on
--   the top of the input stack in inverse order (see
--   <a>IndigoWithParams</a>).
compileIndigo :: forall n inp out a. (SingI (ToPeano n), Default (MetaData inp), AreIndigoParams (ToPeano n) inp, TypeValue a) => IndigoWithParams (ToPeano n) inp out a -> inp :-> out

-- | A utility type for a contract written in Indigo.
--   
--   Note that is a more restrictive type than what is needed for
--   compilation with <a>compileIndigoContract</a> and it's mainly intended
--   to hide arbitrary outputs and be similar to Lorentz's
--   <a>ContractCode</a>.
type IndigoContract param st = IndigoContract' param st '[param, st, Ops]

-- | Type of a contract that can be compiled to Lorentz with
--   <a>compileIndigoContract</a>.
type IndigoContract' param st out = (HasStorage st, HasSideEffects) => Var param -> IndigoM '[param, st, Ops] out ()

-- | Compile Indigo code to Lorentz contract. Drop elements from the stack
--   to return only [Operation] and Storage.
compileIndigoContract :: forall param st out. (TypeValue param, TypeValue st) => IndigoContract' param st out -> ContractCode param st
type Ops = [Operation]

-- | Allows to get a variable with operations
type HasSideEffects = Given (Var Ops)

-- | Return a variable which refers to a stack cell with operations
operationsVar :: HasSideEffects => Var Ops

-- | Allows to get a variable with storage
type HasStorage st = Given (Var st)

-- | Return a variable which refers to a stack cell with storage
storageVar :: HasStorage st => Var st


-- | Module containing pretty-printing of Indigo contracts
module Indigo.Print

-- | Pretty-print an Indigo contract into Michelson code.
printIndigoContract :: (TypeValue param, TypeValue st, NiceParameterFull param, NiceStorage st) => Bool -> IndigoContract' param st out -> LText

-- | Prints the pretty-printed Michelson code of an Indigo contract to the
--   standard output. This is intended to be easy to use for newcomers.
printAsMichelson :: (TypeValue param, TypeValue st, NiceParameterFull param, NiceStorage st, MonadIO m) => IndigoContract' param st out -> m ()

-- | Saves the pretty-printed Michelson code of an Indigo contract to the
--   given file. This is intended to be easy to use for newcomers.
saveAsMichelson :: (TypeValue param, TypeValue st, NiceParameterFull param, NiceStorage st, MonadIO m, MonadMask m) => IndigoContract' param st out -> FilePath -> m ()


-- | This module contains the logic to lookup <a>Var</a>s in a stack and
--   the actions to manipulate it.
--   
--   For efficiency, actions are implemented using Lorentz macros. To do so
--   every necessary constraint is checked at runtime.
module Indigo.Lookup

-- | Puts a copy of the value for the given <a>Var</a> on top of the stack
varActionGet :: TypeValue a => Var a -> StackVars stk -> stk :-> (a & stk)

-- | Sets the value for the given <a>Var</a> to the topmost value on the
--   stack
varActionSet :: TypeValue a => Var a -> StackVars stk -> (a & stk) :-> stk

-- | Updates the value for the given <a>Var</a> with the topmost value on
--   the stack using the given binary instruction.
varActionUpdate :: (TypeValue a, TypeValue b) => Var a -> StackVars stk -> ('[b, a] :-> '[a]) -> (b : stk) :-> stk

-- | Given a stack with a list of <a>Operation</a>s on its bottom, updates
--   it by appending the <a>Operation</a> on the top.
varActionOperation :: HasSideEffects => StackVars stk -> (Operation : stk) :-> stk
rtake :: Sing n -> Rec any s -> Rec any (Take n s)
rdrop :: Sing n -> Rec any s -> Rec any (Drop n s)
instance Data.Type.Equality.TestEquality Indigo.Lookup.TVal


-- | Expressions supported in Indigo language and their compilation to
--   Lorentz code.
--   
--   This module contains only basic building blocks that can be used to
--   implement anything else. Other modules provide high level language
--   constructions and standard functions.
module Indigo.Expr
data Expr a
[C] :: (NiceConstant a, Typeable a) => a -> Expr a
[V] :: TypeValue a => Var a -> Expr a
[Cast] :: (IsExpr ex a, KnownValue a, Typeable a) => ex -> Expr a
[Add] :: (AreExprs ex1 ex2 n m, ArithOpHs Add n m, TypeValue (ArithResHs Add n m)) => ex1 -> ex2 -> Expr (ArithResHs Add n m)
[Sub] :: (AreExprs ex1 ex2 n m, ArithOpHs Sub n m, TypeValue (ArithResHs Sub n m)) => ex1 -> ex2 -> Expr (ArithResHs Sub n m)
[Mul] :: (AreExprs ex1 ex2 n m, ArithOpHs Mul n m, TypeValue (ArithResHs Mul n m)) => ex1 -> ex2 -> Expr (ArithResHs Mul n m)
[Div] :: (AreExprs ex1 ex2 n m, EDivOpHs n m, TypeValue (EDivOpResHs n m)) => ex1 -> ex2 -> Expr (EDivOpResHs n m)
[Mod] :: (AreExprs ex1 ex2 n m, EDivOpHs n m, TypeValue (EModOpResHs n m)) => ex1 -> ex2 -> Expr (EModOpResHs n m)
[Abs] :: (IsExpr ex n, UnaryArithOpHs Abs n, TypeValue (UnaryArithResHs Abs n)) => ex -> Expr (UnaryArithResHs Abs n)
[Neg] :: (IsExpr ex n, UnaryArithOpHs Neg n, TypeValue (UnaryArithResHs Neg n)) => ex -> Expr (UnaryArithResHs Neg n)
[Lsl] :: (AreExprs ex1 ex2 n m, ArithOpHs Lsl n m, TypeValue (ArithResHs Lsl n m)) => ex1 -> ex2 -> Expr (ArithResHs Lsl n m)
[Lsr] :: (AreExprs ex1 ex2 n m, ArithOpHs Lsr n m, TypeValue (ArithResHs Lsr n m)) => ex1 -> ex2 -> Expr (ArithResHs Lsr n m)
[Eq'] :: (AreExprs ex1 ex2 n n, NiceComparable n) => ex1 -> ex2 -> Expr Bool
[Neq] :: (AreExprs ex1 ex2 n n, NiceComparable n) => ex1 -> ex2 -> Expr Bool
[Le] :: (AreExprs ex1 ex2 n n, NiceComparable n) => ex1 -> ex2 -> Expr Bool
[Lt] :: (AreExprs ex1 ex2 n n, NiceComparable n) => ex1 -> ex2 -> Expr Bool
[Ge] :: (AreExprs ex1 ex2 n n, NiceComparable n) => ex1 -> ex2 -> Expr Bool
[Gt] :: (AreExprs ex1 ex2 n n, NiceComparable n) => ex1 -> ex2 -> Expr Bool
[Or] :: (AreExprs ex1 ex2 n m, ArithOpHs Or n m, TypeValue (ArithResHs Or n m)) => ex1 -> ex2 -> Expr (ArithResHs Or n m)
[Xor] :: (AreExprs ex1 ex2 n m, ArithOpHs Xor n m, TypeValue (ArithResHs Xor n m)) => ex1 -> ex2 -> Expr (ArithResHs Xor n m)
[And] :: (AreExprs ex1 ex2 n m, ArithOpHs And n m, TypeValue (ArithResHs And n m)) => ex1 -> ex2 -> Expr (ArithResHs And n m)
[Not] :: (IsExpr op n, UnaryArithOpHs Not n, TypeValue (UnaryArithResHs Not n)) => op -> Expr (UnaryArithResHs Not n)
[Int'] :: IsExpr ex Natural => ex -> Expr Integer
[IsNat] :: IsExpr ex Integer => ex -> Expr (Maybe Natural)
[Fst] :: (IsExpr op (n, m), TypeValue n) => op -> Expr n
[Snd] :: (IsExpr op (n, m), TypeValue m) => op -> Expr m
[Pair] :: (AreExprs ex1 ex2 n m, TypeValue (n, m)) => ex1 -> ex2 -> Expr (n, m)
[Some] :: (IsExpr ex t, TypeValue (Maybe t)) => ex -> Expr (Maybe t)
[None] :: (KnownValue t, TypeValue t) => Expr (Maybe t)
[Mem] :: (MemOpHs c, IsExpr exc c, IsExpr exck (MemOpKeyHs c)) => exck -> exc -> Expr Bool
[StToField] :: (StoreHasField store fname ftype, TypeValue ftype, IsExpr exStore store) => Label fname -> exStore -> Expr ftype
[ULookup] :: (HasUStore name key value store, IsExpr exKey key, IsExpr exStore (UStore store), TypeValue value) => Label name -> exKey -> exStore -> Expr (Maybe value)
[UInsertNew] :: (HasUStore name key value store, IsError err, IsExpr exKey key, IsExpr exVal value, IsExpr exStore (UStore store), TypeValue (UStore store)) => Label name -> err -> exKey -> exVal -> exStore -> Expr (UStore store)
[UInsert] :: (HasUStore name key value store, IsExpr exKey key, IsExpr exVal value, IsExpr exStore (UStore store), TypeValue (UStore store)) => Label name -> exKey -> exVal -> exStore -> Expr (UStore store)
[ToField] :: (InstrGetFieldC dt name, IsExpr exDt dt, TypeValue (GetFieldType dt name)) => exDt -> Label name -> Expr (GetFieldType dt name)
[SetField] :: (InstrSetFieldC dt name, IsExpr exDt dt, IsExpr exFld (GetFieldType dt name), TypeValue dt) => exDt -> Label name -> exFld -> Expr dt
[Name] :: (IsExpr ex t, TypeValue (name :! t)) => Label name -> ex -> Expr (name :! t)
[UnName] :: (IsExpr ex (name :! t), TypeValue t) => Label name -> ex -> Expr t
[Construct] :: (InstrConstructC dt, RMap (ConstructorFieldTypes dt), TypeValue dt) => Rec Expr (ConstructorFieldTypes dt) -> Expr dt

-- | Construct a record from a tuple of named indigo parameters. For
--   instance: ``` constructT @("sender" :: Address, "amount" :: Natural) (
--   (sender :: Expr Address) !~ #sender , (constExpr 10 :: Expr Natural)
--   !~ #amount ) ```
[ConstructT] :: (InstrConstructC dt, TypeValue dt, RMap (ConstructorFieldTypes dt), fields ~ Rec Expr (ConstructorFieldTypes dt), RecFromTuple fields) => IsoRecTuple fields -> Expr dt
[SetContains] :: (IsExpr exKey key, IsExpr exSet (Set key), IsComparable key) => exKey -> exSet -> Expr Bool
[SetInsert] :: (IsExpr exKey key, IsExpr exSet (Set key), IsComparable key, TypeValue (Set key)) => exKey -> exSet -> Expr (Set key)
[SetRemove] :: (IsExpr exKey key, IsExpr exSet (Set key), IsComparable key, TypeValue (Set key)) => exKey -> exSet -> Expr (Set key)
[SetSize] :: IsExpr exSet (Set key) => exSet -> Expr Natural
[MapGet] :: (GetOpHs c, TypeValue (Maybe (GetOpValHs c)), IsExpr exKey (GetOpKeyHs c), IsExpr exMap c) => exKey -> exMap -> Expr (Maybe (GetOpValHs c))
[MapUpdate] :: (UpdOpHs c, TypeValue c, IsExpr exKey (UpdOpKeyHs c), IsExpr exVal (UpdOpParamsHs c), IsExpr exMap c) => exKey -> exVal -> exMap -> Expr c
[MapSize] :: (SizeOpHs c, IsExpr exMap c) => exMap -> Expr Natural
[BigMapGet] :: (IsExpr exKey key, IsExpr exBigMap (BigMap key value), IsComparable key, TypeValue (Maybe value)) => exKey -> exBigMap -> Expr (Maybe value)
[BigMapUpdate] :: (IsExpr exKey key, IsExpr exValue (Maybe value), IsExpr exBigMap (BigMap key value), IsComparable key, TypeValue (BigMap key value)) => exKey -> exValue -> exBigMap -> Expr (BigMap key value)
[EmptyBigMap] :: (KnownCValue key, KnownValue value, TypeValue (BigMap key value)) => Expr (BigMap key value)
[Pack] :: (IsExpr ex a, NicePackedValue a) => ex -> Expr ByteString
[Unpack] :: (NiceUnpackedValue a, Typeable a, IsExpr bsExpr ByteString) => bsExpr -> Expr (Maybe a)
[Cons] :: (IsExpr ex1 a, IsExpr ex2 (List a), TypeValue a) => ex1 -> ex2 -> Expr (List a)
[Nil] :: (KnownValue a, TypeValue a) => Expr (List a)
[Concat] :: (IsExpr ex c, ConcatOpHs c, TypeValue c) => ex -> ex -> Expr c
[Concat'] :: (IsExpr ex (List c), ConcatOpHs c, TypeValue c) => ex -> Expr c
[Slice] :: (IsExpr ex c, SliceOpHs c, TypeValue c, IsExpr an Natural, IsExpr bn Natural) => an -> bn -> ex -> Expr (Maybe c)
[Contract] :: (NiceParameterFull p, NoExplicitDefaultEntryPoint p, ToTAddress p addr, ToT addr ~ ToT Address, IsExpr exAddr addr) => exAddr -> Expr (Maybe (ContractRef p))
[Self] :: (NiceParameterFull p, NoExplicitDefaultEntryPoint p) => Expr (ContractRef p)
[ContractAddress] :: IsExpr exc (ContractRef p) => exc -> Expr Address
[ContractCallingUnsafe] :: (NiceParameter arg, Typeable arg, IsExpr exAddr Address) => EpName -> exAddr -> Expr (Maybe (ContractRef arg))
[RunFutureContract] :: (NiceParameter p, Typeable p, IsExpr conExpr (FutureContract p)) => conExpr -> Expr (Maybe (ContractRef p))
[ImplicitAccount] :: IsExpr exkh KeyHash => exkh -> Expr (ContractRef ())
[ConvertEpAddressToContract] :: (NiceParameter p, Typeable p, IsExpr epExpr EpAddress) => epExpr -> Expr (Maybe (ContractRef p))
[CheckSignature] :: (IsExpr pkExpr PublicKey, IsExpr sigExpr Signature, IsExpr hashExpr ByteString) => pkExpr -> sigExpr -> hashExpr -> Expr Bool
[Sha256] :: IsExpr hashExpr ByteString => hashExpr -> Expr ByteString
[Sha512] :: IsExpr hashExpr ByteString => hashExpr -> Expr ByteString
[Blake2b] :: IsExpr hashExpr ByteString => hashExpr -> Expr ByteString
[HashKey] :: IsExpr keyExpr PublicKey => keyExpr -> Expr KeyHash
[ChainId] :: Expr ChainId
[Now] :: Expr Timestamp
[Amount] :: Expr Mutez
[Balance] :: Expr Mutez
[Sender] :: Expr Address
type IsExpr op n = (ToExpr op, ExprType op ~ n)
type AreExprs ex1 ex2 n m = (IsExpr ex1 n, IsExpr ex2 m)
class ToExpr' (Decide x) x => ToExpr x
type ExprType a = ExprType' (Decide a) a
type (:~>) op n = IsExpr op n
toExpr :: forall a. ToExpr a => a -> Expr (ExprType a)
compileExpr :: forall a inp. Expr a -> IndigoM inp (a & inp) ()
compileToExpr :: ToExpr a => a -> IndigoM inp (ExprType a & inp) ()
nullaryOp :: TypeValue res => (inp :-> (res : inp)) -> IndigoM inp (res : inp) ()
unaryOp :: forall n ex res inp. (IsExpr ex n, TypeValue res) => ex -> ((n & inp) :-> (res & inp)) -> IndigoM inp (res & inp) ()
binaryOp :: forall n m ex1 ex2 res inp. (AreExprs ex1 ex2 n m, TypeValue res) => ex1 -> ex2 -> ((n & (m & inp)) :-> (res & inp)) -> IndigoM inp (res & inp) ()
ternaryOp :: forall n m l ex1 ex2 ex3 res inp. (AreExprs ex1 ex2 n m, IsExpr ex3 l, TypeValue res) => ex1 -> ex2 -> ex3 -> ((n & (m & (l & inp))) :-> (res & inp)) -> IndigoM inp (res & inp) ()
nullaryOpFlat :: (inp :-> inp) -> IndigoM inp inp ()
unaryOpFlat :: forall n ex inp. IsExpr ex n => ex -> ((n & inp) :-> inp) -> IndigoM inp inp ()
binaryOpFlat :: forall n m ex1 ex2 inp. AreExprs ex1 ex2 n m => ex1 -> ex2 -> ((n & (m & inp)) :-> inp) -> IndigoM inp inp ()
ternaryOpFlat :: forall n m l ex1 ex2 ex3 inp. (AreExprs ex1 ex2 n m, IsExpr ex3 l) => ex1 -> ex2 -> ex3 -> ((n & (m & (l & inp))) :-> inp) -> IndigoM inp inp ()

-- | Create an expression holding a constant.
constExpr :: (Typeable a, NiceConstant a) => a -> Expr a

-- | Create an expression holding a variable.
varExpr :: TypeValue a => Var a -> Expr a
cast :: (ex :~> a, KnownValue a, Typeable a) => ex -> Expr a
mem :: (MemOpHs c, IsExpr exc c, IsExpr exck (MemOpKeyHs c)) => exck -> exc -> Expr Bool
(+.) :: (AreExprs ex1 ex2 n m, ArithOpHs Add n m, TypeValue (ArithResHs Add n m)) => ex1 -> ex2 -> Expr (ArithResHs Add n m)
infixl 6 +.
(-.) :: (AreExprs ex1 ex2 n m, ArithOpHs Sub n m, TypeValue (ArithResHs Sub n m)) => ex1 -> ex2 -> Expr (ArithResHs Sub n m)
infixl 6 -.
(*.) :: (AreExprs ex1 ex2 n m, ArithOpHs Mul n m, TypeValue (ArithResHs Mul n m)) => ex1 -> ex2 -> Expr (ArithResHs Mul n m)
infixl 7 *.
(/.) :: (AreExprs ex1 ex2 n m, EDivOpHs n m, TypeValue (EDivOpResHs n m)) => ex1 -> ex2 -> Expr (EDivOpResHs n m)
infixl 7 /.
(%.) :: (AreExprs ex1 ex2 n m, EDivOpHs n m, TypeValue (EModOpResHs n m)) => ex1 -> ex2 -> Expr (EModOpResHs n m)
infixl 7 %.
neg :: (ex :~> n, UnaryArithOpHs Neg n, TypeValue (UnaryArithResHs Neg n)) => ex -> Expr (UnaryArithResHs Neg n)
abs :: (ex :~> n, UnaryArithOpHs Abs n, TypeValue (UnaryArithResHs Abs n)) => ex -> Expr (UnaryArithResHs Abs n)
(==.) :: (NiceComparable n, AreExprs c c1 n n) => c -> c1 -> Expr Bool
infix 4 ==.
(/=.) :: (NiceComparable n, AreExprs c c1 n n) => c -> c1 -> Expr Bool
infix 4 /=.
(<=.) :: (NiceComparable n, AreExprs c c1 n n) => c -> c1 -> Expr Bool
infix 4 <=.
(>=.) :: (NiceComparable n, AreExprs c c1 n n) => c -> c1 -> Expr Bool
infix 4 >=.
(<.) :: (NiceComparable n, AreExprs c c1 n n) => c -> c1 -> Expr Bool
infix 4 <.
(>.) :: (NiceComparable n, AreExprs c c1 n n) => c -> c1 -> Expr Bool
infix 4 >.
isNat :: ex :~> Integer => ex -> Expr (Maybe Natural)
int :: ex :~> Natural => ex -> Expr Integer
(<<.) :: (AreExprs ex1 ex2 n m, ArithOpHs Lsl n m, TypeValue (ArithResHs Lsl n m)) => ex1 -> ex2 -> Expr (ArithResHs Lsl n m)
infixl 8 <<.
(>>.) :: (AreExprs ex1 ex2 n m, ArithOpHs Lsr n m, TypeValue (ArithResHs Lsr n m)) => ex1 -> ex2 -> Expr (ArithResHs Lsr n m)
infixl 8 >>.
(&&.) :: (AreExprs ex1 ex2 n m, ArithOpHs And n m, TypeValue (ArithResHs And n m)) => ex1 -> ex2 -> Expr (ArithResHs And n m)
infixr 3 &&.
(||.) :: (AreExprs ex1 ex2 n m, ArithOpHs Or n m, TypeValue (ArithResHs Or n m)) => ex1 -> ex2 -> Expr (ArithResHs Or n m)
infixr 2 ||.
not :: (op :~> n, UnaryArithOpHs Not n, TypeValue (UnaryArithResHs Not n)) => op -> Expr (UnaryArithResHs Not n)
xor :: (AreExprs ex1 ex2 n m, ArithOpHs Xor n m, TypeValue (ArithResHs Xor n m)) => ex1 -> ex2 -> Expr (ArithResHs Xor n m)
pack :: (IsExpr ex a, NicePackedValue a) => ex -> Expr ByteString
unpack :: (NiceUnpackedValue a, Typeable a, bsExpr :~> ByteString) => bsExpr -> Expr (Maybe a)
pair :: (AreExprs ex1 ex2 n m, TypeValue (n, m)) => ex1 -> ex2 -> Expr (n, m)
fst :: (op :~> (n, m), TypeValue n) => op -> Expr n
snd :: (op :~> (n, m), TypeValue m) => op -> Expr m
some :: (ex :~> t, TypeValue (Maybe t)) => ex -> Expr (Maybe t)
none :: (TypeValue t, KnownValue t) => Expr (Maybe t)
slice :: (ex :~> c, an :~> Natural, bn :~> Natural, SliceOpHs c, TypeValue c) => (an, bn) -> ex -> Expr (Maybe c)
concat :: (IsExpr ex c, ConcatOpHs c, TypeValue c) => ex -> ex -> Expr c
(<>.) :: (IsExpr ex c, ConcatOpHs c, TypeValue c) => ex -> ex -> Expr c
infixr 6 <>.
(.:) :: (ex1 :~> a, ex2 :~> List a, TypeValue a) => ex1 -> ex2 -> Expr (List a)
infixr 5 .:
concat' :: (IsExpr ex (List c), ConcatOpHs c, TypeValue c) => ex -> Expr c
nil :: (KnownValue a, TypeValue a) => Expr (List a)
(%@) :: (HasUStore name key value store, TypeValue value, exKey :~> key, exStore :~> UStore store) => exStore -> (Label name, exKey) -> Expr (Maybe value)
infixr 8 %@
(%~~) :: (HasUStore name key value store, IsError err, exKey :~> key, exVal :~> value, exStore :~> UStore store, TypeValue (UStore store)) => exStore -> (Label name, err, exKey, exVal) -> Expr (UStore store)
infixr 8 %~~
(%~) :: (HasUStore name key value store, TypeValue (UStore store), exKey :~> key, exVal :~> value, exStore :~> UStore store) => exStore -> (Label name, exKey, exVal) -> Expr (UStore store)
infixr 8 %~
(%!) :: (StoreHasField store fname ftype, exStore :~> store, TypeValue ftype) => exStore -> Label fname -> Expr ftype
infixr 8 %!
(~.) :: (InstrSetFieldC dt name, IsExpr exDt dt, exFld :~> GetFieldType dt name, TypeValue dt) => exDt -> (Label name, exFld) -> Expr dt
infixl 8 ~.
(!.) :: (InstrGetFieldC dt name, exDt :~> dt, TypeValue (GetFieldType dt name)) => exDt -> Label name -> Expr (GetFieldType dt name)
infixl 8 !.
(!~) :: (ex :~> t, TypeValue (name :! t)) => ex -> Label name -> Expr (name :! t)
construct :: (InstrConstructC dt, RMap (ConstructorFieldTypes dt), TypeValue dt) => Rec Expr (ConstructorFieldTypes dt) -> Expr dt
constructT :: (InstrConstructC dt, TypeValue dt, RMap (ConstructorFieldTypes dt), fields ~ Rec Expr (ConstructorFieldTypes dt), RecFromTuple fields) => IsoRecTuple fields -> Expr dt
(^?) :: (GetOpHs c, TypeValue (Maybe (GetOpValHs c)), exKey :~> GetOpKeyHs c, exMap :~> c) => exMap -> exKey -> Expr (Maybe (GetOpValHs c))
infixl 8 ^?
(^~) :: (UpdOpHs c, TypeValue c, exKey :~> UpdOpKeyHs c, exVal :~> UpdOpParamsHs c, exMap :~> c) => exMap -> (exKey, exVal) -> Expr c
infixl 8 ^~
msize :: (SizeOpHs c, exMap :~> c) => exMap -> Expr Natural
(&?) :: (exKey :~> key, exBigMap :~> BigMap key value, IsComparable key, TypeValue (Maybe value)) => exBigMap -> exKey -> Expr (Maybe value)
infixl 8 &?
(&~) :: (exKey :~> key, exValue :~> value, exBigMap :~> BigMap key value, IsComparable key, TypeValue value, TypeValue (BigMap key value)) => exBigMap -> (exKey, exValue) -> Expr (BigMap key value)
infixl 8 &~
(&?~) :: (exKey :~> key, exValue :~> Maybe value, exBigMap :~> BigMap key value, IsComparable key, TypeValue (BigMap key value)) => exBigMap -> (exKey, exValue) -> Expr (BigMap key value)
infixl 8 &?~
(&-) :: (TypeValue value, KnownValue value, exKey :~> key, exBigMap :~> BigMap key value, IsComparable key, TypeValue (BigMap key value)) => exBigMap -> exKey -> Expr (BigMap key value)
infixl 8 &-
emptyBigMap :: (KnownCValue key, KnownValue value, TypeValue (BigMap key value)) => Expr (BigMap key value)
(#?) :: (exKey :~> key, exSet :~> Set key, IsComparable key) => exSet -> exKey -> Expr Bool
infixr 8 #?
(#~) :: (exKey :~> key, exSet :~> Set key, IsComparable key, TypeValue (Set key)) => exSet -> exKey -> Expr (Set key)
infixr 8 #~
(#-) :: (exKey :~> key, exSet :~> Set key, IsComparable key, TypeValue (Set key)) => exSet -> exKey -> Expr (Set key)
infixr 8 #-
ssize :: exSet :~> Set key => exSet -> Expr Natural
contract :: (NiceParameterFull p, NoExplicitDefaultEntryPoint p, ToTAddress p addr, ToT addr ~ ToT Address, exAddr :~> addr) => exAddr -> Expr (Maybe (ContractRef p))
self :: (NiceParameterFull p, NoExplicitDefaultEntryPoint p) => Expr (ContractRef p)
contractAddress :: exc :~> ContractRef p => exc -> Expr Address
contractCallingUnsafe :: (NiceParameter arg, Typeable arg, exAddr :~> Address) => EpName -> exAddr -> Expr (Maybe (ContractRef arg))
runFutureContract :: (NiceParameter p, Typeable p, conExpr :~> FutureContract p) => conExpr -> Expr (Maybe (ContractRef p))
implicitAccount :: exkh :~> KeyHash => exkh -> Expr (ContractRef ())
convertEpAddressToContract :: (NiceParameter p, Typeable p, epExpr :~> EpAddress) => epExpr -> Expr (Maybe (ContractRef p))
now :: Expr Timestamp
amount :: Expr Mutez
sender :: Expr Address
blake2b :: hashExpr :~> ByteString => hashExpr -> Expr ByteString
sha256 :: hashExpr :~> ByteString => hashExpr -> Expr ByteString
sha512 :: hashExpr :~> ByteString => hashExpr -> Expr ByteString
hashKey :: keyExpr :~> PublicKey => keyExpr -> Expr KeyHash
chainId :: Expr ChainId
balance :: Expr Mutez
checkSignature :: (pkExpr :~> PublicKey, sigExpr :~> Signature, hashExpr :~> ByteString) => pkExpr -> sigExpr -> hashExpr -> Expr Bool
fromLabel :: IsLabel x a => a
instance Indigo.Expr.ToExpr' (Indigo.Expr.Decide x) x => Indigo.Expr.ToExpr x
instance Indigo.State.TypeValue a => Indigo.Expr.ToExpr' 'Indigo.Expr.VarD (Indigo.State.Var a)
instance (Lorentz.Constraints.Scopes.NiceConstant a, Data.Typeable.Internal.Typeable a) => Indigo.Expr.ToExpr' 'Indigo.Expr.ValD a
instance Indigo.Expr.ToExpr' 'Indigo.Expr.ExprD (Indigo.Expr.Expr a)


-- | Machinery to provide ability to return values from Indigo statements.
module Indigo.Language.Scope
type ScopeCodeGen ret = ScopeCodeGen' (ClassifyBranchReturn ret) ret

-- | Type class which unions all related management of computations in a
--   scope, like in 'if' branch, in 'case' body, etc. Particularly, it
--   takes care of the computation of expressions returning from a scope to
--   leave the scope safely. Basically, this type class encapsulates
--   generation of Lorentz code which looks like: branch_code # we get some
--   arbitrary type of a stack here, lets call it <tt>xs</tt>
--   compute_returning_expressions # we get type of stack [e1, e2, ... ek]
--   ++ xs cleanup_xs_to_inp we get [e1, e2, e3, ..., ek] ++ inp
class ScopeCodeGen' (retKind :: BranchRetKind) (ret :: Type) where {
    
    -- | Type family reflecting the output stack of the resulting statement.
    type family ScopeOutStack' retKind ret (inp :: [Type]) :: [Type];
    
    -- | Type family reflecting the output value of the resulting statement.
    type family ScopeRetVars' retKind ret :: Type;
    
    -- | Tuple looking like `(Expr x, Expr y, ..)`, which corresponds to
    --   expressions returning from the scope. <a>ScopeRetVars'</a> and
    --   <a>ScopeRetExprs'</a> are twin types because the former just adds
    --   <a>Var</a> over each expression from the later one.
    type family ScopeRetExprs' retKind ret :: Type;
}

-- | Produces an Indigo computation, which puts on a stack evaluated
--   returnen expressions from the leaving scope.
compileScopeReturn' :: ScopeCodeGen' retKind ret => ret -> IndigoM xs (ScopeOutStack' retKind ret xs) ()

-- | Drop unused cells of a stack from the leaving scope, which are after
--   evaluated expressions.
liftClear' :: ScopeCodeGen' retKind ret => (xs :-> inp) -> ScopeOutStack' retKind ret xs :-> ScopeOutStack' retKind ret inp

-- | Push a variables in MetaData, which refer to generated expressions,
--   and generate <a>gcClear</a> for the whole statement
finalizeStatement' :: ScopeCodeGen' retKind ret => MetaData inp -> (inp :-> ScopeOutStack' retKind ret inp) -> GenCode inp (ScopeOutStack' retKind ret inp) (ScopeRetVars' retKind ret)
type ScopeOutStack ret inp = ScopeOutStack' (ClassifyBranchReturn ret) ret inp
type ScopeRetVars ret = ScopeRetVars' (ClassifyBranchReturn ret) ret
type ScopeRetExprs ret = ScopeRetExprs' (ClassifyBranchReturn ret) ret

-- | This type family returns promoted value of type BranchRetKind or cause
--   a compilation errors, if tuple with too many elements is used.
type family ClassifyBranchReturn (ret :: Type)

-- | Concatenate a scope code, generation of returning expressions, and
--   clean up of redundant cells from a stack
compileScope :: forall ret inp xs. ScopeCodeGen ret => GenCode inp xs ret -> inp :-> ScopeOutStack ret inp

-- | Specify type of <tt>finalizeStatement'</tt>
finalizeStatement :: forall ret inp. ScopeCodeGen ret => MetaData inp -> (inp :-> ScopeOutStack ret inp) -> GenCode inp (ScopeOutStack ret inp) (ScopeRetVars ret)
instance Indigo.Language.Scope.TypeValueExpr single => Indigo.Language.Scope.ScopeCodeGen' 'Indigo.Language.Scope.SingleVal single
instance (Indigo.Language.Scope.TypeValueExpr x, Indigo.Language.Scope.TypeValueExpr y) => Indigo.Language.Scope.ScopeCodeGen' 'Indigo.Language.Scope.Tuple (x, y)
instance (Indigo.Language.Scope.TypeValueExpr x, Indigo.Language.Scope.TypeValueExpr y, Indigo.Language.Scope.TypeValueExpr z) => Indigo.Language.Scope.ScopeCodeGen' 'Indigo.Language.Scope.Tuple (x, y, z)
instance Indigo.Language.Scope.ScopeCodeGen' 'Indigo.Language.Scope.Unit ()


-- | Conditional statements of Indigo language.
module Indigo.Language.Conditional

-- | If statement. It's supposed that all created variables inside branches
--   will be released after execution leaves a scope where they were
--   created.
if_ :: forall inp xs ys a b exc. (IfConstraint a b inp, exc :~> Bool) => exc -> IndigoM inp xs a -> IndigoM inp ys b -> IndigoM inp (ScopeOutStack a inp) (ScopeRetVars a)

-- | If which works like case for Maybe.
ifJust :: forall inp xs ys x a b exa. (IfConstraint a b inp, TypeValue x, exa :~> Maybe x) => exa -> (Var x -> IndigoM (x & inp) xs a) -> IndigoM inp ys b -> IndigoM inp (ScopeOutStack a inp) (ScopeRetVars a)

-- | Run the instruction when condition is met, do nothing otherwise.
when :: exc :~> Bool => exc -> IndigoM inp out () -> IndigoM inp inp ()

-- | Run the instruction when the given expression returns <a>Just</a>
--   value or do nothing otherwise.
whenJust :: forall inp xs x exa. (TypeValue x, exa :~> Maybe x) => exa -> (Var x -> IndigoM (x & inp) xs ()) -> IndigoM inp inp ()

-- | Run the instruction when the given expression returns <a>Nothing</a>
--   or do nothing otherwise.
whenNothing :: forall inp x ys exa. (TypeValue x, exa :~> Maybe x) => exa -> IndigoM inp ys () -> IndigoM inp inp ()
type IfConstraint a b inp = (ScopeCodeGen a, ScopeCodeGen b, CompareBranchesResults (ScopeRetExprs a) (ScopeRetExprs b), ScopeOutStack a inp ~ ScopeOutStack b inp)


-- | Error related statements of Indigo language.
module Indigo.Language.Error
failWith :: (KnownValue a, IsExpr ex a) => ex -> IndigoM s t r
failUsing_ :: IsError x => x -> IndigoM s t r
failCustom :: forall tag err ex s t r. (err ~ ErrorArg tag, CustomErrorHasDoc tag, NiceConstant err, IsExpr ex err) => Label tag -> ex -> IndigoM s t r
failCustom_ :: forall tag s t r notVoidErrorMsg. (RequireNoArgError tag notVoidErrorMsg, CustomErrorHasDoc tag) => Label tag -> IndigoM s t r
failUnexpected_ :: MText -> IndigoM s t r
assert :: forall s x ex. (IsError x, IsExpr ex Bool) => x -> ex -> IndigoM s s ()


-- | High level statements of Indigo language.
module Indigo.Language.Case

-- | An alias for /-&gt; to use when the body is a lambda so that the whole
--   thing won't have multiple arrows.
(#=) :: CaseArrow name body clause => Label name -> body -> clause

-- | Use this instead of /-&gt;. This operator is like /-&gt; but wrap a
--   body into IndigoAnyOut, which is needed for two reasons: to allow
--   having any output stack and to allow to return not exactly the same
--   values.
(//->) :: (CaseArrow name (Var x -> IndigoAnyOut x inp ret) (IndigoCaseClauseL inp ret ( 'CaseClauseParam ctor field)), ScopeCodeGen retBr, ret ~ ScopeRetExprs retBr, ScopeOutStack ret inp ~ ScopeOutStack retBr inp) => Label name -> (Var x -> IndigoM (x : inp) xs retBr) -> IndigoCaseClauseL inp ret ( 'CaseClauseParam ctor field)
infixr 0 //->

-- | A case statement for indigo. See examples for a sample usage.
case_ :: forall dt guard inp ret clauses. CaseCommon dt guard inp ret clauses => guard -> clauses -> IndigoM inp (ScopeOutStack ret inp) (ScopeRetVars ret)

-- | <a>case_</a> for tuples.
caseT :: forall dt guard inp ret clauses. (CaseCommon dt guard inp ret clauses, RecFromTuple clauses) => guard -> IsoRecTuple clauses -> IndigoM inp (ScopeOutStack ret inp) (ScopeRetVars ret)

-- | <a>entryCase_</a> for tuples.
entryCase :: forall dt entryPointKind guard inp ret clauses. (CaseCommon dt guard inp ret clauses, RecFromTuple clauses, DocumentEntryPoints entryPointKind dt) => Proxy entryPointKind -> guard -> IsoRecTuple clauses -> IndigoM inp (ScopeOutStack ret inp) (ScopeRetVars ret)

-- | <a>case_</a> for pattern-matching on parameter.
entryCase_ :: forall dt entryPointKind guard inp ret clauses. (CaseCommon dt guard inp ret clauses, DocumentEntryPoints entryPointKind dt) => Proxy entryPointKind -> guard -> clauses -> IndigoM inp (ScopeOutStack ret inp) (ScopeRetVars ret)

-- | <a>entryCase</a> for contracts with flat parameter.
entryCaseSimple :: forall cp guard inp ret clauses. (CaseCommon cp guard inp ret clauses, RecFromTuple clauses, DocumentEntryPoints PlainEntryPointsKind cp, NiceParameterFull cp, RequireFlatParamEps cp) => guard -> IsoRecTuple clauses -> IndigoM inp (ScopeOutStack ret inp) (ScopeRetVars ret)
instance (name Data.Type.Equality.~ GHC.TypeLits.AppendSymbol "c" ctor, Michelson.Typed.Haskell.Instr.Sum.AppendCtorField field inp Data.Type.Equality.~ (Michelson.Typed.Haskell.Instr.Sum.ExtractCtorField field Lorentz.Base.& inp), Indigo.State.TypeValue (Michelson.Typed.Haskell.Instr.Sum.ExtractCtorField field), x Data.Type.Equality.~ Michelson.Typed.Haskell.Instr.Sum.ExtractCtorField field) => Lorentz.ADT.CaseArrow name (Indigo.State.Var x -> Indigo.Language.Case.IndigoAnyOut x inp ret) (Indigo.Language.Case.IndigoCaseClauseL inp ret ('Michelson.Typed.Haskell.Instr.Sum.CaseClauseParam ctor field))


-- | Generation of functions that convert Lorentz code to Indigo
module Indigo.FromLorentz

-- | Generates all of the <a>fromLorentzFunN</a> (both with and without
--   return value) from 1 to the given <tt>n</tt>
genFromLorentzFunN :: Int -> Q [Dec]

-- | Generates a function that converts a Lorentz expression to an Indigo
--   one. The first parameter is the number of elements that the Lorentz
--   code consumes from the stack, as well as the number of Indigo
--   <a>IsExpr</a> values. The second parameter is to establish if there is
--   a return value or not, as well as the name of the function. Examples:
--   - `fromLorentzFunN 1 False` produces: `fromLorentzFun1Void :: IsExpr
--   ex a =&gt; a &amp; s :-&gt; s -&gt; ex -&gt; IndigoM s s ()` -
--   `fromLorentzFunN 2 True` produces: ``` fromLorentzFun2 :: (TypeValue
--   ret, IsExpr ex1 a, IsExpr ex2 b) =&gt; a &amp; b &amp; s :-&gt; ret
--   &amp; s -&gt; ex1 -&gt; ex2 -&gt; IndigoM s (ret &amp; s) (Var ret)
--   ```
fromLorentzFunN :: Int -> Bool -> Q [Dec]


-- | High level statements of Indigo language.
module Indigo.Language

-- | Create a new variable with passed expression as an initial value.
newVar :: (IsExpr ex x, TypeValue x) => ex -> IndigoM inp (x & inp) (Var x)

-- | Set to variable new value.
setVar :: (IsExpr ex x, TypeValue x) => Var x -> ex -> IndigoM inp inp ()

-- | Call binary operator with constant argument to update variable
--   in-place.
updateVar :: (IsExpr ey y, TypeValue x, TypeValue y) => ([y, x] :-> '[x]) -> Var x -> ey -> IndigoM inp inp ()
setField_ :: forall dt name inp ex. (InstrSetFieldC dt name, TypeValue dt, IsExpr ex (GetFieldType dt name), TypeValue (GetFieldType dt name)) => Var dt -> Label name -> ex -> IndigoM inp inp ()

-- | For statements to iterate over container.
forEach :: forall a e inp xs. (IterOpHs a, TypeValue (IterOpElHs a), e :~> a) => e -> (Var (IterOpElHs a) -> IndigoM (IterOpElHs a & inp) xs ()) -> IndigoM inp inp ()

-- | While statement. The same rule about releasing.
while :: forall inp xs. Expr Bool -> IndigoM inp xs () -> IndigoM inp inp ()
(+=) :: (IsExpr ex1 n, ArithOpHs Add n m, ArithResHs Add n m ~ m, TypeValue m, TypeValue n) => Var m -> ex1 -> IndigoM inp inp ()
(-=) :: (IsExpr ex1 n, ArithOpHs Sub n m, ArithResHs Sub n m ~ m, TypeValue m, TypeValue n) => Var m -> ex1 -> IndigoM inp inp ()
(*=) :: (IsExpr ex1 n, ArithOpHs Mul n m, ArithResHs Mul n m ~ m, TypeValue m, TypeValue n) => Var m -> ex1 -> IndigoM inp inp ()
(<<=) :: (IsExpr ex1 n, ArithOpHs Lsl n m, ArithResHs Lsl n m ~ m, TypeValue m, TypeValue n) => Var m -> ex1 -> IndigoM inp inp ()
(>>=.) :: (IsExpr ex1 n, ArithOpHs Lsr n m, ArithResHs Lsr n m ~ m, TypeValue m, TypeValue n) => Var m -> ex1 -> IndigoM inp inp ()
(&&=) :: (IsExpr ex1 n, ArithOpHs And n m, ArithResHs And n m ~ m, TypeValue m, TypeValue n) => Var m -> ex1 -> IndigoM inp inp ()
(||=) :: (IsExpr ex1 n, ArithOpHs Or n m, ArithResHs Or n m ~ m, TypeValue m, TypeValue n) => Var m -> ex1 -> IndigoM inp inp ()
(^=) :: (IsExpr ex1 n, ArithOpHs Xor n m, ArithResHs Xor n m ~ m, TypeValue m, TypeValue n) => Var m -> ex1 -> IndigoM inp inp ()
selfCalling :: forall inp p mname. (NiceParameterFull p, TypeValue (GetEntryPointArgCustom p mname)) => EntryPointRef mname -> IndigoM inp (ContractRef (GetEntryPointArgCustom p mname) & inp) ()
contractCalling :: forall inp cp epRef epArg addr exAddr. (HasEntryPointArg cp epRef epArg, ToTAddress cp addr, ToT addr ~ ToT Address, IsExpr exAddr addr, TypeValue epArg) => epRef -> exAddr -> IndigoM inp (Maybe (ContractRef epArg) & inp) ()

-- | Put a document item.
doc :: DocItem di => di -> IndigoM s s ()

-- | Group documentation built in the given piece of code into block
--   dedicated to one thing, e.g. to one entrypoint.
docGroup :: DocGrouping -> IndigoM i o () -> IndigoM i o ()

-- | Give a name to given contract. Apply it to the whole contract code.
contractName :: Text -> IndigoM i o () -> IndigoM i o ()
type IndigoContractCode param store = (HasStorage store, HasSideEffects) => Var param -> IndigoProcedure '[param, store, Ops]
type IndigoEntrypoint param = forall s. param -> IndigoProcedure s
transferTokens :: (IsExpr exp p, IsExpr exm Mutez, IsExpr exc (ContractRef p), NiceParameter p, HasSideEffects) => exp -> exm -> exc -> IndigoM inp inp ()
setDelegate :: (HasSideEffects, IsExpr ex (Maybe KeyHash)) => ex -> IndigoM inp inp ()
createContract :: (TypeValue st, IsExpr exk (Maybe KeyHash), IsExpr exm Mutez, IsExpr exs st, NiceStorage st, NiceParameterFull param, HasSideEffects) => (HasStorage st => Var param -> IndigoM '[param, st, Ops] out ()) -> exk -> exm -> exs -> IndigoM inp (Address & inp) (Var Address)

-- | Utility type for an <a>IndigoM</a> that add one element to the stack
--   and returns a variable pointing at it.
type IndigoFunction s ret = IndigoM s (ScopeOutStack ret s) (ScopeRetVars ret)

-- | Utility type for an <a>IndigoM</a> that does not modify the stack
--   (only the values in it) and returns nothing.
type IndigoProcedure s = IndigoM s s ()

-- | Takes an arbitrary <a>IndigoM</a> and wraps it into an
--   <a>IndigoFunction</a> producing a local scope for its execution. Once
--   it executed, all non-returned variables are cleaned up so that the
--   stack has only returned variables at the top. This also can be
--   interpreted as `if True then f else nop`.
--   
--   Note, that by default we do not define scope inside indigo functions,
--   meaning that once we want to create a new variable or return it from a
--   function we need to do it inside `scope $ instr` construction, for
--   example:
--   
--   ``` f :: IndigoFunction s Natural f = scope $ do *[s]* res &lt;-
--   newVar (0 :: Natural) *[Natural, s]* scope $ do _n &lt;- newVar (1 ::
--   Integer) *[Integer, Natural, s] res += 4 *[Natural, s]* return res
--   *[s]* ```
scope :: forall a inp out. ScopeCodeGen a => IndigoM inp out a -> IndigoFunction inp a

-- | Alias for <a>scope</a> we use in a tutorial.
defFunction :: forall a inp out. ScopeCodeGen a => IndigoM inp out a -> IndigoFunction inp a

-- | A more specific version of <a>defFunction</a> meant to more easily
--   create <tt>IndigoContract</tt>s.
defContract :: ((HasStorage st, HasSideEffects) => IndigoM '[param, st, Ops] out ()) -> (HasStorage st, HasSideEffects) => IndigoProcedure '[param, st, Ops]
fromLorentzFun1 :: (TypeValue ret_a1pK0, IsExpr ex_a1pJX a_a1pJY) => (:->) ((&) a_a1pJY s_a1pJZ) ((&) ret_a1pK0 s_a1pJZ) -> ex_a1pJX -> IndigoM s_a1pJZ ((&) ret_a1pK0 s_a1pJZ) (Var ret_a1pK0)
fromLorentzFun2 :: (TypeValue ret_a1pK9, IsExpr ex_a1pK4 a_a1pK6, IsExpr ex_a1pK5 a_a1pK7) => (:->) ((&) a_a1pK6 ((&) a_a1pK7 s_a1pK8)) ((&) ret_a1pK9 s_a1pK8) -> ex_a1pK4 -> ex_a1pK5 -> IndigoM s_a1pK8 ((&) ret_a1pK9 s_a1pK8) (Var ret_a1pK9)
fromLorentzFun3 :: (TypeValue ret_a1pKk, IsExpr ex_a1pKd a_a1pKg, IsExpr ex_a1pKe a_a1pKh, IsExpr ex_a1pKf a_a1pKi) => (:->) ((&) a_a1pKg ((&) a_a1pKh ((&) a_a1pKi s_a1pKj))) ((&) ret_a1pKk s_a1pKj) -> ex_a1pKd -> ex_a1pKe -> ex_a1pKf -> IndigoM s_a1pKj ((&) ret_a1pKk s_a1pKj) (Var ret_a1pKk)
fromLorentzFun1Void :: IsExpr ex_a1pKo a_a1pKp => (:->) ((&) a_a1pKp s_a1pKq) s_a1pKq -> ex_a1pKo -> IndigoM s_a1pKq s_a1pKq ()
fromLorentzFun2Void :: (IsExpr ex_a1pKv a_a1pKx, IsExpr ex_a1pKw a_a1pKy) => (:->) ((&) a_a1pKx ((&) a_a1pKy s_a1pKz)) s_a1pKz -> ex_a1pKv -> ex_a1pKw -> IndigoM s_a1pKz s_a1pKz ()
fromLorentzFun3Void :: (IsExpr ex_a1pKE a_a1pKH, IsExpr ex_a1pKF a_a1pKI, IsExpr ex_a1pKG a_a1pKJ) => (:->) ((&) a_a1pKH ((&) a_a1pKI ((&) a_a1pKJ s_a1pKK))) s_a1pKK -> ex_a1pKE -> ex_a1pKF -> ex_a1pKG -> IndigoM s_a1pKK s_a1pKK ()


-- | Reimplementation of some syntax sugar
--   
--   You need the following module pragmas to make it work smoothly:
--   
--   {--} {--}
module Indigo.Rebinded

-- | Defines semantics of <tt>if ... then ... else ...</tt> construction
--   for Indigo where the predicate is a generic <tt>exa</tt> for which
--   `IsExpr exa Bool` holds
ifThenElse :: (IfConstraint a b inp, IsExpr exa Bool) => exa -> IndigoM inp xs a -> IndigoM inp ys b -> IndigoM inp (ScopeOutStack a inp) (ScopeRetVars a)
class IsLabel (x :: Symbol) a
fromLabel :: IsLabel x a => a


-- | Standard library for Indigo.
--   
--   As opposed to Expr and Language modules, this module contains quite
--   standard things that are not present in vanilla Michelson and are not
--   typically found in imperative high level languages.
module Indigo.Lib

-- | Indigo version of the <tt>view</tt> macro. It takes a function from
--   view argument to view result and <a>View</a> structure that typically
--   comes from top-level <tt>case</tt>.
view_ :: forall arg r viewExpr inp out. (TypeValue arg, IsoValue arg, NiceParameter r, Typeable r, viewExpr :~> View arg r, HasSideEffects) => (Expr arg -> IndigoM inp out (Expr r)) -> viewExpr -> IndigoM inp out ()

-- | Flipped version of <tt>view_</tt> that is present due to the common
--   appearance of `flip view parameter $ instr` construction. Semantically
--   we "project" the given parameter inside the body of <a>View</a>
--   construction.
project :: forall arg r viewExpr inp out. (TypeValue arg, IsoValue arg, NiceParameter r, Typeable r, viewExpr :~> View arg r, HasSideEffects) => viewExpr -> (Expr arg -> IndigoM inp out (Expr r)) -> IndigoM inp out ()
subGt0 :: (ex1 :~> Natural, ex2 :~> Natural) => ex1 -> ex2 -> (forall st. IndigoM st st ()) -> IndigoFunction s (Maybe Natural)

module Indigo
